<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programming Flix</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon-b0b02b3c.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-e56fce47.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-bf19a4e8.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-4092c1e5.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-dfcd11af.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-328b0d89.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Flix</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/flix/book/" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction-to-flix"><a class="header" href="#introduction-to-flix">Introduction to Flix</a></h1>
<p>Flix is a principled functional, logic, and imperative programming language
developed at <a href="https://cs.au.dk/">Aarhus University</a> and by a community of <a href="https://github.com/flix/flix">open
source contributors</a> in collaboration with
researchers from the <a href="https://uwaterloo.ca/">University of Waterloo</a>, from the
<a href="https://uni-tuebingen.de/">University of Tubingen</a>, and from the <a href="https://di.ku.dk/">University of
Copenhagen</a>.</p>
<p>Flix is inspired by OCaml and Haskell with ideas from Rust and Scala. Flix looks
like Scala, but its type system is based on Hindley-Milner which supports
complete type inference. Flix is a <em>state-of-the-art</em> programming language with
multiple innovative features, including:</p>
<ul>
<li>a polymorphic type and effect system with full type inference.</li>
<li>region-based local mutable memory.</li>
<li>user-defined effects and handlers.</li>
<li>higher-kinded traits with associated types and effects.</li>
<li>embedded first-class Datalog programming.</li>
</ul>
<p>Flix compiles to efficient JVM bytecode, runs on the Java Virtual Machine, and
supports full tail call elimination. Flix has interoperability with Java and can
use JVM classes and methods. Hence the entire Java ecosystem is available from
within Flix.</p>
<p>Flix aims to have world-class Visual Studio Code support. The <a href="#visual-studio-code-extension">Flix Visual
Studio Code extension</a> uses the real Flix compiler hence there is
always a 1:1 correspondence between the Flix language and what is reported in
the editor. The advantages are many: (a) diagnostics are always exact, (b) code
navigation “just works”, and (c) refactorings are always correct.</p>
<h2 id="look-and-feel"><a class="header" href="#look-and-feel">Look and Feel</a></h2>
<p>Here are a few programs to illustrate the look and feel of Flix:</p>
<p>This program illustrates the use of <strong>algebraic data types and pattern matching</strong>:</p>
<pre><code class="language-flix">/// An algebraic data type for shapes.
enum Shape {
    case Circle(Int32),          // circle radius
    case Square(Int32),          // side length
    case Rectangle(Int32, Int32) // height and width
}

/// Computes the area of the given shape using
/// pattern matching and basic arithmetic.
def area(s: Shape): Int32 = match s {
    case Shape.Circle(r)       =&gt; 3 * (r * r)
    case Shape.Square(w)       =&gt; w * w
    case Shape.Rectangle(h, w) =&gt; h * w
}

// Computes the area of a 2 by 4.
def main(): Unit \ IO =
    area(Shape.Rectangle(2, 4)) |&gt; println
</code></pre>
<p>Here is an example that uses <strong>polymorphic records</strong>:</p>
<pre><code class="language-flix">/// Returns the area of the polymorphic record `r`.
/// Note that the use of the type variable `a` permits the record `r`
/// to have labels other than `x` and `y`.
def polyArea[a : RecordRow](r: {x = Int32, y = Int32 | a}): Int32 = r#x * r#y

/// Computes the area of various rectangle records.
/// Note that some records have additional labels.
def polyAreas(): List[Int32] =
    polyArea({x = 1, y = 2}) ::
    polyArea({x = 2, y = 3, z = 4}) :: Nil

def main(): Unit \ IO =
    polyAreas() |&gt; println
</code></pre>
<p>Here is an example that uses <strong>region-based local mutation</strong>:</p>
<pre><code class="language-flix">///
/// We can define pure functions that use
/// internal mutability (impurity) with regions.
/// Regions encapsulate mutability to its declared scope.
///
def deduplicate(l: List[a]): List[a] with Order[a] =
    /// Declare a new region `rc`.
    region rc {

        /// Create a new `MutSet` at region `r`.
        /// This will be used to keep track of
        /// unique elements in `l`.
        let s = MutSet.empty(rc);

        /// The lambda used in the call to `filter`
        /// would be impure without a region.
        List.filter(x -&gt; {
            if (MutSet.memberOf(x, s))
                false // `x` has already been seen.
            else {
                MutSet.add(x, s);
                true
            }
        }, l)
    }
</code></pre>
<p>Here is an example that uses built-in <strong>effects and handlers</strong>:</p>
<pre><code class="language-flix">def main(): Unit \ {Net, IO} =
    run {
        let url = "http://example.com/";
        Logger.info("Downloading URL: '${url}'");
        match HttpWithResult.get(url, Map.empty()) {
            case Result.Ok(response) =&gt;
                let file = "data.txt";
                Logger.info("Saving response to file: '${file}'");
                let body = Http.Response.body(response);
                match FileWriteWithResult.write(str = body, file) {
                    case Result.Ok(_) =&gt;
                        Logger.info("Response saved to file: '${file}'")
                    case Result.Err(err) =&gt;
                        Logger.fatal("Unable to write file: '${err}'")
                }
            case Result.Err(err) =&gt;
                Logger.fatal("Unable to download URL: '${err}'")
        }
    } with FileWriteWithResult.runWithIO
      with HttpWithResult.runWithIO
      with Logger.runWithIO
</code></pre>
<p>Here is an example that <strong>defines its own effects and handlers</strong>:</p>
<pre><code class="language-flix">eff MyPrint {
    def println(s: String): Unit
}

eff MyTime {
    def getCurrentHour(): Int32
}

def sayGreeting(name: String): Unit \ {MyPrint, MyTime} = {
    let hour = MyTime.getCurrentHour();
    if (hour &lt; 12)
        MyPrint.println("Good morning, ${name}")
    else
        MyPrint.println("Good afternoon, ${name}")
}

def main(): Unit \ IO =
    run {
        (sayGreeting("Mr. Bond, James Bond"): Unit)
    } with handler MyPrint {
        def println(s, k) = { println(s); k() }
    } with handler MyTime {
        def getCurrentHour(_, k) = k(11)
    }
</code></pre>
<p>Here is an example that uses <strong>first-class Datalog constraints</strong>:</p>
<pre><code class="language-flix">def reachable(edges: List[(Int32, Int32)], src: Int32, dst: Int32): Bool =
    let db = inject edges into Edge/2;
    let pr = #{
        Path(x, y) :- Edge(x, y).
        Path(x, z) :- Path(x, y), Edge(y, z).
        Reachable() :- Path(src, dst).
    };
    let result = query db, pr select () from Reachable();
    not Vector.isEmpty(result)
</code></pre>
<p>And finally here is an example that uses <strong>structured concurrency with channels
and processes</strong>:</p>
<pre><code class="language-flix">/// A function that sends every element of a list
def sendAll(l: List[Int32], tx: Sender[Int32]): Unit \ Chan =
    match l {
        case Nil     =&gt; ()
        case x :: xs =&gt; Channel.send(x, tx); sendAll(xs, tx)
    }

/// A function that receives n elements
/// and collects them into a list.
def recvN(n: Int32, rx: Receiver[Int32]): List[Int32] \ {Chan, NonDet} =
    match n {
        case 0 =&gt; Nil
        case _ =&gt; Channel.recv(rx) :: recvN(n - 1, rx)
    }

/// A function that calls receive and sends the result on d.
def wait(rx: Receiver[Int32], n: Int32, tx: Sender[List[Int32]]): Unit \ {Chan, NonDet} =
    Channel.send(recvN(n, rx), tx)

/// Spawn a process for send and wait, and print the result.
def main(): Unit \ {Chan, NonDet, IO} = region rc {
    let l = 1 :: 2 :: 3 :: Nil;
    let (tx1, rx1) = Channel.buffered(100);
    let (tx2, rx2) = Channel.buffered(100);
    spawn sendAll(l, tx1) @ rc;
    spawn wait(rx1, List.length(l), tx2) @ rc;
    println(Channel.recv(rx2))
}
</code></pre>
<p>Additional examples can be found in these pages and in the <a href="https://github.com/flix/flix/tree/master/examples">examples folder on
GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Getting started with Flix is straightforward. All you need is <a href="https://adoptium.net/temurin/releases/">Java version 21+</a>.</p>
<p>You can check if Java is installed and its version by typing:</p>
<pre><code class="language-shell">$ java -version
</code></pre>
<p>which should print something like:</p>
<pre><code>openjdk version "21" 2023-09-19 LTS
OpenJDK Runtime Environment Temurin-21+35 (build 21+35-LTS)
OpenJDK 64-Bit Server VM Temurin-21+35 (build 21+35-LTS, mixed mode, sharing)
</code></pre>
<p>If Java is not installed or your version is too old, a newer version can be
downloaded from <a href="https://adoptium.net/temurin/releases/">Adoptium</a>.</p>
<p>Once you have Java 21+ installed there are two ways to proceed:</p>
<ul>
<li>You can use the <a href="https://marketplace.visualstudio.com/items?itemName=flix.flix">Flix VSCode extension</a> (<strong>highly recommended</strong>) or</li>
<li>You can run the Flix compiler from the command line.</li>
</ul>
<h2 id="using-flix-from-vscode"><a class="header" href="#using-flix-from-vscode">Using Flix from VSCode</a></h2>
<p>Flix comes with a fully-featured VSCode plugin. Follow these steps to get
started:</p>
<blockquote>
<ol>
<li>Create a new empty folder (e.g. <code>my-flix-project</code>).</li>
<li>Open VSCode and choose <code>File -&gt; Open Folder</code>.</li>
<li>Create a new file called <code>Main.flix</code> in the folder.</li>
<li>VSCode will ask you want to search the marketplace for extensions. Say “Yes”.</li>
<li>The Flix <em>extension</em> will be downloaded and installed. Once done, it will
ask if you want to download the Flix <em>compiler</em>. Say “Yes” again.</li>
<li>When you see “Starting Flix” followed by “Flix Ready!” everything should be ready.</li>
</ol>
</blockquote>
<p>A screenshot of the Flix Visual Studio Code extension in action:</p>
<p><img src="images/vscode1.png" alt="Visual Studio Code1"></p>
<h2 id="using-flix-from-neovim"><a class="header" href="#using-flix-from-neovim">Using Flix from Neovim</a></h2>
<p>Flix can also be used from <a href="https://neovim.io/">Neovim</a>. Follow these steps to
get started:</p>
<ul>
<li>the <a href="https://github.com/flix/nvim">official plugin</a> relies on features released in Neovim 0.11</li>
<li>check the version of neovim installed</li>
</ul>
<pre><code class="language-shell">nvim --version
</code></pre>
<h3 id="neovim-plugin"><a class="header" href="#neovim-plugin">Neovim Plugin</a></h3>
<p>There is a Lua <a href="https://github.com/flix/nvim">plugin</a> which provides an LSP configuration for the native neovim lsp, and several functions to interact with the flix cli. It’s repo has detailed installation and configuration instructions.
It can be installed with a plugin manager of choice or cloned locally into your neovim runtime path.</p>
<p>The plugin provides no Keymappings but sets the Flix LSP server up, allowing it to work with your default LSP mappings. An example of setting up LSP keymappings with nvim 0.11 can be seen below. Once your <code>LspAttach</code> autocmd has been set the keymappings will apply to <em>all</em> configured lsp servers.</p>
<pre><code class="language-lua">-- create auto command that is triggered when your LSP server attatches to the buffer
vim.api.nvim_create_autocmd('LspAttach', {
  -- give it a name to prevent autocmd conflicts
  group = vim.api.nvim_create_augroup('my.lsp', {}),
  -- the function to run when the server attatches
  callback = function(args)
    -- helper function to set keybinding options with an optional description string
    -- !!! important !!!
    -- `buffer` makes these mappings local to the buffer triggering the autocmd
    local function get_opts(desc)
      return { desc = desc, buffer = args.buf, noremap = true, silent = true }
    end
    -- check that the LSP client supports features before setting bindings
    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))
    if client:supports_method('textDocument/format') then
      vim.keymap.set('n', '&lt;leader&gt;=', vim.lsp.buf.format, get_opts('format buffer'))
    end
    if client:supports_method('textDocument/rename') then
      vim.keymap.set('n', '&lt;leader&gt;rn', vim.lsp.buf.rename, get_opts('rename'))
    end
    vim.keymap.set("n", "&lt;leader&gt;ca", vim.lsp.buf.code_action, get_opts("lsp code action"))
    vim.keymap.set("n", "&lt;leader&gt;cl", vim.lsp.codelens.run, get_opts("lsp codelens run"))
    vim.keymap.set("n", "gr", vim.lsp.buf.references, get_opts("lsp references"))
    vim.keymap.set("n", "gd", vim.lsp.buf.definition, get_opts("lsp definition"))
    vim.keymap.set("n", "&lt;leader&gt;h", vim.lsp.buf.document_highlight, get_opts("lsp document highlight"))
    vim.keymap.set("n", "K", vim.lsp.buf.hover, get_opts("lsp hover"))
    vim.keymap.set("n", "gi", vim.lsp.buf.implementation, get_opts("lsp buf implementation"))
    vim.keymap.set('i', '&lt;C-a&gt;', '&lt;C-x&gt;&lt;C-o&gt;', get_opts("manual expand completion"))
    vim.keymap.set("n", "&lt;leader&gt;rn", vim.lsp.buf.rename, get_opts(""))
    vim.keymap.set("n", "&lt;leader&gt;d", vim.diagnostic.open_float, get_opts("diagnostic open float"))
    vim.keymap.set("n", "&lt;leader&gt;ws", vim.lsp.buf.workspace_symbol, get_opts("lsp workspace symbol"))
    vim.keymap.set("n", "&lt;leader&gt;ds", vim.lsp.buf.document_symbol, get_opts("lsp doc symbol"))
  end
})
</code></pre>
<p>The snippet above provides the following keybindings.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Keybinding</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td><code>gd</code></td><td>Go to definition</td></tr>
<tr><td><code>gi</code></td><td>Go to implementation</td></tr>
<tr><td><code>gr</code></td><td>Find references</td></tr>
<tr><td><code>ctrl+a</code></td><td>Trigger auto-complete</td></tr>
<tr><td><code>shift+k</code></td><td>Hover</td></tr>
<tr><td><code>&lt;leader&gt;rn</code></td><td>Rename symbol</td></tr>
<tr><td><code>&lt;leader&gt;ca</code></td><td>Code actions</td></tr>
<tr><td><code>&lt;leader&gt;cl</code></td><td>Run Code lens</td></tr>
<tr><td><code>&lt;leader&gt;ws</code></td><td>Show workspace symbols</td></tr>
<tr><td><code>&lt;leader&gt;ds</code></td><td>Show document symbols</td></tr>
<tr><td><code>&lt;leader&gt;d</code></td><td>Show diagnostics</td></tr>
<tr><td><code>&lt;leader&gt;h</code></td><td>Show document highlight</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p>Previously <a href="https://github.com/neovim/nvim-lspconfig">lspconfig</a> provided LSP functionality to neovim and lsp configurations. However, after version 0.11 neovim has LSP built in, lspconfig only provides configurations for common lsp servers. This makes its installation less necessary but it is still recommended.</p>
</blockquote>
<p><img src="images/neovim.png" alt="Visual Studio Code1"></p>
<h3 id="manual-configuration"><a class="header" href="#manual-configuration">Manual Configuration</a></h3>
<p>If you would rather setup the LSP server yourself the code from the plugin is as follows.</p>
<ol>
<li>Tell nvim what filetypes are Flix files</li>
</ol>
<pre><code class="language-lua">vim.filetype.add({
  extension = {
    flix = "flix",
  }
})
</code></pre>
<ol start="2">
<li>Configure the Flix LSP for neovim’s native LSP client</li>
</ol>
<pre><code class="language-lua">-- check if "flix" has already been setup
if not vim.lsp.config["flix"] then
  -- create flix LSP configuration for native LSP
  vim.lsp.config('flix', {
    -- choose just one `cmd` definition
    -- for a project local `flix.jar` ie flix.jar is installed in the root of your project
    cmd = { "java", "-jar", "flix.jar", "lsp" },
    -- for a global flix installation ie with "homebrew" or "nix"
    cmd = {"flix", "lsp"},
    filetypes = { "flix" },
    root_markers = { "flix.toml" }, -- where to set the root directory
    cmd_cwd = vim.fs.root(0, { 'flix.toml' }),
    root_dir = vim.fs.root(0, { 'flix.toml' }),
})
end
</code></pre>
<ol start="3">
<li>Create an autocmd to set flix defualts such as comments and indenting, and to run the codelens whenever your flix buffer changes.</li>
</ol>
<pre><code class="language-lua">-- auto commands
-- create named "groups" to prevent autocmd conflicts
local flix = vim.api.nvim_create_augroup("flix.ft", { clear = true })
local flix_lsp = vim.api.nvim_create_augroup("flix.lsp", { clear = true })
-- autocmd that activates when a "flix" buffer is entered
vim.api.nvim_create_autocmd("FileType", {
  group = flix,
  pattern = "flix",
  callback = function(args)
    vim.api.nvim_clear_autocmds({ group = flix_lsp, buffer = args.buf }) -- prevent duplicates
    -- set flix defaults
    vim.opt_local.tabstop = 4
    vim.opt_local.shiftwidth = 4
    vim.opt_local.softtabstop = 4
    vim.bo.commentstring = "// %s"
    -- refresh codelens
    vim.api.nvim_create_autocmd({ 'BufEnter', 'CursorHold', 'InsertLeave' }, {
      group = flix_lsp,
      buffer = args.buf,
      callback = function()
        vim.lsp.codelens.refresh({ bufnr = args.buf })
      end
    })
  end
})
</code></pre>
<blockquote>
<p>place this code in your <code>$HOME/.config/nvim/init.lua</code> or wherever you configure your lsp in neovim.</p>
</blockquote>
<h2 id="using-flix-from-emacs"><a class="header" href="#using-flix-from-emacs">Using Flix from Emacs</a></h2>
<p>Flix can be used from <a href="https://www.gnu.org/software/emacs/">Emacs</a> as well by installing the <a href="https://codeberg.org/mdiin/flix-mode">flix-mode</a> package. Follow the instructions there to get started writing Flix code in Emacs.</p>
<h2 id="using-flix-from-the-cli"><a class="header" href="#using-flix-from-the-cli">Using Flix from the CLI</a></h2>
<p>Flix can also be used from the command line. Follow these steps:</p>
<blockquote>
<ol>
<li>Create a new empty folder (e.g. <code>my-flix-project</code>).</li>
<li>Download the latest <code>flix.jar</code> from <a href="https://github.com/flix/flix/releases/latest">https://github.com/flix/flix/releases/latest</a> and put it into the folder.</li>
<li>Enter the created directory (e.g. <code>cd my-flix-project</code>) and run <code>java -jar flix.jar init</code> to create an empty Flix project.</li>
<li>Run <code>java -jar flix.jar run</code> to compile and run the project.</li>
</ol>
</blockquote>
<h2 id="installing-flix-with-nix"><a class="header" href="#installing-flix-with-nix">Installing Flix with Nix</a></h2>
<p>Flix can also be installed using the <a href="https://nixos.org/">nix package manager</a>.
To install for the currently running shell run:</p>
<pre><code class="language-shell">$ nix-shell -p flix
</code></pre>
<p>Or alternatively to install globally:</p>
<pre><code class="language-shell">$ nix-env -i flix
</code></pre>
<p>Then run <code>flix run</code> in your project directory.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>The most common reasons for Flix not working are (a) the <code>java</code> command not
being on your <code>PATH</code>, (b) the <code>JAVA_HOME</code> environmental variable not being set
or being set incorrectly, or (c) having the wrong version of Java installed. To
debug these issues, ensure that:</p>
<ul>
<li>The command <code>java -version</code> prints the right Java version.</li>
<li>The <code>JAVA_HOME</code> environmental variable is correctly set.
<ul>
<li>On Windows, you can print the variable by typing <code>echo %JAVA_HOME%</code>.</li>
<li>On Mac and Linux, you can print the variable by typing <code>echo $JAVA_HOME</code>.</li>
</ul>
</li>
</ul>
<p>If you are still stuck, you can ask for help on <a href="https://gitter.im/flix/Lobby">Gitter</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>We can now see the famous <em>Hello World</em> program in <code>src/Main.flix</code> file:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    println("Hello World!")
</code></pre>
<p>That’s it!</p>
<p>You will immediately notice a few things are different from other programming
languages:</p>
<ul>
<li>The <code>main</code> function has no formal parameters, in particular it does not take
an arguments array. Instead the command line arguments are available by
calling the <code>Environment.getArgs</code> functions.</li>
<li>The return type of the <code>main</code> function is <code>Unit</code>.</li>
<li>The <code>main</code> function has the <code>IO</code> effect since it prints to the terminal.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h1>
<p>We are now ready write our first real program!</p>
<p>We will write a simple variant of the venerable wordcount (<code>wc</code>) program from
UNIX.</p>
<p>We will use the opportunity to illustrate how to use algebraic effects in Flix.</p>
<pre><code class="language-flix">def wc(file: String): Unit \ {Console, FileReadWithResult} = {
       match FileReadWithResult.readLines(file) {
            case Ok(lines) =&gt; 
                let totalLines = List.length(lines);
                let totalWords = List.sumWith(numberOfWords, lines);
                Console.println("Lines: ${totalLines}, Words: ${totalWords}")
            case Err(_) =&gt; 
                Console.println("Unable to read file: ${file}")
        }
}

def numberOfWords(s: String): Int32 = 
     s |&gt; String.words |&gt; List.length

def main(): Unit \ IO = 
    run {
        wc("Main.flix")
    } with Console.runWithIO
      with FileReadWithResult.runWithIO

</code></pre>
<p>The program works as follows:</p>
<p>We define a <code>wc</code> function that takes a filename and reads all lines from the
file using the algebraic effect <code>FileReadWithResult</code>.</p>
<p>If the file is successfully read, we calculate:</p>
<ul>
<li>The number of lines using <code>List.length</code>.</li>
<li>The number of words by summing the results of applying <code>numberOfWords</code> to each
line.</li>
</ul>
<p>The results are printed to the terminal using the <code>Console</code> algebraic effect.</p>
<p>If the file cannot be read, an error message is printed to the terminal using
the same effect.</p>
<p>The <code>wc</code> function’s type and effect signature specifies the <code>{Console, FileReadWithResult}</code> effect set, indicating these effects are required.
Conceptually, the function is pure except for these effects, which must be
handled by the caller.</p>
<p>The <code>main</code> function calls <code>wc</code> with a fixed filename. Since <code>wc</code> uses the
<code>Console</code> and <code>FileReadWithResult</code> effects, we must provide their
implementations. This is achieved using the <code>run-with</code> construct, where we
specify the default handlers <code>Console.runWithIO</code> and
<code>FileReadWithResult.runWithIO</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<p>Flix comes with a collection of built-in data types,
such as booleans, floats and integers, and
compound types, such as tuples and records.
Moreover, the standard library defines types such as
<code>Option[a]</code>, <code>Result[e, t]</code>, <code>List[a]</code>, <code>Set[a]</code>,
and <code>Map[k, v]</code>.</p>
<p>In addition to these types, Flix allows programmers
to define their own types, including <em>enumerated
types</em>, <em>recursive types</em>, and <em>polymorphic types</em>.</p>
<p>Flix also supports type aliases (new types).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="primitives"><a class="header" href="#primitives">Primitives</a></h1>
<p>Flix supports the primitive types:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Unit</td><td><code>()</code></td><td>The unit value.</td></tr>
<tr><td>Bool</td><td><code>true</code>, <code>false</code></td><td>A boolean value.</td></tr>
<tr><td>Char</td><td><code>'a'</code>, <code>'b'</code>, <code>'c'</code></td><td>A character<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> value.</td></tr>
<tr><td>Float32</td><td><code>0.0f32</code>, <code>21.42f32</code>, <code>-21.42f32</code></td><td>A 32-bit floating point integer.</td></tr>
<tr><td>Float64</td><td><code>0.0f64</code>, <code>21.42f64</code>, <code>-21.42f64</code></td><td>A 64-bit floating point integer.</td></tr>
<tr><td>Int8</td><td><code>0i8</code>, <code>1i8</code>, <code>-1i8</code>, <code>127i8</code>, <code>-128i8</code></td><td>A signed 8-bit integer.</td></tr>
<tr><td>Int16</td><td><code>0i16</code>, <code>123i16</code>, <code>-123i16</code></td><td>A signed 16-bit integer.</td></tr>
<tr><td>Int32</td><td><code>0i32</code>, <code>123i32</code>, <code>-123i32</code></td><td>A signed 32-bit integer.</td></tr>
<tr><td>Int64</td><td><code>0i64</code>, <code>123i64</code>, <code>-123i64</code></td><td>A signed 64-bit integer.</td></tr>
<tr><td>String</td><td><code>"hello"</code>, <code>"world"</code></td><td>A string value.</td></tr>
<tr><td>BigInt</td><td><code>0ii</code>, <code>123ii</code>, <code>-123ii</code></td><td>An arbitrary precision integer.</td></tr>
<tr><td>BigDecimal</td><td><code>0.0ff</code>, <code>123.45ff</code>, <code>-123.45ff</code></td><td>An arbitrary precision decimal.</td></tr>
</tbody>
</table>
</div>
<p><code>Float64</code> and <code>Int32</code> values can be
written without suffix, i.e. <code>123.0f64</code> can simply be written
as <code>123.0</code> and <code>123i32</code> can be written as <code>123</code>.</p>
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<p>Flix has built-in syntactic sugar for lists, sets, maps and regex.</p>
<h3 id="list-literals"><a class="header" href="#list-literals">List Literals</a></h3>
<p>A list literal is written using the infix <code>::</code> constructor. For example:</p>
<pre><code class="language-flix">1 :: 2 :: 3 :: Nil
</code></pre>
<p>which is syntactic sugar for:</p>
<pre><code class="language-flix">Cons(1, Cons(2, Cons(3, Nil)))
</code></pre>
<p>Alternatively, the same list can also be written as:</p>
<pre><code class="language-flix">List#{1, 2, 3}
</code></pre>
<h3 id="set-literals"><a class="header" href="#set-literals">Set Literals</a></h3>
<p>A set literal is written using the notation <code>Set#{v1, v2, ...}</code>. For example:</p>
<pre><code class="language-flix">Set#{1, 2, 3}
</code></pre>
<p>which is syntactic sugar for:</p>
<pre><code class="language-flix">Set.insert(3, Set.insert(2, Set.insert(1, Set.empty())))
</code></pre>
<p>Note that the elements are inserted from left to right, thus 1 is inserted first.</p>
<h3 id="map-literals"><a class="header" href="#map-literals">Map Literals</a></h3>
<p>A map literal is written using the notation
<code>Map#{k1 =&gt; v1, k2 =&gt; v2, ...}</code>.
For example:</p>
<pre><code class="language-flix">Map#{1 =&gt; "Hello", 2 =&gt; "World"}
</code></pre>
<p>which is syntactic sugar for:</p>
<pre><code class="language-flix">Map.insert(2, "World", Map.insert(1, "Hello", Map.empty()))
</code></pre>
<p>Note that similar to sets above, the entries are inserted left to right. In particular, if multiple entries share the same key, the rightmost one overwrites the previous values.</p>
<h3 id="regex-literals"><a class="header" href="#regex-literals">Regex Literals</a></h3>
<p>A regex literal is written using the notation <code>regex"..."</code>. For example:</p>
<pre><code class="language-flix">Regex.isMatch(regex"abc", "abc")
</code></pre>
<p>Additionally, regex literals support regex escape sequences with the following notation <code>regex"\\..."</code>. For example:</p>
<pre><code class="language-flix">Regex.isMatch(regex"\\w", "W")
</code></pre>
<hr>
<ol class="footnote-definition">
<li id="footnote-1">
<p>More precisely, a <code>Char</code> value corresponds to a single UTF-16 code unit. UTF-16 is a variable length encoding:
some of the Unicode code points are represented by a single UTF-16 code unit, but others need two code units.
(Also note that a combination of several Unicode code points may be needed to represent what is usually perceived as
a single character.) <a href="#fr-1-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<p>A tuple is a product of values. The form of a tuple is <code>(exp1, ..., expn)</code>.</p>
<p>For example, here is a 2-tuple (a pair) of an
<code>Int32</code> and a <code>Bool</code>:</p>
<pre><code class="language-flix">(123, true)
</code></pre>
<p>The type of the tuple is <code>(Int32, Bool)</code>.</p>
<p>We can destructure a tuple using pattern matching. For example:</p>
<pre><code class="language-flix">let t = ("Lucky", "Luke", 42, true); // 4-tuple
let (fstName, lstName, age, male) = t;
lstName
</code></pre>
<p>evaluates to the string <code>"Luke"</code>.</p>
<p>The Flix <code>Prelude</code> defines the <code>fst</code> and <code>snd</code> functions:</p>
<pre><code class="language-flix">let t = (1, 2);
let x = fst(t); // x = 1
let y = snd(t)  // y = 2
</code></pre>
<p>which are useful when working with 2-tuples (i.e. pairs). For example:</p>
<pre><code class="language-flix">let l = (1, 1) :: (2, 2) :: Nil; // has type List[(Int32, Int32)]
List.map(fst, l)                 // has type List[Int32]
</code></pre>
<p>which evaluates to the list:</p>
<pre><code class="language-flix">1 :: 2 :: Nil
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<h2 id="enumerated-types"><a class="header" href="#enumerated-types">Enumerated Types</a></h2>
<p>Enumerated types are used to define a type that has
a finite (enumerated) set of values.
Enumerated types are useful for things such as
modeling compass directions, the cards in a deck,
and the days in a week.</p>
<p>For example, here is an enumeration of the days in a
week:</p>
<pre><code class="language-flix">enum Weekday {
    case Monday,
    case Tuesday,
    case Wednesday,
    case Thursday,
    case Friday,
    case Saturday,
    case Sunday
}
</code></pre>
<p>Here <code>Monday</code>, <code>Tuesday</code> and so on are referred to as
the <em>constructors</em> of the enum.</p>
<p>We can refer to a weekday as <code>Monday</code> or
<code>Weekday.Monday</code>.
The latter is required if we have multiple enums in
scope with similarly named constructors.</p>
<p>We can use pattern matching to destruct an enum
value.
For example:</p>
<pre><code class="language-flix">enum Animal {
    case Cat,
    case Dog,
    case Giraffe
}

def isTall(a: Animal): Bool = match a {
    case Animal.Cat        =&gt; false
    case Animal.Dog        =&gt; false
    case Animal.Giraffe    =&gt; true
}
</code></pre>
<p>The function <code>isTall</code> takes a value of type <code>Animal</code>
and performs a pattern match on it.
If the value is <code>Giraffe</code> the function returns
<code>true</code>.
Otherwise it returns <code>false</code>.</p>
<p>Flix guarantees that pattern matches are exhaustive,
i.e. that all cases have been covered.
It is a compile-time error if a pattern match is
non-exhaustive.
A pattern match can always be made exhaustive by
adding a default case as the last case.
A default case is written with an underscore
<code>case _ =&gt; ???</code>.</p>
<h2 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h2>
<p>Recursive types are used to define types that are
self-referential.</p>
<p>For example, we can define a binary tree of integers
as follows:</p>
<pre><code class="language-flix">enum Tree {
    case Leaf(Int32),
    case Node(Tree, Tree)
}
</code></pre>
<p>A tree is either a <code>Leaf</code> with an <code>Int32</code> value or an
internal <code>Node</code> with a left and a right sub-tree.
Note that the definition of <code>Tree</code> refers to itself.</p>
<p>We can write a function, using pattern matching, to
compute the sum of all integers in such a tree:</p>
<pre><code class="language-flix">def sum(t: Tree): Int32 = match t {
    case Tree.Leaf(x)    =&gt; x
    case Tree.Node(l, r) =&gt; sum(l) + sum(r)
}
</code></pre>
<p>The <code>sum</code> function pattern matches on a tree value.
If the tree is a leaf its value is simply returned.
Otherwise the function recurses on both subtrees and
adds their results.</p>
<h2 id="polymorphic-types"><a class="header" href="#polymorphic-types">Polymorphic Types</a></h2>
<p>Polymorphic types are types parameterized by other
types.
For example, we can write:</p>
<pre><code class="language-flix">enum Bottle[a] {
    case Empty,
    case Full(a)
}

def isEmpty(b: Bottle[a]): Bool = match b {
    case Bottle.Empty   =&gt; true
    case Bottle.Full(_) =&gt; false
}
</code></pre>
<p>Here the <code>Bottle</code> type is parameterized by the type
parameter <code>a</code>.
In Flix, type parameters, like ordinary parameters
are always written in lowercase.
The <code>Bottle</code> type has two cases: either the bottle
is empty (and contains no value) or it is full (and
contains one value of type <code>a</code>).
The <code>isEmpty</code> function takes a bottle, type
parameterized by <code>a</code>, and determines if the bottle
is empty.</p>
<p>The careful reader might have noticed that <code>Bottle</code>
is equivalent to the more well-known <code>Option</code> type.</p>
<p>In general, polymorphic types can have more than one
type argument.
For example, the standard library implement of the
<code>Result</code> has two type parameters:</p>
<pre><code class="language-flix">enum Result[e, t] {
    case Ok(t),
    case Err(e)
}
</code></pre>
<h2 id="shorthand-enum-syntax"><a class="header" href="#shorthand-enum-syntax">Shorthand Enum Syntax</a></h2>
<p>A typical enum may look like:</p>
<pre><code class="language-flix">enum Weekday {
    case Monday,
    case Tuesday,
    case Wednesday,
    case Thursday,
    case Friday,
    case Saturday,
    case Sunday
}
</code></pre>
<p>The same enum can also be declared as:</p>
<pre><code class="language-flix">enum Weekday {
    case Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
}
</code></pre>
<p>This shorthand syntax is always available, but should
only be used for simple enums.</p>
<h2 id="singleton-enum-syntax"><a class="header" href="#singleton-enum-syntax">Singleton Enum Syntax</a></h2>
<p>An enum with a single case:</p>
<pre><code class="language-flix">enum USD {
  case USD(Int32)
}
</code></pre>
<p>can be shortened to:</p>
<pre><code class="language-flix">enum USD(Int32)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h1>
<p>Type aliases introduces a short-hand name for a
type.
For example:</p>
<pre><code class="language-flix">///
/// A type alias for a map from keys of type `k`
/// to values of type `Result[String, v]`
///
type alias M[k, v] = Map[k, Result[String, v]]

def foo(): M[Bool, Int32] = Map#{true =&gt; Ok(123)}
</code></pre>
<p>A <em>type alias</em> does not define a new distinct type.
Rather a type alias is simply a syntactic short-hand
for a (usually complex) type.</p>
<p>The Flix compiler expands type aliases before type
checking.
Consequently, type errors are always reported with
respect to the actual underlying types.</p>
<blockquote>
<p><strong>Note:</strong> A type alias cannot be recursively defined in terms
of itself. The Flix compiler will detect and report such
recursive cycles.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions and higher-order functions are the key
building block of a functional programming language.</p>
<p>In Flix, top-level functions are defined with the
<code>def</code> keyword.
For example:</p>
<pre><code class="language-flix">def add(x: Int32, y: Int32): Int32 = x + y + 1
</code></pre>
<p>A definition consists of the function name followed
by an argument list, the return type, and the
function body.
Although Flix supports type
inference, top-level function definitions must
declare the type of their arguments and their return
type.</p>
<p>In Flix, all function arguments and local variables
must be used.
If a function argument is not used it must be
prefixed with an underscore to explicitly mark it as
unused.</p>
<h2 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-Order Functions</a></h2>
<p>A <em>higher-order function</em> is a function that takes a
parameter which is itself a function.
For example:</p>
<pre><code class="language-flix">def twice(f: Int32 -&gt; Int32, x: Int32): Int32 = f(f(x))
</code></pre>
<p>Here the <code>twice</code> function takes two arguments, a
function <code>f</code> and an integer <code>x</code>, and applies <code>f</code> to
<code>x</code> two times.</p>
<p>We can pass a lambda expression to the <code>twice</code>
function:</p>
<pre><code class="language-flix">twice(x -&gt; x + 1, 42)
</code></pre>
<p>which evaluates to <code>44</code> since <code>42</code> is incremented
twice.</p>
<p>We can also define a higher-order function that
requires a function which takes two arguments:</p>
<pre><code class="language-flix">def twice(f: (Int32, Int32) -&gt; Int32, x: Int32): Int32 =
    f(f(x, x), f(x, x))
</code></pre>
<p>which can be called as follows:</p>
<pre><code class="language-flix">twice((x, y) -&gt; x + y, 42)
</code></pre>
<p>We can call a higher-order function with a top-level
function as follows:</p>
<pre><code class="language-flix">def inc(x: Int32): Int32 = x + 1

def twice(f: Int32 -&gt; Int32, x: Int32): Int32 = f(f(x))

twice(inc, 42)
</code></pre>
<h2 id="function-type-syntax"><a class="header" href="#function-type-syntax">Function Type Syntax</a></h2>
<p>Depending on the number of arguments to a function,
the syntax for the function type differs:</p>
<pre><code class="language-flix">Unit -&gt; Int32                // For nullary functions
Int32 -&gt; Int32               // For unary functions
(Int32, Int32, ...) -&gt; Int32 // For the rest
</code></pre>
<h2 id="function-composition"><a class="header" href="#function-composition">Function Composition</a></h2>
<p>Flix supports several operators for function
composition and pipelining:</p>
<pre><code class="language-flix">let f = x -&gt; x + 1;
let g = x -&gt; x * 2;
let h = f &gt;&gt; g;     // equivalent to x -&gt; g(f(x))
</code></pre>
<p>Here <code>&gt;&gt;</code> is forward function composition.</p>
<p>We can also write function applications using the
pipeline operator:</p>
<pre><code class="language-flix">List.range(1, 100) |&gt;
List.filter(x -&gt; x `Int32.mod` 2 == 0) |&gt;
List.map(x -&gt; x * x) |&gt;
println;
</code></pre>
<p>Here <code>x |&gt; f</code> is equivalent to the function
application <code>f(x)</code>.</p>
<h2 id="curried-by-default"><a class="header" href="#curried-by-default">Curried by Default</a></h2>
<p>Functions are curried by default.
A curried function can be called with fewer
arguments than it declares returning a new function
that takes the remainder of the arguments.
For example:</p>
<pre><code class="language-flix">def sum(x: Int32, y: Int32): Int32 = x + y

def main(): Unit \ IO =
    let inc = sum(1);
    inc(42) |&gt; println
</code></pre>
<p>Here the <code>sum</code> function takes two arguments, <code>x</code> and
<code>y</code>, but it is only called with one argument inside
<code>main</code>.
This call returns a new function which is
similar to <code>sum</code>, except that in this function <code>x</code>
is always bound to <code>1</code>.
Hence when <code>inc</code> is called with <code>42</code> it returns <code>43</code>.</p>
<p>Currying is useful in many programming patterns.
For example, consider the <code>List.map</code> function.
This function takes two arguments, a function of
type <code>a -&gt; b</code> and a list of type <code>List[a]</code>, and
returns a <code>List[b]</code> obtained by applying the
function to every element of the list.
Now, if we combine currying with the pipeline
operator <code>|&gt;</code> we are able to write:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    List.range(1, 100) |&gt;
    List.map(x -&gt; x + 1) |&gt;
    println
</code></pre>
<p>Here the call to <code>List.map</code> passes the function
<code>x -&gt; x + 1</code> which <em>returns</em> a new function that
expects a list argument.
This list argument is then supplied by the pipeline
operator <code>|&gt;</code> which, in this case, expects a list
and a function that takes a list.</p>
<h2 id="pipelines"><a class="header" href="#pipelines">Pipelines</a></h2>
<p>Flix supports the pipeline operator <code>|&gt;</code> which is
simply a prefix version of function application (i.e.
the argument appears before the function).</p>
<p>The pipeline operator can often be used to make
functional code more readable.
For example:</p>
<pre><code class="language-flix">let l = 1 :: 2 :: 3 :: Nil;
l |&gt;
List.map(x -&gt; x * 2) |&gt;
List.filter(x -&gt; x &lt; 4) |&gt;
List.count(x -&gt; x &gt; 1)
</code></pre>
<p>Here is another example:</p>
<pre><code class="language-flix">"Hello World" |&gt; String.toUpperCase |&gt; println
</code></pre>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<p>Flix has a number of built-in unary and infix operators.
In addition Flix supports infix function application by enclosing
the function name in backticks. For example:</p>
<pre><code class="language-flix">123 `sum` 456
</code></pre>
<p>is equivalent to the normal function call:</p>
<pre><code class="language-flix">sum(123, 456)
</code></pre>
<p>In addition, a function named with an operator name (some combination of <code>+</code>, <code>-</code>, <code>*</code>, <code>&lt;</code>, <code>&gt;</code>, <code>=</code>, <code>!</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, and <code>$</code>) can also be used infix. For example:</p>
<pre><code class="language-flix">def &lt;*&gt;(x: Int32, y: Int32): Int32 = ???
</code></pre>
<p>can be used as follows:</p>
<pre><code class="language-flix">1 &lt;*&gt; 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="immutable-data"><a class="header" href="#immutable-data">Immutable Data</a></h1>
<p>The <em>bread-and-butter</em> of functional programming is <em>immutable data types</em>.</p>
<p>We have already seen several examples of immutable data types:</p>
<ul>
<li><a href="#primitives">Primitive Types</a></li>
<li><a href="#tuples">Tuple Types</a></li>
<li><a href="#enums">Enumerated, Recursive, and Polymorphic Types</a></li>
</ul>
<p>In addition, The Flix standard library offers several immutable data types:</p>
<ul>
<li><code>List[t]</code>     : An immutable singly-linked list of elements of type <code>t</code>.</li>
<li><code>Chain[t]</code>    : An immutable chain of elements of type <code>t</code> with fast append.</li>
<li><code>Vector[t]</code>   : An immutable sequence of elements of type <code>t</code> with fast lookup.</li>
<li><code>Set[t]</code>      : An immutable set of elements of type <code>t</code>.</li>
<li><code>Map[k, v]</code>   : An immutable map of keys of type <code>k</code> to values of type <code>v</code>.</li>
</ul>
<p>Other immutable data types include:</p>
<ul>
<li><code>Option[t]</code>       : A type that is either <code>None</code> or <code>Some(t)</code>.</li>
<li><code>Result[e, t]</code>    : A type that is either <code>Ok(t)</code> or <code>Err(e)</code>.</li>
<li><code>Nel[t]</code>          : An immutable non-empty singly-linked list of elements of type <code>t</code>.</li>
<li><code>Nec[t]</code>          : An immutable non-empty sequence of elements of type <code>t</code> that supports fast append.</li>
<li><code>MultiMap[k, v]</code>  : An immutable map of keys of type <code>k</code> to <em>sets</em> of values of type <code>v</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lists"><a class="header" href="#lists">Lists</a></h1>
<p>A list is either the empty list, written as <code>Nil</code>,
or a cons cell, written as <code>x :: xs</code> where <code>x</code> is
the head element and <code>xs</code> is the tail of the list.
The <code>List</code> type is polymorphic so you can have a
list of integers, written as <code>List[Int32]</code>, or a
list of strings written as <code>List[String]</code>.</p>
<p>We write the empty list as follows:</p>
<pre><code class="language-flix">Nil
</code></pre>
<p>We can construct a list of strings with the strings
<code>"Hello"</code> and <code>"World"</code> as follows:</p>
<pre><code class="language-flix">"Hello" :: "World" :: Nil
</code></pre>
<p>or using the following notation:</p>
<pre><code class="language-flix">List#{"Hello", "World"}
</code></pre>
<p>Given a list there are many useful operations we can
perform on it.</p>
<p>For example, we can compute the length of a list as
follows:</p>
<pre><code class="language-flix">List.length(1 :: 2 :: 3 :: Nil)
</code></pre>
<p>We can also reverse the order of elements in a list:</p>
<pre><code class="language-flix">List.reverse(1 :: 2 :: 3 :: Nil)
</code></pre>
<p>We can append two lists using the <code>List.append</code>
function as follows:</p>
<pre><code class="language-flix">let xs = (1 :: 2 :: 3 :: Nil);
let ys = (4 :: 5 :: 6 :: Nil);
List.append(xs, ys)
</code></pre>
<p>Or, alternatively, we can use the built-in append
operator <code>:::</code> as follows:</p>
<pre><code class="language-flix">let xs = (1 :: 2 :: 3 :: Nil);
let ys = (4 :: 5 :: 6 :: Nil);
xs ::: ys
</code></pre>
<p>Flix has an extensive collection of functions to
operate on lists.</p>
<p>Here are some of the most common:</p>
<pre><code class="language-flix">List.count(x -&gt; x == 1, 1 :: 2 :: 3 :: Nil);
List.filter(x -&gt; x == 1, 1 :: 2 :: 3 :: Nil);
List.map(x -&gt; x + 1, 1 :: 2 :: 3 :: Nil);
List.foldLeft((x, y) -&gt; x + y, 0, 1 :: 2 :: 3 :: Nil)
</code></pre>
<p>And here are some more exotic functions:</p>
<pre><code class="language-flix">List.intersperse("X", "a" :: "b" :: "c" :: Nil)
</code></pre>
<p>which inserts <code>"X"</code> between every element in the
list.</p>
<pre><code class="language-flix">let l1 = "X" :: "Y" :: Nil;
let l2 = ("a" :: "b" :: Nil) :: ("c" :: "d" :: Nil) :: Nil;
List.intercalate(l1, l2)
</code></pre>
<p>which inserts the list <code>l1</code> between every element in
the list <code>l2</code>.</p>
<p>We can write our own recursive functions to operate
on lists.</p>
<p>For example, here is an implementation of the <code>map</code>
function:</p>
<pre><code class="language-flix">///
/// Returns the result of applying `f` to every element in `l`.
/// That is, the result is of the form: `f(x1) :: f(x2) :: ...`.
///
pub def map(f: a -&gt; b \ ef, l: List[a]): List[b] \ ef = match l {
    case Nil     =&gt; Nil
    case x :: xs =&gt; f(x) :: map(f, xs)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="chains-and-vectors"><a class="header" href="#chains-and-vectors">Chains and Vectors</a></h1>
<p>In addition to immutable <code>List</code>s, Flix also supports immutable <code>Chain</code>s and
<code>Vector</code>s.</p>
<p>The following table illustrates the performance trade-offs between lists,
chains, and vectors:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation \ Type</th><th style="text-align: center">List</th><th style="text-align: center">Chain</th><th style="text-align: center">Vector</th></tr>
</thead>
<tbody>
<tr><td>Find First Element</td><td style="text-align: center">O(1)</td><td style="text-align: center">O(n)</td><td style="text-align: center">O(1)</td></tr>
<tr><td>Find Last Element</td><td style="text-align: center">O(n)</td><td style="text-align: center">O(n)</td><td style="text-align: center">O(1)</td></tr>
<tr><td>Find Element at Index</td><td style="text-align: center">O(n)</td><td style="text-align: center">O(n)</td><td style="text-align: center">O(1)</td></tr>
<tr><td>Cons</td><td style="text-align: center">O(1)</td><td style="text-align: center">O(n)</td><td style="text-align: center">O(n)</td></tr>
<tr><td>Append</td><td style="text-align: center">O(n + m)</td><td style="text-align: center">O(1)</td><td style="text-align: center">O(n + m)</td></tr>
</tbody>
</table>
</div>
<p>When to use <code>List</code>, <code>Chain</code>, or <code>Vector</code>?:</p>
<ul>
<li>The <code>List</code> data structure should be the default choice as it is simple and
well-known.</li>
<li>The <code>Vector</code> data structure is an excellent choice when the size of a
collection is fixed and/or when fast random access is required.</li>
<li>The <code>Chain</code> data structure is more rarely used, but shines when fast appends
are required.</li>
</ul>
<h2 id="chains"><a class="header" href="#chains">Chains</a></h2>
<p>A <code>Chain[t]</code> is an immutable linked sequence of elements.</p>
<p>The <code>Chain[t]</code> data type is defined as:</p>
<pre><code class="language-flix">enum Chain[t] {
    case Empty
    case One(t)
    case Chain(Chain[t], Chain[t])
}
</code></pre>
<p>The data structure supports <code>O(1)</code> append because we can construct a new chain
from two existing chains using the <code>Chain</code> constructor (or more appropriately
using <code>Chain.append</code>).</p>
<p>We can build chains using <code>Chain.empty</code>, <code>Chain.singleton</code>, <code>Chain.cons</code>, and
<code>Chain.append</code>.</p>
<p>For example, we can write:</p>
<pre><code class="language-flix">let c = Chain.cons(1, Chain.empty());
println(c)
</code></pre>
<p>which prints <code>Chain#{1}</code> when compiled and executed.</p>
<h2 id="vectors"><a class="header" href="#vectors">Vectors</a></h2>
<p>A <code>Vector[t]</code> is an immutable fixed-length sequence of contiguous elements of
type <code>t</code>.</p>
<p>Flix has support for <code>Vector</code> literals. For example, we can write:</p>
<pre><code class="language-flix">Vector#{1, 2, 3}
</code></pre>
<p>which creates a vector of length three with the elements: 1, 2, and 3.</p>
<p>Vectors support fast random access with the <code>Vector.get</code> operation:</p>
<pre><code class="language-flix">let v = Vector#{1, 2, 3};
println(Vector.get(2, v))
</code></pre>
<p>which prints <code>3</code> when compiled and executed.</p>
<blockquote>
<p><strong>Warning:</strong> Indexing into a vector beyond its bounds will panic the program.</p>
</blockquote>
<p>Vectors support many operations. For example, we can map a function over a vector:</p>
<pre><code class="language-flix">let v = Vector#{1, 2, 3};
Vector.map(x -&gt; x + 1, v)
</code></pre>
<p>evaluates to <code>Vector#{2, 3, 4}</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sets-and-maps"><a class="header" href="#sets-and-maps">Sets and Maps</a></h1>
<p>Flix has excellent support for (immutable) <code>Set</code>s and <code>Map</code> based on balanced
trees; hence the elements of a <code>Set</code> and the keys of <code>Map</code> must implement the
<code>Order</code> trait.</p>
<blockquote>
<p><strong>Tip:</strong> The Flix <code>Set</code> and <code>Map</code> data structures will automatically
parallelize certain operations. Such operations are marked with
<code>@ParallelWhenPure</code> in the API docs.</p>
</blockquote>
<h2 id="sets"><a class="header" href="#sets">Sets</a></h2>
<p>The empty set is written as:</p>
<pre><code class="language-flix">Set#{}
</code></pre>
<p>which is equivalent to <code>Set.empty()</code>. A set literal is written as:</p>
<pre><code class="language-flix">Set#{1, 2, 3}
</code></pre>
<p>We can insert into a set using <code>Set.insert</code> (which returns a new set):</p>
<pre><code class="language-flix">let s1 = Set#{1, 2, 3};
let s2 = Set.insert(4, s1);
</code></pre>
<p>We can determine if a set contains an element using <code>Set.memberOf</code>:</p>
<pre><code class="language-flix">let s = Set#{1, 2, 3};
Set.memberOf(2, s)
</code></pre>
<p>We can merge two sets using <code>Set.union</code>:</p>
<pre><code class="language-flix">let s1 = Set#{1, 2, 3};
let s2 = Set#{3, 4, 5};
let sr = Set.union(s1, s2);
</code></pre>
<p>Since <code>Set</code>s are <code>SemiGroup</code>s, we can also use the <code>++</code> operator and write <code>s1 ++ s2</code>.</p>
<h2 id="maps"><a class="header" href="#maps">Maps</a></h2>
<p>The empty map is written as:</p>
<pre><code class="language-flix">Map#{}
</code></pre>
<p>which is equivalent to <code>Map.empty()</code>. A map literal is written as:</p>
<pre><code class="language-flix">Map#{"a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3}
</code></pre>
<p>We can insert into a map using <code>Map.insert</code> (which returns a new map):</p>
<pre><code class="language-flix">let m1 = Map#{"a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3};
let m2 = Map.insert("d", 4, m1);
</code></pre>
<p>We can lookup the value associated with a key using <code>Map.get</code>:</p>
<pre><code class="language-flix">let m = Map#{"a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3};
Map.get("b", m) 
</code></pre>
<p>The <code>Map.get</code> function returns an <code>Option[v]</code>.</p>
<p>We can merge two maps using one of <code>Map.unionWith</code> and <code>Map.unionWithKey</code>
functions.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="records"><a class="header" href="#records">Records</a></h1>
<p>Flix supports row polymorphic extensible records.</p>
<p>Flix records are immutable (but may contain mutable reference cells).</p>
<h2 id="record-literals"><a class="header" href="#record-literals">Record Literals</a></h2>
<p>A record literal is written with curly braces:</p>
<pre><code class="language-flix">{ x = 1, y = 2 }
</code></pre>
<p>which has the record type
<code>{ x = Int32, y = Int32 }</code>.</p>
<p>The order of labels in a record does not matter. Hence the above record is
equivalent to:</p>
<pre><code class="language-flix">{ y = 2, x = 1 }
</code></pre>
<p>which has type <code>{ y = Int32, x = Int32 }</code>. This type is equivalent to <code>{ x = Int32, y = Int32 }</code>. In other words, the order of labels within a record type
does not matter.</p>
<h2 id="label-access"><a class="header" href="#label-access">Label Access</a></h2>
<p>We can access the label of a record using a hash:</p>
<pre><code class="language-flix">let p = { x = 1, y = 2 };
p#x + p#y
</code></pre>
<p>The type system ensures that we cannot access a label that does not exist.</p>
<p>Records are immutable. Once constructed, the values of the record labels cannot
be changed.</p>
<h2 id="label-update"><a class="header" href="#label-update">Label Update</a></h2>
<p>While records are immutable, we can construct a new
record with an updated label value:</p>
<pre><code class="language-flix">let p1 = { x = 1, y = 2 };
let p2 = { x = 3 | p1 };
p1#x + p2#x
</code></pre>
<p>The expression <code>{ x = 3 | p1 }</code> updates the record <code>p1</code> with a new value of its
<code>x</code> label. Note that updating a label requires that the label exists on the
record. A record cannot be <em>updated</em> with a new label, but it can be <em>extended</em>
with a new label, as we shall see later.</p>
<h2 id="record-extension"><a class="header" href="#record-extension">Record Extension</a></h2>
<p>We can add a new label to an existing record as follows:</p>
<pre><code class="language-flix">let p1 = { x = 1, y = 2 };
let p2 = { +z = 3 | p1 };
p1#x + p1#y + p2#z
</code></pre>
<p>Here the expression <code>{ +z = 3 | p1 }</code> extends the record <code>p1</code> with a new label
<code>z</code> such that the result has three labels: <code>x</code>, <code>y</code>, and <code>z</code> all of which are of
<code>Int32</code> type.</p>
<h2 id="record-restriction"><a class="header" href="#record-restriction">Record Restriction</a></h2>
<p>Similarly to record extension, we can also remove a label from a record:</p>
<pre><code class="language-flix">let p1 = { x = 1, y = 2 };
let p2 = { -y | p1 };
</code></pre>
<p>Here the record <code>p2</code> has the same labels as <code>p1</code> except that the <code>y</code> label has
been removed.</p>
<h2 id="row-polymorphism"><a class="header" href="#row-polymorphism">Row Polymorphism</a></h2>
<p>A function may specify that it requires a record with two labels:</p>
<pre><code class="language-flix">def f(r: {x = Int32, y = Int32}): Int32 = r#x + r#y
</code></pre>
<p>We can call this function with the records <code>{ x = 1, y = 2 }</code> and <code>{ y = 2, x = 1 }</code>, but we <em>cannot</em> call it with the record <code>{ x = 1, y = 2, z = 3 }</code> since
the signature of <code>f</code> demands a record with <em>exactly</em> two labels: <code>x</code> and <code>y</code>. We
say that the record <code>r</code> is <em>closed</em>.</p>
<p>We can lift this restriction by using row polymorphism:</p>
<pre><code class="language-flix">def g(r: {x = Int32, y = Int32 | s}): Int32 = r#x + r#y
</code></pre>
<p>We can call this function with <em>any</em> record as long as it has <code>x</code> and <code>y</code> labels
which are of type <code>Int32</code>. We say that the record type of <code>r</code> is <em>open</em>.</p>
<h2 id="named-parameters"><a class="header" href="#named-parameters">Named Parameters</a></h2>
<p>When a function has multiple parameters that share the same type, it is easy to
get confused about the right argument order. For example, what does
<code>String.contains("Hello","Hello World")</code> return? What does
<code>String.contains("Hello World", "Hello")</code> return?</p>
<p>A common solution to this problem is to use <em>named parameters</em>. Flix supports a
form of named parameters building on records. For example, we can write a
function translate to translate from one language to another as follows:</p>
<pre><code class="language-flix">def translate(src: {src = Language}, dst: {dst = Language}, text: String): String = ???
</code></pre>
<p>We can call this function as follows:</p>
<pre><code class="language-flix">translate({src = English}, {dst = French}, "Where is the library?")
</code></pre>
<p>Since such verbosity gets tedious, we can also use the syntactic sugar:</p>
<pre><code class="language-flix">translate(src = English, dst = French, "Where is the library?")
</code></pre>
<p>which is equivalent to the above.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mutable-data"><a class="header" href="#mutable-data">Mutable Data</a></h1>
<p>Flix is a <em>functional-first</em> programming language that encourages but does not
demand, the use of immutable data structures. While immutable data structures
should be the default, Flix has rich support for imperative programming with
destructive updates to mutable data.</p>
<p>Flix uses its effect system to separate pure and impure code. In particular,
Flix uses the region concept to track the use of mutable memory. That is, all
mutable memory belongs to some statically-scoped region.</p>
<p>Flix has three basic types of mutable memory:</p>
<ul>
<li><a href="#references">References</a></li>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#structs">Structs</a></li>
</ul>
<p>We can use these data types to build higher-level mutable data structures.
For example, the Flix Standard Library offers collections such as <code>MutList</code>,
<code>MutDeque</code>, <code>MutSet</code>, and <code>MutMap</code>. As a rule, these higher-level data
structures should be preferred over lower-level references and arrays.</p>
<p>We begin this chapter with a discussion of <a href="#regions">regions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="regions"><a class="header" href="#regions">Regions</a></h1>
<p>Flix supports <em>scoped</em> mutable memory. In Flix, all mutable memory belongs to a
<em>region</em> that is tied to its lexical scope. When execution leaves the lexical
scope of a region, all memory in that region becomes unreachable.</p>
<p>Regions are useful because they enable us to implement <em>pure functions</em> that
internally use <em>mutation</em>. We will illustrate this powerful idea with several
real-world examples, but let us first discuss how to use a region:</p>
<p>We introduce a new region scope with the <code>region</code> construct:</p>
<pre><code class="language-flix">region rc { // region starts.
  ...       // the region handle `rc` is in scope.
}           // region ends and all data associated with `rc` is no longer in scope.
</code></pre>
<p>We can use regions to implement a pure <code>sort</code> function that internally uses mutation:</p>
<pre><code class="language-flix">def sort(l: List[a]): List[a] with Order[a] =
    region rc {
        let arr = List.toArray(rc, l);
        Array.sort(arr);
        Array.toList(arr)
    }
</code></pre>
<p>Here we introduce a region named <code>rc</code>. We use the function <code>List.toArray</code> to
convert the list <code>l</code> to a mutable array <code>arr</code> associated with the region <code>rc</code>.
We then sort <code>arr</code> using <code>Array.sort</code> which uses an efficient in-place sorting
algorithm. Finally, we convert the sorted array back to a list and return it.
The <code>sort</code> function is pure, even though it internally uses mutation.</p>
<p>As another example, we can implement a <code>toString</code> function for <code>List[a]</code> which
is pure but internally uses a mutable <code>StringBuilder</code>:</p>
<pre><code class="language-flix">def toString(l: List[a]): String with ToString[a] =
    region rc {
        let sb = StringBuilder.empty(rc);
        List.forEach(x -&gt; StringBuilder.appendString("${x} :: ", sb), l);
        StringBuilder.appendString("Nil", sb);
        StringBuilder.toString(sb)
    } // scope of rc ends, the entire expression is pure.
</code></pre>
<p>The programming pattern is the same: We open a new region, allocate a
<code>StringBuilder</code> in the region, fill the builder with strings, and convert it
into one string.</p>
<p>We can use regions to implement certain <em>functional operations</em> more
efficiently. For example, here is a fast implementation of <code>List.flatMap</code>:</p>
<pre><code class="language-flix">def flatMap(f: a -&gt; List[b] \ ef, l: List[a]): List[b] \ ef =
    region rc {
        let ml = MutList.empty(rc);
        l |&gt; List.forEach(x -&gt; MutList.append(f(x), ml));
        MutList.toList(ml)
    }
</code></pre>
<h2 id="regions-are-values"><a class="header" href="#regions-are-values">Regions are Values</a></h2>
<p>A region (or region handle) is a <em>value</em> that can be passed as a function
argument. This is useful, for example, when we want to write a reusable function
that allocates and returns a mutable data structure.</p>
<p>For example, here is the <code>List.toMutDeque</code> function:</p>
<pre><code class="language-flix">def toMutDeque(rc: Region[r], l: List[a]): MutDeque[a, rc] \ rc =
    let d = MutDeque.empty(rc);
    forEach(x -&gt; MutDeque.pushBack(x, d), l);
    d
</code></pre>
<p>The function takes a region handle <code>rc</code>, allocates a new mutable deque
(<code>MutDeq</code>) in the given region, inserts all elements of the list <code>l</code> in the
deque, and returns it.</p>
<h2 id="regions-are-scoped"><a class="header" href="#regions-are-scoped">Regions are Scoped</a></h2>
<p>Regions and all memory associated with them cannot outlive their lexical scope.</p>
<p>Consider the following program:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    let escaped = region rc {
        Array#{1, 2, 3} @ rc
    };
    println(escaped)
</code></pre>
<p>Here we allocate the <code>Array#{1, 2, 3}</code> in the region <code>rc</code> and try to return it
outside of its enclosing scope. The Flix compiler detects such escape violations
and reports an error:</p>
<pre><code>❌ -- Type Error ----------------------------

&gt;&gt; The region variable 'rc' escapes its scope.

2 |&gt;     let escaped = region rc {
3 |&gt;         Array#{1, 2, 3} @ rc
4 |&gt;     };

region variable escapes.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="references"><a class="header" href="#references">References</a></h1>
<p>Flix supports mutable <em>scoped</em> references. A reference is a box whose value can
change over time. The three key reference operations are:</p>
<ul>
<li>Creating a new reference <code>Ref.fresh(rc, e)</code>.</li>
<li>Dereferencing a reference <code>Ref.get(e)</code>.</li>
<li>Assigning to a reference <code>Ref.put(e, e)</code>.</li>
</ul>
<p>In Flix, the type of a reference is <code>Ref[t, r]</code> where <code>t</code> is the type of the
element and <code>r</code> is its region. Like all mutable memory in Flix, every reference
must belong to some region. Reading from and writing to a reference are
<em>effectful</em> operations. For example, reading the value of a reference <code>Ref[t, r]</code>
has effect <code>r</code>.</p>
<p>The <code>Ref.fresh(rc, e)</code> operation allocates a reference cell in a region of the heap
and returns its location, the <code>Ref.get</code> operation dereferences a location and
returns the content of a reference cell, and the assignment <code>Ref.put</code> operation
changes the value of a reference cell. Informally, a reference cell can be
thought of as an “object” with a single field that can be changed.</p>
<h2 id="allocating-references"><a class="header" href="#allocating-references">Allocating References</a></h2>
<p>A reference cell is allocated with the <code>Ref.fresh(rc, e)</code> function. For example:</p>
<pre><code class="language-flix">region rc {
    let c = Ref.fresh(rc, 42);
    println(Ref.get(c))
}
</code></pre>
<p>Here we introduce a region named <code>rc</code>. Inside the region, we create a reference
cell called <code>c</code> with the value <code>42</code> which we then dereference and print.</p>
<h2 id="dereferencing-references"><a class="header" href="#dereferencing-references">Dereferencing References</a></h2>
<p>A reference cell is accessed (dereferenced) with the <code>Ref.get</code> function. For example:</p>
<pre><code class="language-flix">region rc {
    let c = Ref.fresh(rc, 42);
    let x = Ref.get(c);
    let y = Ref.get(c);
    println(x + y)
}
</code></pre>
<p>Here the program prints <code>42 + 42 = 84</code>.</p>
<h2 id="assignment"><a class="header" href="#assignment">Assignment</a></h2>
<p>We can update the value of a reference cell. For example:</p>
<pre><code class="language-flix">region rc {
    let c = Ref.fresh(rc, 0);
    Ref.put(Ref.get(c) + 1, c);
    Ref.put(Ref.get(c) + 1, c);
    Ref.put(Ref.get(c) + 1, c);
    println(Ref.get(c))
}
</code></pre>
<p>Here the program creates a reference cell <code>c</code> with the value <code>0</code>. We dereference
the cell and increment its value three times. Hence the program prints <code>3</code>.</p>
<h2 id="example-a-simple-counter"><a class="header" href="#example-a-simple-counter">Example: A Simple Counter</a></h2>
<p>We can use references to implement a simple counter:</p>
<pre><code class="language-flix">enum Counter[r: Region] { // The Region here is a type-kind
    case Counter(Ref[Int32, r])
}

def newCounter(rc: Region[r]): Counter[r] \ r = Counter.Counter(Ref.fresh(rc, 0))

def getCount(c: Counter[r]): Int32 \ r =
    let Counter.Counter(l) = c;
    Ref.get(l)

def increment(c: Counter[r]): Unit \ r =
    let Counter.Counter(l) = c;
    Ref.put(Ref.get(l) + 1, l)

def main(): Unit \ IO =
    region rc {
        let c = newCounter(rc);
        increment(c);
        increment(c);
        increment(c);
        getCount(c) |&gt; println
    }
</code></pre>
<p>Here the <code>Counter</code> data type has a region type parameter. This is required since
the counter internally uses a reference that requires a region. Hence <code>Counter</code>s
are also scoped. Note that the <code>newCounter</code> function requires a region handle to
create a new <code>Counter</code>. Moreover, note that the functions <code>getCount</code> and
<code>increment</code> both have the <code>r</code> effect.</p>
<h2 id="aliasing-and-references-to-references"><a class="header" href="#aliasing-and-references-to-references">Aliasing and References to References</a></h2>
<p>References naturally support aliasing since that is their purpose. For example:</p>
<pre><code class="language-flix">region rc {
    let l1 = Ref.fresh(rc, 42);
    let l2 = l1;
    Ref.put(84, l2);
    println(Ref.get(l1))
}
</code></pre>
<p>Prints <code>84</code> because the reference cell that <code>l1</code> points to is modified through
the alias <code>l2</code>.</p>
<p>References can also point to references as the following example illustrates:</p>
<pre><code class="language-flix">region rc {
    let l1 = Ref.fresh(rc, 42);
    let l2 = Ref.fresh(rc, l1);
    let rs = Ref.get(Ref.get(l2));
    println(rs)
}
</code></pre>
<p>Here the type of <code>l2</code> is <code>Ref[Ref[Int32, rc], rc]</code>.</p>
<h2 id="mutable-tuples-and-records"><a class="header" href="#mutable-tuples-and-records">Mutable Tuples and Records</a></h2>
<p>Flix tuples and records are <em>immutable</em>. However, tuples and records may contain
mutable references.</p>
<p>For example, here is a pair that contains two mutable references:</p>
<pre><code class="language-flix">region rc {
    let p = (Ref.fresh(rc, 1), Ref.fresh(rc, 2));
    Ref.put(123, fst(p))
};
</code></pre>
<p>The type of the pair is <code>(Ref[Int32, rc], Ref[Int32, rc])</code>. The assignment does
not change the pair but instead changes the value of the reference cell in the
first component.</p>
<p>Similarly, here is a record that contains two mutable references:</p>
<pre><code class="language-flix">region rc {
    let r = { fstName = Ref.fresh(rc, "Lucky"), lstName = Ref.fresh(rc, "Luke") };
    Ref.put("Unlucky", r#fstName)
};
</code></pre>
<p>The type of the record is <code>{ fstName = Ref[String, rc], lstName = Ref[String, rc] }</code>.
Again, the assignment does not change the record, but instead changes
the value of the reference cell corresponding to the <code>fstName</code> label.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>Flix supports mutable <em>scoped</em> arrays. An array is a fixed-length mutable
sequence of elements that share the same type. Arrays are laid out consecutively
in memory. Arrays are mutable; hence their elements can change over time.
However, once created, the length of an array cannot be changed.</p>
<p>In Flix, the type of an array is <code>Array[t, r]</code> where <code>t</code> is the type of its
elements and <code>r</code> is its region. Like all mutable memory in Flix, every array
must belong to some region. Reading from and writing to arrays are <em>effectful</em>
operations. For example, reading an element from an array of type <code>Array[t, r]</code>
has the effect <code>r</code>. Likewise, creating an array in a region is also an effectful
operation.</p>
<p>Arrays are <em>always</em> unboxed. For example, an array of type <code>Array[Int32, r]</code> is
represented as a sequence of primitive 32-bit integers, i.e., in JVM
terminology, the array is represented as <code>int[]</code>. Flix will never box primitive
integers as <code>java.lang.Integer</code> objects but still permits primitives in generic
collections and functions. The same is true for other types of primitives and
arrays of primitives.</p>
<p>Arrays are low-level data structures typically used to implement higher-level
data structures. Therefore, unless implementing such data structures, we
recommend that arrays are used sparingly. Instead, we recommend using the
<code>MutList</code>, <code>MutDeque</code>, <code>MutSet</code>, and <code>MutMap</code> data structures.</p>
<blockquote>
<p><strong>Hint:</strong> Use <code>MutList</code> if you need a <em>growable</em> mutable sequence of elements.</p>
</blockquote>
<h2 id="array-literals"><a class="header" href="#array-literals">Array Literals</a></h2>
<p>The syntax of an array literal is of the form <code>Array#{e1, e2, e3, ...} @ r</code>
where <code>e1</code>, <code>e2</code>, and so forth are <em>element expressions</em>, and <code>r</code> is the <em>region
expression</em>. For example:</p>
<pre><code class="language-flix">region rc {
    let fruits = Array#{"Apple", "Pear", "Mango"} @ rc;
    println(Array.toString(fruits))
}
</code></pre>
<p>Here we introduce a region named <code>rc</code>. Inside the region, we create an array of
<code>fruits</code> that contain the three strings <code>"Apple"</code>, <code>"Pear"</code>, and <code>"Mango"</code>. The
type of <code>fruits</code> is <code>Array[String, rc]</code>. For more information about regions, we
refer to the chapter on <a href="#regions">Regions</a>.</p>
<p>Running the program prints <code>Array#{"Apple", "Pear", "Mango"}</code>.</p>
<h2 id="allocating-arrays"><a class="header" href="#allocating-arrays">Allocating Arrays</a></h2>
<p>We can allocate an array of size <code>n</code> filled with the same element using the
<code>Array.repeat</code> function. For example:</p>
<pre><code class="language-flix">region rc {
    let arr = Array.repeat(rc, 1_000, 42);
    println(Array.toString(arr))
}
</code></pre>
<p>Here we create an array <code>arr</code> of length <code>1_000</code> where each array element has the
value <code>42</code>. Note that we must pass the region <code>rc</code> as an argument to
<code>Array.repeat</code> because the function must know to which region the returned array
should belong.</p>
<p>We can also create an array filled with all integers from zero to ninety-nine:</p>
<pre><code class="language-flix">region rc {
    let arr = Array.range(rc, 0, 100);
    println(Array.toString(arr))
}
</code></pre>
<p>Moreover, we can convert most data structures to arrays. For example:</p>
<pre><code class="language-flix">region rc {
    let fruitList = List#{"Apple", "Pear", "Mango"};
    let fruitArray = List.toArray(rc, fruitList);
}
</code></pre>
<p>Note that we must pass the region <code>rc</code> as an argument to <code>List.toArray</code> since
the function must know to which region the returned array should belong.</p>
<h2 id="allocating-arrays-with-uninitialized-elements"><a class="header" href="#allocating-arrays-with-uninitialized-elements">Allocating Arrays with Uninitialized Elements</a></h2>
<p>We can use the <code>Array.empty</code> function to create an array of a given length where
the content of the array is uninitialized. For example:</p>
<pre><code class="language-flix">region rc {
    let arr: Array[String, rc] = Array.empty(rc, 100);
    // ... initialize `arr` here ...
}
</code></pre>
<p>Here we create an array of length <code>100</code> of type <code>Array[String, rc]</code>. We use an
explicit type annotation <code>: Array[String, rc]</code> to inform Flix of the expected
type of the array.</p>
<blockquote>
<p><strong>Warning:</strong> It is dangerous to use arrays that have uninitialized elements.</p>
</blockquote>
<p>What are the elements of an uninitialized array? Flix follows Java (and the JVM)
which defines a <em>default value</em> for every primitive– and reference type. So,
for example, the default values for <code>Bool</code> and <code>Int32</code> are <code>false</code> and <code>0</code>,
respectively. The default value for reference types are <code>null</code>. So be careful!
Flix does not have a <code>null</code> value, but one can be indirectly introduced by
reading from improperly initialized arrays which can lead to
<code>NullPointerException</code>s.</p>
<h2 id="reading-from-and-writing-to-arrays"><a class="header" href="#reading-from-and-writing-to-arrays">Reading from and Writing to Arrays</a></h2>
<p>We can retrieve or update the element at a specific position in an array using
<code>Array.get</code> and <code>Array.put</code>, respectively. For example:</p>
<pre><code class="language-flix">region rc {
    let strings = Array.empty(rc, 2);
    Array.put("Hello", 0, strings);
    Array.put("World", 1, strings);
    let s1 = Array.get(0, strings);
    let s2 = Array.get(1, strings);
    println("${s1} ${s2}")
}
</code></pre>
<p>Here we create an empty array of length of two. We then store the string
<code>"Hello"</code> at position zero and the string <code>"World"</code> at position one. Next, we
retrieve the two strings, and print them. Thus the program, when compiled and
run, prints <code>Hello World</code>.</p>
<p>We can also write part of the program in a more <em>fluent-style</em> using the <code>!&gt;</code>
pipeline operator:</p>
<pre><code class="language-flix">let strings =
    Array.empty(rc, 2) !&gt;
    Array.put("Hello", 0) !&gt;
    Array.put("World", 1);
</code></pre>
<h2 id="slicing-arrays"><a class="header" href="#slicing-arrays">Slicing Arrays</a></h2>
<p>We can slice arrays using <code>Array.slice</code>. A slice of an array is a new (shallow)
copy of a sub-range of the original array. For example</p>
<pre><code class="language-flix">region rc {
    let fruits = Array#{"Apple", "Pear", "Mango"} @ rc;
    let result = Array.slice(rc, start = 1, end = 2, fruits);
    println(Array.toString(result))
}
</code></pre>
<p>which prints <code>Array#{"Pear"}</code> when run.</p>
<h2 id="taking-the-length-of-an-array"><a class="header" href="#taking-the-length-of-an-array">Taking the Length of an Array</a></h2>
<p>We can compute the length of an array using the <code>Array.length</code> function. For
example</p>
<pre><code class="language-flix">region rc {
    let fruits = Array#{"Apple", "Pear", "Mango"} @ rc;
    println(Array.length(fruits))
}
</code></pre>
<p>which prints <code>3</code> when run.</p>
<blockquote>
<p><strong>Note</strong>: We advise against indexed-based iteration through arrays. Instead,
we recommend to use functions such as <code>Array.count</code>, <code>Array.forEach</code>, and
<code>Array.transform</code>.</p>
</blockquote>
<h2 id="additional-array-operations"><a class="header" href="#additional-array-operations">Additional Array Operations</a></h2>
<p>The <code>Array</code> module offers an extensive collection of functions for working with
arrays. For example, <code>Array.append</code>, <code>Array.copyOfRange</code>, <code>Array.findLeft</code>,
<code>Array.findRight</code>, <code>Array.sortWith</code>, and <code>Array.sortBy</code> to name a few. In
total, the module offers more than 100 functions ready for use.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Flix supports mutable <em>scoped</em> structs. A struct is a sequence of user-defined
fields. Fields are immutable by default, but can be made mutable by marking them
with the <code>mut</code> modifier. Like all mutable memory in Flix, every struct must
belong to some region.</p>
<p>Structs are the mutable alternative to extensible records which are immutable.</p>
<p>The fields of a struct are unboxed, i.e. primitive types do not cause
indirection. Thus structs are a memory efficient data structure that can be used
to implement higher-level mutable data structures, e.g. mutable lists, mutable
stacks, mutable queues, and so forth.</p>
<p>Flix supports three operations for working with structs:</p>
<ul>
<li>Creating a struct instance in a region with <code>new Struct @ rc { ... }</code>.</li>
<li>Accessing a field of a struct with <code>struct-&gt;field</code>.</li>
<li>Updating a <em>mutable</em> field of a struct with <code>struct-&gt;field = ...</code>.</li>
</ul>
<p>Each operation has an effect in the region of the struct.</p>
<h2 id="declaring-a-struct"><a class="header" href="#declaring-a-struct">Declaring a Struct</a></h2>
<p>We can declare a struct as follows:</p>
<pre><code class="language-flix">struct Person[r] {
    name: String,
    mut age: Int32,
    mut height: Int32
}
</code></pre>
<p>Here we declare a struct with three fields: <code>name</code>, <code>age</code>, and <code>height</code>. The
<code>name</code> field is immutable, i.e. cannot be changed once the struct instance has
been created. The <code>age</code> and <code>heights</code> are mutable and hence can be changed after
creation. The <code>Person</code> struct has one type parameter: <code>r</code> which specifies the
region that the struct belongs to.</p>
<p>Every struct must have a region type parameter and it must be the last in the
type parameter list.</p>
<h2 id="creating-a-struct"><a class="header" href="#creating-a-struct">Creating a Struct</a></h2>
<p>We can create an instance of the <code>Person</code> struct as follows:</p>
<pre><code class="language-flix">mod Person {
    pub def mkLuckyLuke(rc: Region[r]): Person[r] \ r =
        new Person @ rc { name = "Lucky Luke", age = 30, height = 185 }
}
</code></pre>
<p>The <code>mkLuckyLuke</code> function takes one argument: the region capability <code>rc</code> to
associate with the struct.</p>
<p>The syntax:</p>
<pre><code class="language-flix">new Person @ rc { name = "Lucky Luke", age = 30, height = 185 }
</code></pre>
<p>specifies that we create a new instance of the <code>Person</code> struct in the region
<code>rc</code>. We then specify the values of each field of the struct. All struct fields
must be initialized immediately and explicitly.</p>
<h2 id="reading-and-writing-fields"><a class="header" href="#reading-and-writing-fields">Reading and Writing Fields</a></h2>
<p>We can read and write fields of a struct using the field access operator <code>-&gt;</code>. For example:</p>
<pre><code class="language-flix">mod Person {
    pub def birthday(p: Person[r]): Unit \ r =
        p-&gt;age = p-&gt;age + 1;
        if(p-&gt;age &lt; 18) {
            p-&gt;height = p-&gt;height + 10
        } else {
            ()
        }
}
</code></pre>
<p>The <code>birthday</code> function takes a <code>Person</code> struct <code>p</code> and mutates its <code>age</code> and
<code>height</code> fields.</p>
<p>For example, in the line:</p>
<pre><code class="language-flix">p-&gt;age = p-&gt;age + 1;
</code></pre>
<p>we access the current age as <code>p-&gt;age</code>, increment it, and store the result back
in the <code>age</code> field.</p>
<p>We must distinguish between the <em>struct field access operator</em> <code>-&gt;</code> and the
function arrow <code>  -&gt;   </code>. The former has no space around
it, whereas the latter should have space on both sides. In summary:</p>
<ul>
<li><code>s-&gt;f</code>: is a struct field access of field <code>f</code> on struct <code>s</code>.</li>
<li><code>x -&gt; x</code>: is a function from formal parameter <code>x</code> to the variable expression <code>x</code>.</li>
</ul>
<h3 id="field-visibility"><a class="header" href="#field-visibility">Field Visibility</a></h3>
<p>In Flix, the fields of a struct are only visible from within its companion
module. We can think of this as a form of compiler-enforced encapsulation.</p>
<p>For example, if we write:</p>
<pre><code class="language-flix">struct Point[r] {
    x: Int32,
    y: Int32
}

def area(p: Point[r]): Int32 \ r = 
    p-&gt;x * p-&gt;y
</code></pre>
<p>The Flix compiler emits two errors:</p>
<pre><code>❌ -- Resolution Error -------------------------------------------------- 

&gt;&gt; Undefined struct field 'x'.

7 |     p-&gt;x * p-&gt;y
           ^
           undefined field

❌ -- Resolution Error -------------------------------------------------- 

&gt;&gt; Undefined struct field 'y'.

7 |     p-&gt;x * p-&gt;y
                  ^
                  undefined field
</code></pre>
<p>Instead, we should define the <code>area</code> function <em>inside</em> the companion module:</p>
<pre><code class="language-flix">struct Point[r] {
    x: Int32,
    y: Int32
}

mod Point { // Companion module for Point
    pub def area(p: Point[r]): Int32 \ r = 
        p-&gt;x * p-&gt;y
}
</code></pre>
<p>If we want to provide access to the fields of a struct from outside its companion
module, we can introduce explicit getters and setters. For example:</p>
<pre><code class="language-flix">mod Point {
    pub def getX(p: Point[r]): Int32 \ r = p-&gt;x
    pub def getY(p: Point[r]): Int32 \ r = p-&gt;y
}
</code></pre>
<p>Thus access to the fields of struct is tightly controlled.</p>
<h3 id="immutable-and-mutable-fields"><a class="header" href="#immutable-and-mutable-fields">Immutable and Mutable Fields</a></h3>
<p>In Flix, every field of a struct is either immutable or mutable. A mutable field
must be marked with the <code>mut</code> modifier. Otherwise the field is immutable by
default, i.e. the value of the field cannot be changed once the struct instance has
been created.</p>
<p>For example, we can define a struct to represent a user:</p>
<pre><code class="language-flix">struct User[r] {
    id: Int32,
    mut name: String,
    mut email: String
}
</code></pre>
<p>Here the identifier <code>id</code> is immutable and cannot be changed whereas the <code>name</code>
and <code>email</code> fields can be changed over the lifetime of the struct instance.</p>
<p>If we try to modify an immutable field:</p>
<pre><code class="language-flix">mod User {
    pub def changeId(u: User[r]): Unit \ r =
        u-&gt;id = 0
}
</code></pre>
<p>The Flix compiler emits an error:</p>
<pre><code>❌ -- Resolution Error -------------------------------------------------- 

&gt;&gt; Modification of immutable field 'id' on User'.

9 |         u-&gt;id = 0
               ^^
               immutable field

Mark the field as 'mut' in the declaration of the struct.
</code></pre>
<p>We remark that field immutability is <em>not</em> transitive.</p>
<p>For example, we can define a struct:</p>
<pre><code class="language-flix">struct Book[r] {
    title: String,
    authors: MutList[String, r]
}
</code></pre>
<p>where the <code>authors</code> field is immutable.</p>
<p>However, since a <code>MutList</code> can be changed, we can write:</p>
<pre><code class="language-flix">mod Book {
    pub def addAuthor(a: String, b: Book[r]): Unit \ r =
        MutList.push(a, b-&gt;authors)
}
</code></pre>
<p>Here we are not changing the field of the struct. We are changing the underlying
mutable list.</p>
<h2 id="recursive-and-polymorphic-structs"><a class="header" href="#recursive-and-polymorphic-structs">Recursive and Polymorphic Structs</a></h2>
<p>We can define a struct for a binary search tree that is recursive and polymorphic:</p>
<pre><code class="language-flix">struct Tree[k, v, r] {
    key: k,
    mut value: v,
    mut left: Option[Tree[k, v, r]],
    mut right: Option[Tree[k, v, r]]
}
</code></pre>
<p>If we assume that <code>Tree[k, v, r]</code> is sorted, we can define a <code>search</code> function:</p>
<pre><code class="language-flix">mod Tree {
    // A function to search the tree `t` for the given key `k`.
    pub def search(k: k, t: Tree[k, v, r]): Option[v] \ r with Order[k] =
        match (Order.compare(k, t-&gt;key)) {
            case Comparison.EqualTo  =&gt; Some(t-&gt;value)
            case Comparison.LessThan =&gt;
                // Search in the left subtree.
                match t-&gt;left {
                    case None            =&gt; None
                    case Some(leftTree)  =&gt; search(k, leftTree)
                }
            case Comparison.GreaterThan =&gt;
                // Search in the right subtree.
                match t-&gt;right {
                    case None            =&gt; None
                    case Some(rightTree) =&gt; search(k, rightTree)
                }
        }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mutable-collections"><a class="header" href="#mutable-collections">Mutable Collections</a></h1>
<p>The Flix standard library supports many immutable collections, including
options, lists, chains, sets, and maps. We strongly encourage their use.</p>
<p>In addition, the Flix standard library also offers several mutable collections:</p>
<ul>
<li><code>MutList[t, r]</code>      : a contiguous growable/shrinkable array of elements of type <code>t</code>.</li>
<li><code>MutSet[t, r]</code>       : a mutable set of elements of type <code>t</code>.</li>
<li><code>MutMap[k, v, r]</code>    : a mutable map of keys of type <code>k</code> to values of type <code>v</code>.</li>
<li><code>MutDeque[t, r]</code>     : a mutable double-ended queue of elements of type <code>t</code>.</li>
</ul>
<p>Recall that in Flix all mutable memory, including mutable collections, belongs
to a region.</p>
<p>Here is an example of how to use <code>MutList[t]</code>:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    region rc {
        let fruits = MutList.empty(rc);
        MutList.push("Apple", fruits);
        MutList.push("Pear", fruits);
        MutList.push("Mango", fruits);
        MutList.forEach(println, fruits)
    }
</code></pre>
<p>which prints <code>Apple</code>, <code>Pear</code>, and <code>Mango</code>. Here the <code>MutList[String, rc]</code>
automatically expands (and shrinks) as elements are pushed (or popped) from it.</p>
<p>We can write the above program in a more <em>fluent-style</em> using the <code>!&gt;</code> pipeline
operator:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    region rc {
        let fruits =
            MutList.empty(rc) !&gt;
            MutList.push("Apple") !&gt;
            MutList.push("Pear") !&gt;
            MutList.push("Mango");
        MutList.forEach(println, fruits)
    }
</code></pre>
<p>We can split the above program into several functions as follows:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    region rc {
        let fruits = sweetFruits(rc);
        printFruits(fruits)
    }

def sweetFruits(rc: Region[r]): MutList[String, r] \ r =
    MutList.empty(rc) !&gt;
    MutList.push("Apple") !&gt;
    MutList.push("Pear") !&gt;
    MutList.push("Mango")

def printFruits(fruits: MutList[String, r]): Unit \ {r, IO} =
    MutList.forEach(println, fruits)
</code></pre>
<p>Here the <code>main</code> function introduces a new region <code>rc</code>. We pass this region to
<code>sweetFruits</code> which creates and returns a new mutable list of fruits. Note that
<code>sweetFruits</code> has the effect <code>r</code> since it allocates mutable memory using <code>rc</code>.
The <code>printFruits</code> takes a mutable list of fruits and prints them. Note that this
function has effect <code>r</code> since it reads from mutable memory in <code>r</code> and it has
effect <code>IO</code> since it prints to the terminal.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="control-structures"><a class="header" href="#control-structures">Control Structures</a></h1>
<p>Flix — being a functional programming language — has few control-structures.
Most control is simply function application. The Flix control structures are:</p>
<ul>
<li><a href="#if-then-else">If-Then-Else</a>: A traditional if-then-else expression.</li>
<li><a href="#pattern-matching">Pattern Matching</a>: A functional construct for
taking apart algebraic data types.</li>
<li><a href="#foreach">Foreach</a>: An imperative construct for iteration through
collections.</li>
<li><a href="#monadic-for-yield">Monadic For-Yield</a>: A functional construct for
monadic operations, similar to Scala’s <code>for</code>-comprehensions and Haskell’s
<code>do</code>-notation.</li>
<li><a href="#applicative-for-yield">Applicative For-Yield</a>: A functional construct
for applicative operations, similar to Haskell’s applicative <code>do</code>-notation.</li>
</ul>
<p>What’s the difference between <code>foreach</code>, monadic <code>forM</code>, and applicative <code>forA</code>?:</p>
<p>The following table gives some uses cases for each construct:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Action</th><th>Construct</th></tr>
</thead>
<tbody>
<tr><td>Print all elements in a collection.</td><td><a href="#foreach">Foreach</a></td></tr>
<tr><td>Apply an effectful operation to each element in a collection.</td><td><a href="#foreach">Foreach</a></td></tr>
<tr><td>Work with <code>Option</code>s and <code>Result</code>s.</td><td><a href="#monadic-for-yield">Monadic For-Yield</a></td></tr>
<tr><td><code>flatMap</code> through a <code>Monad</code>.</td><td><a href="#monadic-for-yield">Monadic For-Yield</a></td></tr>
<tr><td>Work with <code>Validation</code>s</td><td><a href="#applicative-for-yield">Applicative For-Yield</a></td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Note:</strong> Flix does not have traditional <code>while</code> or <code>for</code>-loops. Instead, we
recommend the use of recursion and/or one of the above constructs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="if-then-else"><a class="header" href="#if-then-else">If-then-else</a></h1>
<p>Flix supports the usual <em>if-then-else</em> expression:</p>
<pre><code class="language-flix">if (1 == 1) "Hello" else "World"
</code></pre>
<p>which evaluates to <code>Hello</code>.</p>
<p>But <code>if</code> guards are also supported in other parts of the language.</p>
<h2 id="guarded-pattern-matches"><a class="header" href="#guarded-pattern-matches">Guarded Pattern Matches</a></h2>
<p>We can use an <code>if</code>-guard in a pattern match:</p>
<pre><code class="language-flix">def isSquare(s: Shape): Bool = match s {
    case Rectangle(h, w) if h == w =&gt; true
    case _                         =&gt; false
}
</code></pre>
<h2 id="guarded-datalog-rules"><a class="header" href="#guarded-datalog-rules">Guarded Datalog Rules</a></h2>
<p>We can use an <code>if</code>-guard in a Datalog rule:</p>
<pre><code class="language-flix">Path(x, z) :- Path(x, y), Edge(y, z), if (x != z).
</code></pre>
<p>Note that the parentheses around the guard are mandatory.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<h2 id="matching-on-enums"><a class="header" href="#matching-on-enums">Matching on Enums</a></h2>
<p>Flix supports pattern matching on algebraic data types.</p>
<p>For example, if we have an algebraic data type that models shapes:</p>
<pre><code class="language-flix">enum Shape {
    case Circle(Int32)
    case Square(Int32)
    case Rectangle(Int32, Int32)
}
</code></pre>
<p>Then we can write a function to compute the area of a <code>Shape</code> using pattern
matching:</p>
<pre><code class="language-flix">def area(s: Shape): Int32 = match s {
    case Shape.Circle(r)       =&gt; 3 * (r * r)
    case Shape.Square(w)       =&gt; w * w
    case Shape.Rectangle(h, w) =&gt; h * w
}
</code></pre>
<h2 id="matching-on-records"><a class="header" href="#matching-on-records">Matching on Records</a></h2>
<p>The above also works for record types; however, the syntax is slightly different.
Let us rewrite the <code>Shape</code> type from before, this time using records.</p>
<pre><code class="language-flix">enum Shape {
    case Circle({ radius = Int32 })
    case Square({ width = Int32 })
    case Rectangle({ height = Int32, width = Int32 })
}

def area(s: Shape): Int32 = match s {
    case Shape.Circle({ radius })           =&gt; 3 * (radius * radius)
    case Shape.Square({ width })            =&gt; width * width
    case Shape.Rectangle({ height, width }) =&gt; height * width
}
</code></pre>
<p>In the example above, we implicitly require that each pattern
has exactly the specified labels.
No more, no less.
However, in general, the syntax for record patterns is similar to their types.
Thus, we can match on a record that has at least one specific label.</p>
<pre><code class="language-flix">def f(r: { height = Int32 | a }): Int32 = match r {
    case { height | _ } =&gt; height
    // The extension has a wildcard pattern since it is unused
}
</code></pre>
<p>Note, however, that the pattern also implies a type,
thus the following example will not work.</p>
<pre><code class="language-flix">def badTypes(r: { height = Int32 | a }): Int32 = match r {
    case { height } =&gt; height
}
</code></pre>
<p>Additionally, all cases must have the same type,
so this will also not work:</p>
<pre><code class="language-flix">match ??? {
    case { height | _ } =&gt; height
    case { height }     =&gt; height
}
</code></pre>
<p>This may be a contrived example, but it
demonstrates a common pitfall, which is easily fixed.</p>
<p>This is because the first case is a polymorphic record
with a defined <code>height</code>-label, whereas the second case
matches on a closed record that <em>only</em> has the
<code>height</code>-label defined.</p>
<p>Additionally, the <code>{ label }</code> pattern is actually
syntactic sugar for <code>{ label = pattern }</code>.
Thus, if you are dealing with multiple records,
then it may be necessary to use different patterns.</p>
<pre><code class="language-flix">def shadowing(r1: { height = Int32 | a }, r2: { height = Int32 | b }): Int32 =
    match (r1, r2) {
        case ({ height | _ }, { height | _ }) =&gt; height + height
        // This does not work because `height = height` is defined twice
    }
</code></pre>
<p>However, renaming the variables makes the program type check.</p>
<pre><code class="language-flix">def renaming(r1: { height = Int32 | a }, r2: { height = Int32 | b }): Int32 =
    match (r1, r2) {
        case ({ height = h1 | _ }, { height = h2 | _ }) =&gt; h1 + h2
    }
</code></pre>
<p>To summarize, here are a few examples of record patterns:</p>
<ul>
<li><code>{ }</code> - the empty record</li>
<li><code>{ radius = r }</code> - a record containg only the label <code>radius</code> where the value is bound to <code>r</code> in the scope</li>
<li><code>{ radius }</code> - a record containing only the label <code>radius</code> (this is actually syntactic sugar for <code>{ radius = radius }</code>)</li>
<li><code>{ radius | _ }</code> - a record containg at least the label <code>radius</code></li>
<li><code>{ radius | r }</code> - a record containg at least the label <code>radius</code> where the rest of the record is bound to <code>r</code></li>
</ul>
<h2 id="let-pattern-match"><a class="header" href="#let-pattern-match">Let Pattern Match</a></h2>
<p>In addition to the pattern <code>match</code> construct, a let-binding can be used to
destruct a value. For example:</p>
<pre><code class="language-flix">let (x, y, z) = (1, 2, 3)
</code></pre>
<p>Binds the variables <code>x</code>, <code>y</code>, and <code>z</code> to the values <code>1</code>, <code>2</code>, and <code>3</code>,
respectively.</p>
<p>Any exhaustive pattern may be used in a let-binding. For example:</p>
<pre><code class="language-flix">let (x, Foo(y, z)) = (1, Foo(2, 3))
</code></pre>
<p>is legal provided that the <code>Foo</code> constructor belongs to a type where it is the
only constructor.</p>
<p>The following let-bindings are <em>illegal</em> because they are not exhaustive:</p>
<pre><code class="language-flix">let (1, 2, z) = ...
let Some(x) = ...
</code></pre>
<p>The Flix compiler will reject such non-exhaustive patterns.</p>
<p>Let-pattern-matches work well with records, as they
allow you to destructure a record and only use the
labels you are interested in:</p>
<pre><code class="language-flix">let { height | _ } = r;
height + height
</code></pre>
<h2 id="match-lambdas"><a class="header" href="#match-lambdas">Match Lambdas</a></h2>
<p>Pattern matches can also be used with lambda expressions. For example:</p>
<pre><code class="language-flix">List.map(match (x, y) -&gt; x + y, (1, 1) :: (2, 2) :: Nil)
</code></pre>
<p>is equivalent to:</p>
<pre><code class="language-flix">List.map(w -&gt; match w { case (x, y) =&gt; x + y }, (1, 1) :: (2, 2) :: Nil)
</code></pre>
<p>As for let-bindings, such pattern matches must be exhaustive.</p>
<p>Note the difference between the two lambda expressions:</p>
<pre><code class="language-flix">let f = (x, y, z) -&gt; x + y + z + 42i32
let g = match (x, y, z) -&gt; x + y + z + 42i32
</code></pre>
<p>Here <code>f</code> is a function that expects <em>three</em> <code>Int32</code> arguments, whereas <code>g</code> is a
function that expects <em>one</em> three tuple <code>(Int32, Int32, Int32)</code> argument.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="foreach"><a class="header" href="#foreach">Foreach</a></h1>
<p>Flix supports a traditional <em>foreach</em> construct that enables imperative
iteration through collections.</p>
<p>We typically use the <em>foreach</em> construct when we want to iterate through one or
more collections and execute an effectful operation for each of their elements.</p>
<p>For example, the program:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    let fruits = List#{"Apple", "Pear", "Mango"};
    foreach (fruit &lt;- fruits) 
        println(fruit)
</code></pre>
<p>Prints the strings <code>Apple</code>, <code>Pear</code>, and <code>Mango</code>.</p>
<p>We can also iterate through multiple collections:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    let fruits = List#{"Apple", "Pear", "Mango"};
    let creams = List#{"Vanilla", "Stracciatella"};
    foreach (fruit &lt;- fruits) 
        foreach (cream &lt;- creams)
            println("Would you like some ${fruit} with ${cream} icecream?")
</code></pre>
<p>The same loop can also be written:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    let fruits = List#{"Apple", "Pear", "Mango"};
    let creams = List#{"Vanilla", "Stracciatella"};
    foreach (fruit &lt;- fruits; cream &lt;- creams) 
        println("Would you like some ${fruit} with ${cream} icecream?")
</code></pre>
<p>We can also write loops with a filter. For example:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    let fruits = List#{"Apple", "Pear", "Mango"};
    let creams = List#{"Vanilla", "Stracciatella"};
    foreach (fruit &lt;- fruits; if isExcotic(fruit); cream &lt;- creams) 
        println("Would you like some ${fruit} with ${cream} icecream?")

def isExcotic(fruit: String): Bool = match fruit {
    case "Mango" =&gt; true
    case _       =&gt; false
}
</code></pre>
<h2 id="adding-optional-braces-for-visual-clarity"><a class="header" href="#adding-optional-braces-for-visual-clarity">Adding Optional Braces for Visual Clarity</a></h2>
<p>We can sometimes improve the visual clarity of a <code>foreach</code> expression by adding
braces:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    let fruits = List#{"Apple", "Pear", "Mango"};
    let creams = List#{"Vanilla", "Stracciatella"};
    foreach (fruit &lt;- fruits) {
        foreach (cream &lt;- creams) {
            println("Would you like some ${fruit} with ${cream} icecream?")
        }
    }
</code></pre>
<p>The braces have no impact on the meaning of the <code>foreach</code> loop; they are purely
stylistic.</p>
<h2 id="the-foreach-trait"><a class="header" href="#the-foreach-trait">The ForEach Trait</a></h2>
<p>We can use the <code>foreach</code> syntax to iterate through any collection type that
implements the <code>ForEach</code> trait. In particular, the <code>ForEach</code> trait
defines a single signature:</p>
<pre><code class="language-flix">///
/// A trait for data structures that support a forEach operation.
///
trait ForEach[t] {

    ///
    /// The type of elements in the data structure.
    ///
    type Elm: Type

    ///
    /// The effect of `forEach`.
    ///
    type Aef: Eff = {}

    ///
    /// Applies `f` to each element in the data structure.
    ///
    pub def forEach(f: ForEach.Elm[t] -&gt; Unit \ ef, t: t): Unit \ (ef + ForEach.Aef[t])

}
</code></pre>
<blockquote>
<p><strong>Note:</strong> Flix expects the expression body of a <code>foreach</code> to have type <code>Unit</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="monadic-for-yield"><a class="header" href="#monadic-for-yield">Monadic For-Yield</a></h1>
<p>Flix supports a monadic <em>forM-yield</em> construct similar to Scala’s
for-comprehensions and Haskell’s do notation. The <em>forM</em> construct is syntactic
sugar for uses of <code>point</code> and <code>flatMap</code> (which are provided by the <code>Monad</code>
trait). The <em>forM</em> construct also supports a <em>guard</em>-expression that uses
<code>empty</code> (which is provided by the <code>MonadZero</code> trait).</p>
<p>For example, the monadic <code>forM</code> expression:</p>
<pre><code class="language-flix">let l1 = 1 :: 2 :: Nil;
let l2 = 1 :: 2 :: Nil;
forM (x &lt;- l1; y &lt;- l2)
    yield (x, y)
</code></pre>
<p>evaluates to the list:</p>
<pre><code class="language-flix">(1, 1) :: (1, 2) :: (2, 1) :: (2, 2) :: Nil
</code></pre>
<h2 id="using-guard-expressions"><a class="header" href="#using-guard-expressions">Using Guard Expressions</a></h2>
<p>We can use <em>guard expressions</em> in <code>forM</code> expressions. For example, the program:</p>
<pre><code class="language-flix">let l1 = 1 :: 2 :: Nil;
let l2 = 1 :: 2 :: Nil;
forM (x &lt;- l1; y &lt;- l2; if x &lt; y)
    yield (x, y)
</code></pre>
<p>evaluates to the list:</p>
<pre><code class="language-flix">(1, 2) :: Nil
</code></pre>
<h2 id="working-with-options-and-results"><a class="header" href="#working-with-options-and-results">Working with Options and Results</a></h2>
<p>We can also use <code>forM</code> to work with the <code>Option</code> data type. For example:</p>
<pre><code class="language-flix">def divide(x: Int32, y: Int32): Option[Int32] = 
    if (y == 0) None else Some(x / y)

def f(): Option[Int32] = 
    forM (
        x &lt;- divide(5, 2);
        y &lt;- divide(x, 8);
        z &lt;- divide(9, y)
    ) yield x + y + z
</code></pre>
<p>Here the function <code>f</code> returns <code>None</code> since <code>x = 5 / 2 = 2</code> and <code>2 / 8 = 0</code> hence
the last division fails.</p>
<p>Similarly, we can use <code>forM</code> to work with the <code>Result[e, t]</code> data type. For
example:</p>
<pre><code class="language-flix">def main(): Result[String, Unit] \ IO = 
    println("Please enter your first name, last name, and age:");
    forM (
        fstName &lt;- Console.readLine();
        lstName &lt;- Console.readLine();
        ageLine &lt;- Console.readLine();
        ageNum  &lt;- Int32.parse(10, ageLine)
    ) yield {
        println("Hello ${lstName}, ${fstName}.");
        println("You are ${ageNum} years old!")
    }
</code></pre>
<p>Here <code>main</code> prompts the user to enter their first name, last name, and age. Each
call to <code>Console.readLine</code> returns a <code>Result[String, String]</code> value which is
either an error or the input string. Thus the local variables <code>fstName</code>,
<code>lstName</code>, and <code>ageLine</code> are <code>String</code>s. We parse <code>ageLine</code> into an <code>Int32</code> using
<code>Int32.parse</code>, which returns a <code>Result[String, Int32]</code> value. If every operation
is successful then we print a greeting and return <code>Ok(())</code> (i.e., <code>Ok</code> of
<code>Unit</code>). Otherwise, we return an <code>Err(msg)</code> value.</p>
<h2 id="working-with-other-monads"><a class="header" href="#working-with-other-monads">Working with Other Monads</a></h2>
<p>We can use <code>forM</code> with other types of <code>Monad</code>s, including <code>Chain</code> and <code>Nel</code>s
(non-empty lists). For example, we can write:</p>
<pre><code class="language-flix">let l1 = Nel(1, 2 :: Nil);
let l2 = Nel(1, 2 :: Nil);
forM (x &lt;- l1; y &lt;- l2)
    yield (x, y)
</code></pre>
<p>which evaluates to the non-empty list:</p>
<pre><code class="language-flix">Nel((1, 1), (1, 2) :: (2, 1) :: (2, 2) :: Nil)
</code></pre>
<blockquote>
<p><strong>Note:</strong> We cannot use an <code>if</code>-guard with non-empty lists because such an
<code>if</code>-guard requires an instance of the <code>MonadZero</code> trait which is not
implemented by non-empty list (since such a list cannot be empty).</p>
</blockquote>
<h2 id="desugaring"><a class="header" href="#desugaring">Desugaring</a></h2>
<p>The <code>forM</code> expression is syntactic sugar for uses of <code>Monad.flatMap</code>,
<code>Applicative.point</code>, and <code>MonadZero.empty</code>.</p>
<p>For example, the expression:</p>
<pre><code class="language-flix">let l1 = 1 :: 2 :: Nil;
let l2 = 1 :: 2 :: Nil;
forM (x &lt;- l1; y &lt;- l2; if x &lt; y)
    yield (x, y)
</code></pre>
<p>is de-sugared to:</p>
<pre><code class="language-flix">Monad.flatMap(x -&gt; 
    Monad.flatMap(y -&gt; 
        if (x &lt; y)
            Applicative.point((x, y))
        else 
            MonadZero.empty(), 
    l2), 
l1);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="applicative-for-yield"><a class="header" href="#applicative-for-yield">Applicative For-Yield</a></h1>
<p>In addition to the monadic <code>forM</code> expression, Flix supports an applicative
<code>forA</code> expression that builds on the <code>Applicative</code> trait. The <code>forA</code>
construct makes it simple to write error-handling code which uses the
<code>Validation[e, t]</code> data type.</p>
<h2 id="working-with-validations"><a class="header" href="#working-with-validations">Working with Validations</a></h2>
<p>We can use the <code>forA</code> expression to validate user input while collecting all
errors.</p>
<pre><code class="language-flix">enum Connection(String, String)

enum InvalidInput {
    case InvalidUserName,
    case InvalidPassword
}

def validateUser(s: String): Validation[InvalidInput, String] =
    if (8 &lt;= String.length(s) and String.forAll(Char.isLetter, s))
        Validation.Success(s)
    else 
        Validation.Failure(Nec.singleton(InvalidInput.InvalidUserName))

def validatePass(s: String): Validation[InvalidInput, String] =
    if (12 &lt;= String.length(s) and String.length(s) &lt;= 20)
        Validation.Success(s)
    else 
        Validation.Failure(Nec.singleton(InvalidInput.InvalidPassword))

def connect(u: String, p: String): Validation[InvalidInput, Connection] = 
    forA (
        user &lt;- validateUser(u);
        pass &lt;- validatePass(p)
    ) yield Connection.Connection(user, pass)
</code></pre>
<p>The expression:</p>
<pre><code class="language-flix">connect("Lucky Luke", "Ratata")
</code></pre>
<p>evaluates to:</p>
<pre><code class="language-flix">Failure(Nec#{InvalidUserName, InvalidPassword})
</code></pre>
<p>which contains <em>both</em> input validation errors. On the other hand, the expression:</p>
<pre><code class="language-flix">connect("luckyluke", "password12356789")
</code></pre>
<p>evaluates to:</p>
<pre><code class="language-flix">Success(Connection(luckyluke, password12356789))
</code></pre>
<h2 id="applicatives-are-independent-computations"><a class="header" href="#applicatives-are-independent-computations">Applicatives are Independent Computations</a></h2>
<p>We can write a monadic <code>forM</code> expression where the result of one monadic
operation is used as the input to another monadic operation. For example:</p>
<pre><code class="language-flix">forM(x &lt;- Some(123);  y &lt;- Some(x)) 
    yield (x, y)
</code></pre>
<p>Here the value of <code>y</code> depends on <code>x</code>. That is, the computation of <code>x</code> and <code>y</code>
are not independent.</p>
<p>If we try to same with the applicative <code>forA</code> expression:</p>
<pre><code class="language-flix">forA(x &lt;- Some(123); y &lt;- Some(x))
    yield (x, y)
</code></pre>
<p>then the Flix compiler emits a compiler error:</p>
<pre><code class="language-flix">❌ -- Resolution Error --------------

&gt;&gt; Undefined name 'x'.

10 |         y &lt;- Some(x)
                       ^
                       name not found
</code></pre>
<p>because the computations of <code>x</code> and <code>y</code> are <em>independent</em> and hence the value of
<code>x</code> is <em>not</em> in scope when we define the value of <code>y</code>.</p>
<h2 id="desugaring-1"><a class="header" href="#desugaring-1">Desugaring</a></h2>
<p>The <code>forA</code> expression is syntactic sugar for uses of <code>Functor.map</code> and
<code>Applicative.ap</code>.</p>
<p>For example, the expression:</p>
<pre><code class="language-flix">let o1 = Some(21);
let o2 = Some(42);
forA(x &lt;- o1; y &lt;- o2) 
    yield x + y;
</code></pre>
<p>is de-sugared to:</p>
<pre><code class="language-flix">Applicative.ap(Functor.map(x -&gt; y -&gt; x + y, o1), o2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="effect-system"><a class="header" href="#effect-system">Effect System</a></h1>
<p>Flix features a state-of-the-art type and effect system fully integrated into
the language. The Flix effect system is powerful and extensive, supporting
effect polymorphism, sub-effecting, effect exclusion, purity reflection, and
associated effects.</p>
<p>We will explore these new and exciting features over the coming pages.</p>
<p>What are the benefits of an effect system? There are many:</p>
<ul>
<li>
<p><strong>(Purity)</strong> A type and effect system separates pure and impure functions. In
Flix, a pure function cannot have any side-effects and must return the same
value when given the same arguments. Nevertheless, a pure function can still
be implemented in an imperative style using mutable data structures as long as
those data structures leave scope when the function ends.</p>
</li>
<li>
<p><strong>(Reasoning)</strong> A type and effect system helps programmers understand how
their programs work by requiring every function to specify its argument and
return types, as well as the side-effects of the function.</p>
</li>
<li>
<p><strong>(Modularity)</strong>  A type and effect system enforces modularity by forcing
programmers to consider what side effects are allowed where in the program.
Moreover, effects — like types — serve as compiler checked
documentation.</p>
</li>
<li>
<p><strong>(Effects and Handlers)</strong> A type and effect system is the foundation for
algebraic effects and handlers. These allow programmers to implement their own
control structures, such as exceptions, async/await, and cooperative
multitasking.</p>
</li>
<li>
<p><strong>(Security)</strong> A type and effect system offers iron-clad guarantees about the
behavior of functions, allowing programmers to increase their trust in unknown
code. For example, if a function is pure, it cannot have any side-effects: it
cannot access the file system, the network, etc. A specific benefit is that
programs become more resistant to supply chain attacks.</p>
</li>
<li>
<p><strong>(Purity Reflection)</strong> The Flix Standard Library (and other library authors
in extension) can use <a href="#purity-reflection">purity reflection</a> to inspect
the purity of function arguments passed to higher-order functions. We can
exploit this information to implement automatic parallelization while
preserving the original semantics of the program. For example, in Flix, the
<code>Set.count</code> function uses parallel evaluation if (a) the set is sufficiently
large and (b) the passed predicate function is pure.</p>
</li>
<li>
<p><strong>(Optimizations)</strong> The Flix compiler exploits purity information for
aggressive dead code elimination and inlining.</p>
</li>
</ul>
<p>The Flix type and effect system is quite sophisticated and requires some
background knowledge to use effectively. In the next couple of sections, we
gradually introduce the features of the type and effect system and give several
examples of its use.</p>
<p>Before we continue, it is important to understand that Flix has three types of effects:</p>
<ul>
<li><a href="#primitive-effects">primitive effects</a></li>
<li><a href="#effects-and-handlers">algebraic effects</a></li>
<li><a href="#mutable-data">heap effects</a></li>
</ul>
<p>We describe how traits and effects interact in the section on <a href="#associated-effects">Associated
Effects</a>.</p>
<h2 id="direct-style"><a class="header" href="#direct-style">Direct Style</a></h2>
<p>Flix is a so-called <em>direct-style</em> programming language with a traditional type
and effect system. This is in contrast to so-called <em>functional effect systems</em>
like <a href="https://typelevel.org/cats-effect/">Cats Effect</a>,
<a href="https://getkyo.io/#/#/">Kyo</a>, and <a href="https://zio.dev/">ZIO</a>. These systems offer a
library-level effect system, essentially a custom <code>IO</code> monad. While this
approach has some advantages, the downsides are at least twofold (a) we do not
get any of the guarantees offered by a traditional type and effect system (e.g.,
we cannot know when a function is pure), and (b) we must write our program in a
monadic-style, which is burdensome.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="primitive-effects"><a class="header" href="#primitive-effects">Primitive Effects</a></h1>
<blockquote>
<p><strong>Note:</strong> This page is slightly updated and pending a rewrite.</p>
</blockquote>
<p>Flix comes with a collection of pre-defined primitive effects. Unlike algebraic
and heap effects, primitive effects cannot be handled and never go out of scope.
A primitive effect represents a side-effect that happens on the machine. It
cannot be undone or reinterpreted.</p>
<p>The most important primitive effect is the <code>IO</code> effect.</p>
<h2 id="the-io-effect"><a class="header" href="#the-io-effect">The <code>IO</code> Effect</a></h2>
<p>The <code>IO</code> effect represents any action that interacts with the world outside the
program. Such actions include printing to the console, creating, reading, and
writing files, accessing the network, and more. The <code>IO</code> represents actions that
<em>change</em> the outside world (e.g., modifying a file) but also actions that merely
<em>access</em> the outside world (e.g., retrieving the current time). Unlike a pure
function, a function with the <code>IO</code> effect may change behavior every time it is
called, even if its arguments are the same. For example, reading the same file
twice is not guaranteed to return the same result since the file may have
changed between the two accesses.</p>
<p>The <code>IO</code> effect, and all other primitive effects, are <em>viral</em>. If a function has
a primitive effect, all its callers will also have that primitive effect. That
is to say, once you have tainted yourself with impurity, you remain tainted.</p>
<h2 id="the-other-primitive-effects"><a class="header" href="#the-other-primitive-effects">The Other Primitive Effects</a></h2>
<ul>
<li><strong>NonDet</strong>: The <code>NonDet</code> effect represents an almost pure computation. For
example, a function that flips a coin is virtually pure; it has no
side-effects. Yet, it may return different results, even when given the same
arguments.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="effect-polymorphism"><a class="header" href="#effect-polymorphism">Effect Polymorphism</a></h1>
<p>In Flix, we can express that a function is pure (i.e. has no side-effects):</p>
<pre><code class="language-flix">def inc(x: Int32): Int32 \ { } = x + 1
                        // ^^^ empty effect set
</code></pre>
<p>The <code>inc</code> function is <em>pure</em> because its effect set is empty. When a function is
pure, we know that the function must return the same value when given the same
arguments. Moreover, the function cannot have any side-effect on the outside
world.</p>
<p>We do not have to write the empty effect set. We can simply write:</p>
<pre><code class="language-flix">def inc(x: Int32): Int32 = x + 1
</code></pre>
<p>In Flix, we can express that a function has a single effect:</p>
<pre><code class="language-flix">def incAndPrint(x: Int32): Int32 \ {IO} = 
    let result = x + 1;         // ^^^^ singleton effect set
    println(result);
    result
</code></pre>
<p>Here the <code>incAndPrint</code> function has the primitive <code>IO</code> effect.</p>
<p>We can also express that a function has multiple effects:</p>
<pre><code class="language-flix">def copyFile(src: File, dst: File): Unit \ {FsRead, FsWrite, IO} = ...
                                         // ^^^^^^^^^^^^^^^^^^^^ multiple effects
</code></pre>
<p>Here the <code>copyFile</code> function has three primitive effects: <code>FsRead</code>, <code>FsWrite</code>,
and <code>IO</code>.</p>
<p>In Flix, we can express a function that has a heap effect:</p>
<pre><code class="language-flix">def nth(i: Int32, a: Array[t, r]): Option[a] \ {r} = ....
                                            // ^^^ heap effect
</code></pre>
<p>Here the <code>nth</code> function has a heap effect in the region <code>r</code>.</p>
<p>We can also write functions that mix different effects:</p>
<pre><code class="language-flix">def strange(a: Array[t, r]): Unit \ {r, Clock, Net, IO} 
                                 // ^^^^^^^^^^^^^^^^^^^ a mixture of effects
</code></pre>
<p>This function has a heap effect <code>r</code> and three primitive effects: <code>Clock</code>,
<code>Net</code>, and <code>IO</code>.</p>
<h2 id="higher-order-functions-1"><a class="header" href="#higher-order-functions-1">Higher-Order Functions</a></h2>
<p>When we write higher-order functions, we must think carefully about their effect behavior.</p>
<p>For example, we can write a higher-order function <code>Set.exists</code>:</p>
<pre><code class="language-flix">def exists(f: a -&gt; Bool \ { }, s: Set[a]): Bool = ...
                          ^^^
</code></pre>
<p>Here the <code>exists</code> function enforces the predicate function <code>f</code> to be pure. Why
would we do this? For at least two reasons: (a) it allows us to hide the
iteration order used in the set, and (b) it allows us to perform the counting in
parallel.</p>
<p>Nevertheless, requiring a function to be pure unless necessary is considered a
bad programming style. Instead, we should write <em>effect polymorphic</em> functions.
An effect polymorphic function is a higher-order function whose effects depend
on the effects of its function arguments.</p>
<p>For example, we can write an effect polymorphic map function:</p>
<pre><code class="language-flix">def map(f: a -&gt; b \ ef, l: List[a]): List[b] \ ef = ...
                    ^^ // effect variable      ^^ effect variable
</code></pre>
<p>The type and effect signature of <code>map</code> states: If <code>map</code> is given a function <code>f</code>
with effects <code>ef</code> then calling <code>map</code> has the effects <code>ef</code>. That is, if <code>f</code> is
pure (i.e. has no effects) then the call to <code>map</code> will be pure. If <code>f</code> has the
<code>IO</code> effect then the call to <code>map</code> will have the <code>IO</code> effect:</p>
<pre><code class="language-flix">List.map(x -&gt; x + 1, l)               // has the { } effect (i.e., is pure)
List.map(x -&gt; {println(x); x + 1}, l) // has the { IO } effect
</code></pre>
<p>A higher-order function that takes multiple function arguments may combine their
effects.</p>
<p>For example, the Flix Standard Library definition of forward function
composition <code>&gt;&gt;</code>takes two functions <code>f</code> and <code>g</code>, and composes them:</p>
<pre><code class="language-flix">def &gt;&gt;(f: a -&gt; b \ ef1, g: b -&gt; c \ ef2): a -&gt; c \ (ef1 + ef2) = x -&gt; g(f(x))
</code></pre>
<p>The type and effect signature of <code>&gt;&gt;</code> states: If <code>map</code> is given two functions
<code>f</code> with effects <code>ef1</code> and <code>g</code> with effects <code>ef2</code> then it returns a new function
which has the union of effects <code>ef1 + ef2</code>.</p>
<p>In Flix, the language of effects is based on set formulas:</p>
<ul>
<li>The <em>complement</em> of <code>ef</code> is written <code>~ef</code>.</li>
<li>The <em>union</em> of <code>ef1</code> and <code>ef2</code> is written <code>ef1 + ef2</code>.</li>
<li>The <em>intersection</em> of <code>ef1</code> and <code>ef2</code> is written <code>ef1 &amp; ef2</code>.</li>
<li>The <em>difference</em> of <code>ef1</code> and <code>ef2</code> is written <code>ef1 - ef2</code>.</li>
</ul>
<p>By far the most common operation is to compute the union of effects.</p>
<p>It’s important to understand that there can be several ways to write the same
effect set. For example, <code>ef1 + ef2</code> is equivalent to <code>ef2 + ef1</code>, as one would
expect.</p>
<h2 id="effect-exclusion"><a class="header" href="#effect-exclusion">Effect Exclusion</a></h2>
<p>A novel feature of Flix is its support for <a href="https://dl.acm.org/doi/abs/10.1145/3607846">effect
exclusion</a>. In simple terms, effect
exclusion allows us to write higher-order functions that disallow specific
effects while allowing all other effects.</p>
<p>For example, we can write an event listener registration function:</p>
<pre><code class="language-flix">def onClick(listener: KeyEvent -&gt; Unit \ (ef - Block), ...): ... 
</code></pre>
<p>Here the <code>onClick</code> function takes an event listener that may have <em>any</em> effect,
<em>except</em> the <code>Block</code> effect. Hence listener can perform any action, except for
an action that would block the UI thread.</p>
<p>As another example, we can write an exception handler function:</p>
<pre><code class="language-flix">def recoverWith(f: Unit -&gt; a \ Throw, h: ErrMsg -&gt; a \ (ef - Throw)): a = ... 
</code></pre>
<p>Here the <code>recoverWith</code> function takes two function arguments: the function <code>f</code>
that may throw an exception and a handler <code>h</code> which can handle the error.
Notably, the effect system enforces that <code>h</code> cannot itself throw an exception.</p>
<h2 id="sub-effecting"><a class="header" href="#sub-effecting">Sub-Effecting</a></h2>
<blockquote>
<p><strong>Note:</strong> This feature is not yet enabled.</p>
</blockquote>
<p>Flix supports <em>sub-effecting</em> which allows an expression or a function to
<em>widen</em> its effect set.</p>
<p>For example, if we write:</p>
<pre><code class="language-flix">if (???) { x -&gt; x + 1 } else { x -&gt; {println(x); x + 1}}
</code></pre>
<p>The first branch should have type <code>Int32 -&gt; Int32 \ { }</code> (i.e. it is pure)
whereas the second branch has type <code>Int32 -&gt; Int32 \ { IO }</code>. Without
sub-effecting these two types are incompatible because <code>{ } != { IO }</code>. However,
because of sub-effecting, Flix gives the first branch the type <code>Int32 -&gt; Int32 \ ef</code> for some fresh effect variable <code>ef</code>. This allows type inference to <em>widen</em>
the effect of the first branch to <code>IO</code>. Hence the compiler is able to type check
the whole expression.</p>
<p>As another example:</p>
<pre><code class="language-flix">def handle(f: Unit -&gt; a \ (ef + Throw)): a = ...
</code></pre>
<p>Here the <code>handle</code> function expects a function argument <code>f</code> with the <code>Throw</code>
effect. However, due to sub-effecting, we can still call the <code>handle</code> function
with a pure function, i.e.:</p>
<pre><code class="language-flix">def handle(x -&gt; Throw.throw(x))    // OK, has the `Throw` effect.
def handle(x -&gt; x)                 // OK, because of sub-effecting.
def handle(x -&gt; println(x))        // Not OK, handle does not permit `IO`.
</code></pre>
<p>Flix also allows sub-effect in instance declarations.</p>
<p>For example, we can define the trait:</p>
<pre><code class="language-flix">trait Foo[t] {
    def f(x: t): Bool \ { IO }
}
</code></pre>
<p>where <code>f</code> has the <code>IO</code> effect. We can implement it:</p>
<pre><code class="language-flix">instance Foo[Int32] {
    def f(x: Int32): Bool = x == 0 // Pure function
}
</code></pre>
<p>The declared effect of <code>f</code> is <code>IO</code>, but here the implementation of <code>f</code> is pure
(i.e., it has the empty effect set <code>{ }</code>). The program still type checks because
<code>{ }</code> can be widened to <code>IO</code>.</p>
<p>Flix, however, does not allow sub-effecting for top-level functions.</p>
<p>For example, if we declare the function:</p>
<pre><code class="language-flix">def foo(): Bool \ IO = true
</code></pre>
<p>The Flix compiler emits the error message:</p>
<pre><code>❌ -- Type Error ------------------------------

&gt;&gt; Expected type: 'IO' but found type: 'Pure'.

1 | def foo(): Bool \ IO = true
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    expression has unexpected type.
</code></pre>
<p>In summary, Flix allows effect widening in two cases: for (a) lambda expressions
and (b) instance definitions. We say that Flix supports <em>abstraction site
sub-effecting</em> and <em>instance definition sub-effecting</em>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="effects-and-handlers"><a class="header" href="#effects-and-handlers">Effects and Handlers</a></h1>
<p>Flix supports algebraic effects and handlers in the style of
<a href="https://www.eff-lang.org/">Eff</a> and <a href="https://koka-lang.github.io/">Koka</a>.</p>
<p>Flix effect handlers use dynamic scope, deep handlers, and support multiple
resumptions.</p>
<p>In this section, we introduce effects and handlers, but we also recommend the
reader take a look at:</p>
<ul>
<li><a href="https://www.eff-lang.org/handlers-tutorial.pdf">An Introduction to Algebraic Effects and Handlers</a> — Matija Pretnar</li>
</ul>
<p>We begin a type of effect most programmers are familiar with: <em>exceptions</em>.</p>
<h2 id="non-resumable-effects-exceptions"><a class="header" href="#non-resumable-effects-exceptions">Non-Resumable Effects: Exceptions</a></h2>
<p>We can use effects and handlers to implement exceptions. For example:</p>
<pre><code class="language-flix">eff DivByZero {
    def divByZero(): Void
}

def divide(x: Int32, y: Int32): Int32 \ DivByZero = 
    if (y == 0) {
        DivByZero.divByZero()
    } else {
        x / y
    }

def main(): Unit \ IO = 
    run {
        println(divide(3, 2));
        println(divide(3, 0))
    } with handler DivByZero {
        def divByZero(_resume) = println("Oops: Division by Zero!")
    }
</code></pre>
<p>Here we declare the effect <code>DivByZero</code> and use it inside the <code>divide</code> function.
Hence the <code>divide</code> function has the <code>DivByZero</code> effect. In <code>main</code> we perform two
divisions. The first succeeds and prints <code>1</code>. The second fails and prints an
error message. The continuation, <code>_resume</code>, is unused and cannot be used because
its argument type is <code>Void</code>. The <code>main</code> function has the <code>IO</code> effect since we
use <code>println</code> in the handler, but it does <em>not</em> have the <code>DivByZero</code> effect
since that has been handled.</p>
<p>Exceptions are non-resumable because once an exception has been raised, we
cannot resume execution from where the exception was thrown. We can only handle
the exception and do something else. We know that <code>DivByZero</code> is an exception
because its effect operation has the <code>Void</code> return type.</p>
<blockquote>
<p><strong>Note:</strong> The <code>Void</code> type is an empty, i.e., uninhabited, type built into
Flix. A function with the return type <code>Void</code> cannot return normally; it only
returns abnormally (e.g., by throwing an exception). Similarly, a function
that takes an argument of type <code>Void</code> cannot be called.</p>
</blockquote>
<p>Recall that Flix supports <a href="#effect-polymorphism">effect polymorphism</a>, hence
the following works without issue:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    let l = List#{1, 2, 0, 3};
    run {
        List.map(x -&gt; println(divide(42, x)), l);
        ()
    } with handler DivByZero {
        def divByZero(_) = println("Oops: Division by Zero!")
    }
</code></pre>
<p>This program will print:</p>
<pre><code>42
21
Oops: Division by Zero!
</code></pre>
<p>Because the first two calls to <code>divide</code> succeed, whereas the last call will
raise a <code>DivByZero</code> exception. Notably, the Flix type and effect system can
track the exception effect through the effect polymorphic call to <code>List.map</code>.</p>
<h2 id="resumable-effects"><a class="header" href="#resumable-effects">Resumable Effects</a></h2>
<p>Flix also supports resumable effects. For example:</p>
<pre><code class="language-flix">import java.time.LocalDateTime

eff HourOfDay {
    def getCurrentHour(): Int32
}

def greeting(): String \ {HourOfDay} = 
    let h = HourOfDay.getCurrentHour();
    if (h &lt;= 12) 
        "Good morning"
    else if (h &lt;= 18)
        "Good afternoon"
    else 
        "Good evening"

def main(): Unit \ IO = 
    run {
        println(greeting())
    } with handler HourOfDay {
        def getCurrentHour(_, resume) = 
            let dt = LocalDateTime.now();
            resume(dt.getHour())
    }
</code></pre>
<p>Here we declare an effect <code>HourOfDay</code> with a single operation that returns the
current hour of the day. Next, we define the <code>greeting</code> function, which uses the
<code>HourOfDay</code> effect to return a greeting appropriate for the current time.
Lastly, in <code>main</code>, we call <code>greeting</code> and print its result. In particular, the
handler for <code>HourOfDay</code> uses Java interoperability to obtain the current hour.</p>
<p>What is important is that when the effect <code>getHourOfDay</code> is called, Flix
captures the current continuation and finds the closest handler (in <code>main</code>),
which <strong>resumes</strong> the computation from within <code>greeting</code> using the current hour
of the day, as obtained from system clock.</p>
<h2 id="multiple-effects-and-handlers"><a class="header" href="#multiple-effects-and-handlers">Multiple Effects and Handlers</a></h2>
<p>We can write functions that use multiple effects:</p>
<pre><code class="language-flix">eff Ask {
    def ask(): String
}

eff Say {
    def say(s: String): Unit
}

def greeting(): Unit \ {Ask, Say} = 
    let name = Ask.ask();
    Say.say("Hello Mr. ${name}")

def main(): Unit \ IO = 
    run {
        greeting()
    } with handler Ask {
        def ask(_, resume) = resume("Bond, James Bond")
    } with handler Say {
        def say(s, resume) = { println(s); resume() }
    }
</code></pre>
<p>Here we declare two effects: <code>Ask</code> and <code>Say</code>. The <code>Ask</code> effect is a consumer: it
needs a string from the environment. The <code>Say</code> effect is a producer: it passes a
string to the environment. We use both effects in <code>greeting</code>. In <code>main</code>, we call
<code>greeting</code> and handle each effect. We handle the <code>Ask</code> effect by always resuming
the continuation with the string <code>"Bond, James Bond"</code>. We handle the <code>Say</code>
effect by printing to the console and resuming the continuation.</p>
<h2 id="multiple-resumptions"><a class="header" href="#multiple-resumptions">Multiple Resumptions</a></h2>
<p>Flix supports algebraic effects with multiple resumptions. We can use such
effects to implement async/await, backtracking search, cooperative
multi-tasking, and more.</p>
<p>Here is a simple example:</p>
<pre><code class="language-flix">eff Amb {
    def flip(): Bool
}

eff Exc {
    def raise(m: String): Void
}

def drunkFlip(): String \ {Amb, Exc} = {
    if (Amb.flip()) {
        let heads = Amb.flip();
        if (heads) "heads" else "tails"
    } else {
        Exc.raise("too drunk to flip")
    }
}

def handleAmb(f: a -&gt; b \ ef): a -&gt; List[b] \ ef - Amb =  
    x -&gt; run {
        f(x) :: Nil
    } with handler Amb {
        def flip(_, resume) = resume(true) ::: resume(false)
    }

def handleExc(f: a -&gt; b \ ef): a -&gt; Option[b] \ ef - Exc = 
    x -&gt; run {
        Some(f(x))
    } with handler Exc {
        def raise(_, _) = None
    }


def main(): Unit \ IO = {
    // Prints: Some(heads) :: Some(tails) :: None :: Nil
    handleAmb(handleExc(drunkFlip))() |&gt; println;

    // Prints: None
    handleExc(handleAmb(drunkFlip))() |&gt; println
}
</code></pre>
<p>Here we declare two effects: <code>Amb</code> (short for ambiguous) and <code>Exc</code> (short for
exception). We then define the <code>drunkFlip</code> function. The idea is to model a
drunk man trying to flip a coin. <strong>First</strong>, we flip a coin to determine if the
man can flip the coin or if he drops it. <strong>Second</strong>, if the flip was successful,
we flip the coin again to obtain either heads or tails. What is important is
that <code>drunkFlip</code> conceptually has three outcomes: “heads”, “tails”, or “too
drunk”.</p>
<p>Next, we define two effect handlers: <code>handleAmb</code> and <code>handleExc</code>. Starting with
the latter, the <code>Exc</code> handler catches the exception and returns <code>None</code>. If no
exception is raised, it returns <code>Some(x)</code> of the computed value. The <code>Amb</code>
handler handles the <code>flip</code> effect by calling the continuation <strong>twice</strong> with
<code>true</code> and <code>false</code>, and collecting the result in a list. In other words, the
<code>Amb</code> handler explores <strong>both</strong> outcomes of flipping a coin.</p>
<p>In <code>main</code>, we use the two effect handlers. Notably, the <em>nesting order of
handlers matters</em>! If we handle the <code>Exc</code> effect first then we obtain the list
<code>Some(heads) :: Some(tails) :: None :: Nil</code>. If, on the other hand, we handle
<code>Exc</code> last then the whole computation fails with <code>None</code>.</p>
<h2 id="algebraic-effects-and-monads"><a class="header" href="#algebraic-effects-and-monads">Algebraic Effects and Monads</a></h2>
<p>Flix supports algebraic effect handlers and <a href="#monadic-for-yield">monads</a>
because we want to support both styles of programming:</p>
<ul>
<li>
<p>If you want to program with effect handlers, you can do that.</p>
</li>
<li>
<p>If you want to program with functors, applicative functors, and monads, you can do that.</p>
</li>
</ul>
<p>Flix does not (yet) define an <code>IO</code> monad, but you can roll your own.</p>
<p>The Flix Standard Library is biased towards a hybrid. We use algebraic effects
to model interaction with the outside world but prefer the <code>Option</code> and <code>Result</code>
data types for simple error handling. Working with <code>Option</code>s and <code>Result</code>s is
more pleasant with <a href="#monadic-for-yield">monadic syntax</a>.</p>
<h2 id="limitation-polymorphic-effects"><a class="header" href="#limitation-polymorphic-effects">Limitation: Polymorphic Effects</a></h2>
<p>The Flix type and effect system does not yet support polymorphic effects.<sup class="footnote-reference" id="fr-1-1-1"><a href="#footnote-1-1">1</a></sup></p>
<p>For example, we <em>cannot</em> declare a polymorphic <code>Throw[a]</code> effect:</p>
<pre><code class="language-flix">eff Throw[a] {
    def throw(x: a): Void
}
</code></pre>
<p>The Flix compiler emits the error message:</p>
<pre><code>❌ -- Syntax Error --

&gt;&gt; Unexpected effect type parameters.

1 | eff Throw[a] {
              ^
              unexpected effect type parameters
</code></pre>
<p>Unfortunately, if we need to throw values of different types, we have to declare
different effects.</p>
<p>For example:</p>
<pre><code class="language-flix">eff ThrowBool {
    def throw(x: Bool): Void
}

eff ThrowInt32 {
    def throw(x: Int32): Void
}
</code></pre>
<h2 id="unhandled-effects-in-new-object-and-spawn-expressions"><a class="header" href="#unhandled-effects-in-new-object-and-spawn-expressions">Unhandled Effects in New Object and Spawn Expressions</a></h2>
<p>Flix does not permit unhandled effects in new object expressions nor in spawn
expressions.</p>
<p>For example, if we write:</p>
<pre><code class="language-flix">eff Ask {
    def ask(): String
}

def main(): Unit \ IO = 
    region rc {
        spawn Ask.ask() @ rc
    }
</code></pre>
<p>The Flix compiler emits the error message:</p>
<pre><code>-- Safety Error -------------------------------------------------- 

&gt;&gt; Illegal spawn effect: 'Ask'. 

&gt;&gt; A spawn expression must be pure or have a primitive effect.

7 |         spawn do Ask.ask() @ rc
                  ^^^^^^^^^^^^
                  illegal effect.
</code></pre>
<hr>
<ol class="footnote-definition">
<li id="footnote-1-1">
<p>We are currently investigating how to lift this restriction. <a href="#fr-1-1-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="library-effects"><a class="header" href="#library-effects">Library Effects</a></h1>
<p>The Flix Standard Library comes with a collection of algebraic effects and
handlers.</p>
<h2 id="clock"><a class="header" href="#clock">Clock</a></h2>
<p>Flix defines a <code>Clock</code> effect to access the time since the <a href="https://en.wikipedia.org/wiki/Unix_time">UNIX epoch</a>:</p>
<pre><code class="language-flix">eff Clock {
    /// Returns a measure of time since the epoch in the given time unit `u`.
    def currentTime(u: TimeUnit): Int64
}
</code></pre>
<pre><code class="language-flix">mod Clock {
    /// Runs `f` handling the `Clock` effect using `IO`.
    def runWithIO(f: Unit -&gt; a \ ef): a \ (ef - Clock) + IO

    /// Returns `f` with the `Clock` effect handled using `IO`.
    def handle(f: a -&gt; b \ ef): a -&gt; b \ (ef - Clock) + IO
}
</code></pre>
<p>Every effect in the standard library comes with <code>handle</code> and <code>runWithIO</code>
functions.</p>
<h3 id="example-using-clock"><a class="header" href="#example-using-clock">Example: Using <code>Clock</code></a></h3>
<pre><code class="language-flix">def main(): Unit \ IO = 
    run {
        let timestamp = Clock.currentTime(TimeUnit.Milliseconds);
        println("${timestamp} ms since the epoc")
    } with Clock.runWithIO
</code></pre>
<h2 id="console"><a class="header" href="#console">Console</a></h2>
<p>Flix defines a <code>Console</code> effect to read from and write to shell:</p>
<pre><code class="language-flix">eff Console {
    /// Reads a single line from the console.
    def readln(): String

    /// Prints the given string `s` to the standard out.
    def print(s: String): Unit

    /// Prints the given string `s` to the standard err.
    def eprint(s: String): Unit

    /// Prints the given string `s` to the standard out followed by a new line.
    def println(s: String): Unit

    /// Prints the given string `s` to the standard err followed by a new line.
    def eprintln(s: String): Unit
}
</code></pre>
<h3 id="example-using-console"><a class="header" href="#example-using-console">Example: Using <code>Console</code></a></h3>
<pre><code class="language-flix">def main(): Unit \ IO = 
    run {
        Console.println("Please enter your name: ");
        let name = Console.readln();
        Console.println("Hello ${name}")
    } with Console.runWithIO
</code></pre>
<h2 id="filereadwithresult"><a class="header" href="#filereadwithresult">FileReadWithResult</a></h2>
<p>Flix defines a <code>FileReadWithResult</code> effect to read from the file system:</p>
<pre><code class="language-flix">eff FileReadWithResult {
    /// Returns `true` if the given file `f` exists.
    def exists(f: String): Result[IoError, Bool]

    /// Returns `true` is the given file `f` is a directory.
    def isDirectory(f: String): Result[IoError, Bool]

    /// Returns `true` if the given file `f` is a regular file.
    def isRegularFile(f: String): Result[IoError, Bool]

    /// Returns `true` if the given file `f` is readable.
    def isReadable(f: String): Result[IoError, Bool]

    /// Returns `true` if the given file `f` is a symbolic link.
    def isSymbolicLink(f: String): Result[IoError, Bool]

    /// Returns `true` if the given file `f` is writable.
    def isWritable(f: String): Result[IoError, Bool]

    /// Returns `true` if the given file `f` is executable.
    def isExecutable(f: String): Result[IoError, Bool]

    /// Returns the last access time of the given file `f` in milliseconds since the epoch.
    def accessTime(f: String): Result[IoError, Int64]

    /// Returns the creation time of the given file `f` in milliseconds since the epoch.
    def creationTime(f: String): Result[IoError, Int64]

    /// Returns the last-modified timestamp of the given file `f` in milliseconds since the epoch.
    def modificationTime(f: String): Result[IoError, Int64]

    /// Returns the size of the given file `f` in bytes.
    def size(f: String): Result[IoError, Int64]

    /// Returns a string of all lines in the given file `f`.
    def read(f: String): Result[IoError, String]

    /// Returns a list of all lines in the given file `f`.
    def readLines(f: String): Result[IoError, List[String]]

    /// Returns a vector of all the bytes in the given file `f`.
    def readBytes(f: String): Result[IoError, Vector[Int8]]

    /// Returns a list with the names of all files and directories in the given directory `d`.
    def list(f: String): Result[IoError, List[String]]
}
</code></pre>
<h3 id="example-using-filereadwithresult"><a class="header" href="#example-using-filereadwithresult">Example: Using <code>FileReadWithResult</code></a></h3>
<pre><code class="language-flix">def main(): Unit \ IO = 
    run {
        match FileReadWithResult.readLines("Main.flix") {
            case Result.Ok(lines) =&gt; 
                lines |&gt; List.forEach(println)
            case Result.Err(err) =&gt; 
                println("Unable to read file. Error: ${err}")
        }
    } with FileReadWithResult.runWithIO
</code></pre>
<h2 id="filewritewithresult"><a class="header" href="#filewritewithresult">FileWriteWithResult</a></h2>
<p>Flix defines a <code>FileWriteWithResult</code> effect to write to the file system:</p>
<pre><code class="language-flix">eff FileWriteWithResult {
    /// Writes `str` to the given file `f`.
    def write(data: {str = String}, f: String): Result[IoError, Unit]

    /// Writes `lines` to the given file `f`.
    def writeLines(data: {lines = List[String]}, f: String): Result[IoError, Unit]

    /// Writes `data` to the given file `f`.
    def writeBytes(data: Vector[Int8], f: String): Result[IoError, Unit]

    /// Appends `str` to the given file `f`.
    def append(data: {str = String}, f: String): Result[IoError, Unit]

    /// Appends `lines` to the given file `f`.
    def appendLines(data: {lines = List[String]}, f: String): Result[IoError, Unit]

    /// Appends `data` to the given file `f`.
    def appendBytes(data: Vector[Int8], f: String): Result[IoError, Unit]

    /// Truncates the given file `f`.
    def truncate(f: String): Result[IoError, Unit]

    /// Creates the directory `d`.
    def mkDir(d: String): Result[IoError, Unit]

    /// Creates the directory `d` and all its parent directories.
    def mkDirs(d: String): Result[IoError, Unit]

    /// Creates a new temporary directory with the given prefix.
    def mkTempDir(prefix: String): Result[IoError, String]
}
</code></pre>
<h3 id="example-using-filewritewithresult"><a class="header" href="#example-using-filewritewithresult">Example: Using <code>FileWriteWithResult</code></a></h3>
<pre><code class="language-flix">def main(): Unit \ IO = 
    run {
        let data = List#{"Hello", "World"};
        match FileWriteWithResult.writeLines(lines = data, "data.txt"){
            case Result.Ok(_)    =&gt; ()
            case Result.Err(err) =&gt; 
                println("Unable to write file. Error: ${err}")
        }
    } with FileWriteWithResult.runWithIO
</code></pre>
<h2 id="httpwithresult"><a class="header" href="#httpwithresult">HttpWithResult</a></h2>
<p>Flix defines a <code>HttpWithResult</code> effect to communicate over HTTP:</p>
<pre><code class="language-flix">eff HttpWithResult {
    def request(method: String, 
                url: String, 
                headers: Map[String, List[String]], 
                body: Option[String])
        : Result[IoError, Http.Response]
}
</code></pre>
<p>The <code>HttpWithResult</code> companion module provides several convenience functions:</p>
<pre><code class="language-flix">mod HttpWithResult {
    /// Send a `GET` request to the given `url` with the given `headers`
    /// and wait for the response.
    def get(url: String, headers: Map[String, List[String]])
        : Result[IoError, Http.Response] \ HttpWithResult

    /// Send a `POST` request to the given `url` with the given `headers`
    /// and `body` and wait for the response.
    def post(url: String, headers: Map[String, List[String]], body: String)
        : Result[IoError, Http.Response] \ HttpWithResult

    /// Send a `PUT` request to the given `url` with the given `headers`
    /// and `body` and wait for the response.
    def put(url: String, headers: Map[String, List[String]], body: String)
        : Result[IoError, Http.Response] \ HttpWithResult

    // ... additional functions (head, delete, options, trace, patch) ...
}
</code></pre>
<h3 id="example-using-httpwithresult"><a class="header" href="#example-using-httpwithresult">Example: Using <code>HttpWithResult</code></a></h3>
<pre><code class="language-flix">def main(): Unit \ IO =
    run {
        match HttpWithResult.get("http://example.com/", Map.empty()) {
            case Result.Ok(response) =&gt;
                let body = Http.Response.body(response);
                println(body)
            case Result.Err(e) =&gt; println(e)
        }
    } with HttpWithResult.runWithIO
</code></pre>
<h2 id="logger"><a class="header" href="#logger">Logger</a></h2>
<p>Flix defines a <code>Logger</code> effect for logging messages:</p>
<pre><code class="language-flix">eff Logger {
    /// Logs the given message `m` at the given severity `s`.
    def log(s: Severity, m: RichString): Unit
}
</code></pre>
<p>The <code>Logger</code> companion module provides several convenience functions:</p>
<pre><code class="language-flix">mod Logger {
    /// Logs the message `m` at the `Trace` level.
    def trace(m: a): Unit \ (Logger + Formattable.Aef[a]) with Formattable[a]

    /// Logs the message `m` at the `Debug` level.
    def debug(m: a): Unit \ (Logger + Formattable.Aef[a]) with Formattable[a]

    /// Logs the message `m` at the `Info` level.
    def info(m: a): Unit \ (Logger + Formattable.Aef[a]) with Formattable[a]

    /// Logs the message `m` at the `Warn` level.
    def warn(m: a): Unit \ (Logger + Formattable.Aef[a]) with Formattable[a]

    /// Logs the message `m` at the `Fatal` level.
    def fatal(m: a): Unit \ (Logger + Formattable.Aef[a]) with Formattable[a]
}
</code></pre>
<h3 id="example-using-logger"><a class="header" href="#example-using-logger">Example: Using <code>Logger</code></a></h3>
<pre><code class="language-flix">def main(): Unit \ IO =
    run {
        Logger.info("Hello");
        Logger.warn("World")
    } with Logger.runWithIO
</code></pre>
<h2 id="processwithresult"><a class="header" href="#processwithresult">ProcessWithResult</a></h2>
<p>Flix defines a <code>ProcessWithResult</code> effect for running commands outside of the JVM:</p>
<pre><code class="language-flix">eff ProcessWithResult {
    /// Executes the command `cmd` with the arguments `args`, by the path `cwd`
    /// and with the environment `env`.
    def execWithCwdAndEnv(cmd: String, args: List[String],
                          cwd: Option[String],
                          env: Map[String, String]): Result[IoError, ProcessHandle]

    // ... additional operations (exitValue, isAlive, pid, stop, waitFor, waitForTimeout) ...
}
</code></pre>
<p>The <code>Process</code> companion module provides several convenience functions:</p>
<pre><code class="language-flix">/// Executes the command `cmd` with the arguments `args`.
pub def exec(cmd: String, args: List[String])
    : Result[IoError, ProcessHandle] \ ProcessWithResult

/// Executes the command `cmd` with the arguments `args`, by the path `cwd`.
def execWithCwd(cmd: String, args: List[String], cwd: Option[String])
    : Result[IoError, ProcessHandle] \ ProcessWithResult

/// Executes the command `cmd` with the arguments `args` and with 
/// the environment `env`.
def execWithEnv(cmd: String, args: List[String], env: Map[String, String])
    : Result[IoError, ProcessHandle] \ ProcessWithResult
</code></pre>
<h3 id="example-using-processwithresult"><a class="header" href="#example-using-processwithresult">Example: Using <code>ProcessWithResult</code></a></h3>
<pre><code class="language-flix">def main(): Unit \ IO =
    run {
        match ProcessWithResult.exec("ls", Nil) {
            case Result.Ok(_)    =&gt; ()
            case Result.Err(err) =&gt; println("Unable to execute process: ${err}")
        }
    } with ProcessWithResult.runWithIO
</code></pre>
<h2 id="random"><a class="header" href="#random">Random</a></h2>
<p>Flix defines a <code>Random</code> effect for the generation of random values:</p>
<pre><code class="language-flix">eff Random {
    /// Returns a pseudorandom boolean value with equal probability of being `true` or `false`.
    def randomBool(): Bool

    /// Returns a pseudorandom 32-bit floating-point number in the range [0.0, 1.0].
    def randomFloat32(): Float32

    /// Returns a pseudorandom 64-bit floating-point number in the range [0.0, 1.0].
    def randomFloat64(): Float64

    /// Returns a pseudorandom 32-bit integer.
    def randomInt32(): Int32

    /// Returns a pseudorandom 64-bit integer.
    def randomInt64(): Int64

    /// Returns a 64-bit floating point number following a standard normal (Gaussian) distribution.
    def randomGaussian(): Float64
}
</code></pre>
<h3 id="example-using-random"><a class="header" href="#example-using-random">Example: Using <code>Random</code></a></h3>
<pre><code class="language-flix">def main(): Unit \ {NonDet, IO} =
    run {
        let flip = Random.randomBool();
        if (flip) 
            println("heads")
        else 
            println("tails")
    } with Random.runWithIO
</code></pre>
<h2 id="running-multiple-effects"><a class="header" href="#running-multiple-effects">Running Multiple Effects</a></h2>
<p>We can easily combine multiple effects and run them:</p>
<pre><code class="language-flix">def main(): Unit \ {NonDet, IO} =
    run {
        Console.println("Please enter your name:");
        let name = Console.readln();
        let flip = Random.randomBool();
        if (flip) 
            Console.println("Pleased to meet you, ${name}")
        else 
            Console.println("Oh no, not you, ${name}")
    } with Console.runWithIO
      with Random.runWithIO
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="default-handlers"><a class="header" href="#default-handlers">Default Handlers</a></h1>
<p>Flix supports <strong>default handlers</strong> which means that an effect can declare a
handler that translates the effect into the <code>IO</code> effect. This allows <code>main</code> (and
any method annotated with <code>@Test</code>) to use that effect without explicitly
providing a handler in a <code>run-with</code> block.</p>
<p>For example, we can write:</p>
<pre><code class="language-flix">def main(): Unit \ {Clock, Env, Logger} = 
    let ts = Clock.currentTime(TimeUnit.Milliseconds);
    let os = Env.getOsName();
    Logger.info("UNIX Timestamp:   ${ts}");
    Logger.info("Operating System: ${os}")

</code></pre>
<p>which the Flix compiler translates to:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    run {
        let ts = Clock.currentTime(TimeUnit.Milliseconds);
        let os = Env.getOsName();
        Logger.info("UNIX Timestamp:   ${ts}");
        Logger.info("Operating System: ${os}")
    } with Clock.runWithIO
      with Env.runWithIO
      with Logger.runWithIO
</code></pre>
<p>That is, the Flix compiler automatically inserts calls to <code>Clock.runWithIO</code>,
<code>Env.runWithIO</code>, and <code>Logger.runWithIO</code> which are the default handlers for their
respective effects.</p>
<p>For example, <code>Clock.runWithIO</code> is declared as:</p>
<pre><code class="language-flix">@DefaultHandler
pub def runWithIO(f: Unit -&gt; a \ ef): a \ (ef - Clock) + IO = ...
</code></pre>
<p>A default handler is declared using the <code>@DefaultHandler</code> annotation. Each
effect may have at most one default handler, and it must reside in the companion
module of that effect.</p>
<p>A default handler must have a signature of the form:</p>
<pre><code class="language-flix">def runWithIO(f: Unit -&gt; a \ ef): a \ (ef - E) + IO
</code></pre>
<p>where <code>E</code> is the name of the effect.</p>
<p>We can use effects with default handlers in tests. For example:</p>
<pre><code class="language-flix">@Test
def myTest01(): Unit \ {Assert, Logger} = 
    Logger.info("Running test!");
    Assert.assertEq(expected = 42, 42)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="effect-oriented-programming"><a class="header" href="#effect-oriented-programming">Effect-Oriented Programming</a></h1>
<p>Programming with effects requires a new mindset, <em>an effect-oriented mindset</em>.</p>
<p>Imagine a programmer coming from JavaScript or Python to a statically-typed
programming language such as C# or Java. If they continue to program with
objects, maps, and strings without introducing their own types, then the
benefits of a static type system are lost. In the same way, if a programmer
comes to Flix without adapting <em>an effect-oriented mindset</em> then the benefits of
the Flix type and effect system are lost.</p>
<p>In Flix, we can give every function the <code>IO</code> effect and call effectful code
everywhere, but this is not effect-oriented programming and is a bad programming
style. A proper effect-oriented program architecture consists of a functional
core, which may use <a href="#effects-and-handlers">algebraic effects and handlers</a>,
surrounded by an imperative shell that performs <code>IO</code>. A good rule of thumb is
that <code>IO</code> effect should be <em>close</em> to the <code>main</code> function.</p>
<p>We now illustrate these points with an example.</p>
<h2 id="a-guessing-game--the-wrong-way"><a class="header" href="#a-guessing-game--the-wrong-way">A Guessing Game — The Wrong Way</a></h2>
<p>Consider the following program written in a mixed style of Flix and Java:</p>
<pre><code class="language-flix">import java.lang.System
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.{Random =&gt; JRandom}

def getSecretNumber(): Int32 \ {NonDet, IO} = 
    let rnd = new JRandom();
    rnd.nextInt()

def readGuess(): Result[String, String] \ IO = 
    let reader = new BufferedReader(new InputStreamReader(System.in));
    let line = reader.readLine();
    if (Object.isNull(line)) 
        Result.Err("no input")
    else 
        Result.Ok(line)

def readAndParseGuess(): Result[String, Int32] \ IO = 
    forM(g &lt;- readGuess(); 
         n &lt;- Int32.parse(10, g)
    ) yield n

def gameLoop(secret: Int32): Unit \ IO = {
    println("Enter a guess:");
    match readAndParseGuess() {
        case Result.Ok(g) =&gt; 
            if (secret == g) {
                println("Correct!")
            } else {
                println("Incorrect!");
                gameLoop(secret)
            }
        case Result.Err(_) =&gt; 
            println("Not a number? Goodbye.");
            println("The secret was: ${secret}")
    }
}

def main(): Unit \ {NonDet, IO} = 
    let secret = getSecretNumber();
    gameLoop(secret)
</code></pre>
<p>Here every function, i.e. <code>getSecretNumber</code>, <code>readGuess</code>, <code>readAndParseGuess</code>,
<code>gameLoop</code>, and <code>main</code> has the <code>IO</code> effect. The consequence is that every
function can do anything. Note how effectful code is scattered everywhere
throughout the program.</p>
<p>Understanding, refactoring, and testing a program written in this style is a
nightmare.</p>
<p>Programming in a effect-oriented style means that we should define effects for
every action that interacts with the outside world. We should then <em>handle</em>
these effects close to the <code>main</code> function.</p>
<h2 id="a-guessing-game--the-right-way"><a class="header" href="#a-guessing-game--the-right-way">A Guessing Game — The Right Way</a></h2>
<p>Here is what we should have done:</p>
<pre><code class="language-flix">import java.lang.System
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.{Random =&gt; JRandom}

eff Guess {
    def readGuess(): Result[String, String]
}

eff Secret {
    def getSecret(): Int32
}

eff Terminal {
    def println(s: String): Unit    
}

def readAndParseGuess(): Result[String, Int32] \ {Guess} = 
    forM(g &lt;- Guess.readGuess(); 
         n &lt;- Int32.parse(10, g)
    ) yield n

def gameLoop(secret: Int32): Unit \ {Guess, Terminal} = {
    Terminal.println("Enter a guess:");
    match readAndParseGuess() {
        case Result.Ok(g) =&gt; 
            if (secret == g) {
                Terminal.println("Correct!")
            } else {
                Terminal.println("Incorrect!");
                gameLoop(secret)
            }
        case Result.Err(_) =&gt; 
            Terminal.println("Not a number? Goodbye.");
            Terminal.println("The secret was: ${secret}")
    }
}

def main(): Unit \ {NonDet, IO} = 
    run {
        let secret = Secret.getSecret();
        gameLoop(secret)
    } with handler Secret {
        def getSecret(_, resume) = 
            let rnd = new JRandom();
            resume(rnd.nextInt())
    } with handler Guess {
        def readGuess(_, resume) = 
            let reader = new BufferedReader(new InputStreamReader(System.in));
            let line = reader.readLine();
            if (Object.isNull(line)) 
                resume(Result.Err("no input"))
            else 
                resume(Result.Ok(line))
    } with handler Terminal {
        def println(s, resume) = { println(s); resume() }
    }
</code></pre>
<p>Here, we have introduced three algebraic effects:</p>
<ol>
<li>A <code>Guess</code> effect that represents the action of asking the user for a guess.</li>
<li>A <code>Secret</code> effect that represents the action of picking a secret number.</li>
<li>A <code>Terminal</code> effect that represents the action of printing to the console.</li>
</ol>
<p>We have written each function to only use the relevant effects. For example, the
<code>gameLoop</code> function uses the <code>Guess</code> and <code>Terminal</code> effects — and has no
other effects. Furthermore, all effects are now handled in one place: in the
<code>main</code> function. The upshot is that the business is logic is purely functional.
Where impurity is needed, it is precisely encapsulated by the use of effects and
handlers.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Flix supports hierarchical modules as known from many other programming
languages.</p>
<h2 id="declaring-and-using-modules"><a class="header" href="#declaring-and-using-modules">Declaring and Using Modules</a></h2>
<p>We declare modules using the <code>mod</code> keyword followed by the namespace and name of
the module.</p>
<p>For example, we can declare a module:</p>
<pre><code class="language-flix">mod Math {
    pub def sum(x: Int32, y: Int32): Int32 = x + y
}
</code></pre>
<p>Here we have declared a module called <code>Math</code> with a function called <code>sum</code> inside
it. We can refer to the <code>sum</code> function, from outside of its module, using its
fully-qualified name:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    let result = Math.sum(123, 456);
    println(result)
</code></pre>
<p>Alternatively, we can bring the <code>sum</code> function into local scope with <code>use</code>:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    use Math.sum;
    let result = sum(123, 456);
    println(result)
</code></pre>
<h2 id="using-multiple-declarations-from-a-module"><a class="header" href="#using-multiple-declarations-from-a-module">Using Multiple Declarations from a Module</a></h2>
<p>If we have multiple declarations in a module:</p>
<pre><code class="language-flix">mod Math {
    pub def sum(x: Int32, y: Int32): Int32 = x + y
    pub def mul(x: Int32, y: Int32): Int32 = x * y
}
</code></pre>
<p>We can, of course, <code>use</code> each declaration:</p>
<pre><code class="language-flix">use Math.sum;
use Math.mul;

def main(): Unit \ IO =
    mul(42, 84) |&gt; sum(21) |&gt; println
</code></pre>
<p>but a shorter way is to group the <code>use</code>s together into one:</p>
<pre><code class="language-flix">use Math.{sum, mul};

def main(): Unit \ IO =
    mul(42, 84) |&gt; sum(21) |&gt; println
</code></pre>
<blockquote>
<p><strong>Note:</strong> Flix does not support wildcard uses since they can lead to subtle
bugs.</p>
</blockquote>
<h2 id="avoiding-name-clashes-with-renaming"><a class="header" href="#avoiding-name-clashes-with-renaming">Avoiding Name Clashes with Renaming</a></h2>
<p>We can use renaming to avoid name clashes between identically named declarations.</p>
<p>For example, if we have two modules:</p>
<pre><code class="language-flix">mod A {
    pub def concat(x: String, y: String): String = x + y
}

mod B {
    pub def concat(xs: List[Int32], ys: List[Int32]): List[Int32] = xs ::: ys
}
</code></pre>
<p>We can then <code>use</code> each <code>concat</code> function under a unique name. For example:</p>
<pre><code class="language-flix">use A.{concat =&gt; concatStrings}
use B.{concat =&gt; concatLists}

def main(): Unit \ IO =
    concatStrings("Hello", " World!") |&gt; println
</code></pre>
<p>While this feature is powerful, in many cases using a fully-qualified name might be
more appropriate.</p>
<h2 id="modules-and-enums"><a class="header" href="#modules-and-enums">Modules and Enums</a></h2>
<p>We can define an enum inside a module. For example:</p>
<pre><code class="language-flix">mod Zoo {
    pub enum Animal {
        case Cat,
        case Dog,
        case Fox
    }
}
</code></pre>
<p>Here the <code>Zoo</code> module contains an enum type named <code>Animal</code> which has three
cases: <code>Cat</code>, <code>Dog</code>, and <code>Fox</code>.</p>
<p>We can access the type and the cases using their fully-qualified names:</p>
<pre><code class="language-flix">def says(a: Zoo.Animal): String = match a {
    case Zoo.Animal.Cat =&gt; "Meow"
    case Zoo.Animal.Dog =&gt; "Woof"
    case Zoo.Animal.Fox =&gt; "Roar"
}

def main(): Unit \ IO = 
    println("A cat says ${says(Zoo.Animal.Cat)}!")
</code></pre>
<p>Alternatively, we can <code>use</code> both the <code>Animal</code> type and its cases:</p>
<pre><code class="language-flix">use Zoo.Animal
use Zoo.Animal.Cat
use Zoo.Animal.Dog
use Zoo.Animal.Fox

def says(a: Animal): String = match a {
    case Animal.Cat =&gt; "Meow"
    case Animal.Dog =&gt; "Woof"
    case Animal.Fox =&gt; "Roar"
}

def main(): Unit \ IO = 
    println("A cat says ${says(Cat)}!")
</code></pre>
<p>Note that <code>use Zoo.Animal</code> brings the <code>Animal</code> <em>type</em> into scope, whereas <code>use Zoo.Animal.Cat</code> brings the <code>Cat</code> <em>case</em> into scope.</p>
<h2 id="modules-and-trait"><a class="header" href="#modules-and-trait">Modules and Trait</a></h2>
<p>We can also define a trait inside a module. The mechanism is similar to
enums inside modules.</p>
<p>For example, we can write:</p>
<pre><code class="language-flix">mod Zoo {
    pub trait Speakable[t] {
        pub def say(x: t): String
    }
}

enum Animal with ToString {
    case Cat,
    case Dog,
    case Fox
}

instance Zoo.Speakable[Animal] {
    pub def say(a: Animal): String = match a {
        case Cat =&gt; "Meow"
        case Dog =&gt; "Woof"
        case Fox =&gt; "Roar"
    }
}
</code></pre>
<p>We can use fully-qualified names to write:</p>
<pre><code class="language-flix">def speak(x: t): Unit \ IO with Zoo.Speakable[t], ToString[t] = 
    println("A ${x} says ${Zoo.Speakable.say(x)}!")

def main(): Unit \ IO = 
    speak(Animal.Cat)
</code></pre>
<p>Or we can <code>use</code> the <code>Zoo.Speakable</code> trait and the <code>Zoo.Speakable.say</code>
function:</p>
<pre><code class="language-flix">use Zoo.Speakable
use Zoo.Speakable.say

def speak(x: t): Unit \ IO with Speakable[t], ToString[t] = 
    println("A ${x} says ${say(x)}!")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="declaring-modules"><a class="header" href="#declaring-modules">Declaring Modules</a></h1>
<p>As we have already seen, modules can be declared using the <code>mod</code> keyword:</p>
<pre><code class="language-flix">mod Museum {
    // ... members ...
}
</code></pre>
<p>We can nest modules inside other modules:</p>
<pre><code class="language-flix">mod Museum {
    mod Entrance {
        pub def buyTicket(): Unit \ IO = 
            println("Museum.Entrance.buyTicket() was called.")
    }

    mod Restaurant {
        pub def buyMeal(): Unit \ IO = 
            println("Museum.Restaurant.buyMeal() was called.")
    }

    mod Giftshop {
        pub def buyGift(): Unit \ IO = 
            println("Museum.Giftshop.buyGift() was called.")
    }
}
</code></pre>
<p>We can call these methods as follows:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    Museum.Entrance.buyTicket();
    Museum.Restaurant.buyMeal();
    Museum.Giftshop.buyGift()
</code></pre>
<p>Or alternatively as follows:</p>
<pre><code class="language-flix">use Museum.Entrance.buyTicket;
use Museum.Restaurant.buyMeal;
use Museum.Giftshop.buyGift;
def main(): Unit \ IO = 
    buyTicket();
    buyMeal();
    buyGift()
</code></pre>
<h2 id="accessibility"><a class="header" href="#accessibility">Accessibility</a></h2>
<p>A module member <code>m</code> declared in module <code>A</code> is accessible from another module <code>B</code>
if:</p>
<ul>
<li>the member <code>m</code> is declared as public (<code>pub</code>).</li>
<li>the module <code>B</code> is a sub-module of <code>A</code>.</li>
</ul>
<p>For example, the following is allowed:</p>
<pre><code class="language-flix">mod A {
    mod B {
       pub def g(): Unit \ IO = A.f() // OK
    }

    def f(): Unit \ IO = println("A.f() was called.")
}
</code></pre>
<p>Here <code>f</code> is private to the module A. However, since <code>B</code> is a sub-module of <code>A</code>
can access <code>f</code> from inside <code>B</code>. On the other hand, the following is <em>not</em>
allowed:</p>
<pre><code class="language-flix">mod A {
    mod B {
       def g(): Unit \ IO = println("A.B.g() was called.")
    }

    pub def f(): Unit \ IO = A.B.g() // NOT OK
}
</code></pre>
<p>because <code>g</code> is private to <code>B</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="using-modules"><a class="header" href="#using-modules">Using Modules</a></h1>
<p>As we have already seen, the <code>use</code> construct brings members of a module into local scope.</p>
<p>For example, given the program:</p>
<pre><code class="language-flix">mod A {
    mod B {
        pub enum Color {
            case Red, Green, Blue
        }

        pub type alias Hue = Color 

        pub def isWarm(c: Color): Bool = 
            match c {
                case Color.Red    =&gt; true
                case Color.Green  =&gt; false
                case Color.Blue   =&gt; false
            }

    }
}
</code></pre>
<p>All of the following <code>use</code>s are meaningful:</p>
<pre><code class="language-flix">use A.B.Color 
use A.B.Color.{Red, Green, Blue}
use A.B.Hue
use A.B.isWarm 
</code></pre>
<h2 id="all-kinds-of-uses"><a class="header" href="#all-kinds-of-uses">All Kinds of Uses</a></h2>
<p>Flix supports several kinds of uses, including:</p>
<ul>
<li>A qualified use of a name: <code>use A.B.Color</code>.</li>
<li>A qualified use of multiple names: <code>use A.B.Color.{Red, Green, Blue}</code>.</li>
<li>A qualified use with rename: <code>use A.B.Color =&gt; AColor</code>.</li>
<li>A qualified use with multiple renames: <code>use A.B.Color.{Red =&gt; R, Green =&gt; G, Blue =&gt; B}</code>.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> Flix does not support wildcard.</p>
</blockquote>
<h2 id="where-can-uses-occur"><a class="header" href="#where-can-uses-occur">Where can Uses Occur?</a></h2>
<p>Flix supports uses in two places:</p>
<ul>
<li>Inside modules.</li>
<li>Inside functions.</li>
</ul>
<p>For example:</p>
<pre><code class="language-flix">mod A {
    use Chain
    use Chain.Empty
    use Chain.Chain
    use Int32.max

    pub def maxValue(c: Chain[Int32]): Int32 = 
        match c {
            case Empty       =&gt; 0
            case One(x)      =&gt; x
            case Chain(x, y) =&gt; max(maxValue(x), maxValue(y))
        }
}
</code></pre>
<p>which can also be written as:</p>
<pre><code class="language-flix">mod A {
    use Chain

    pub def maxValue(c: Chain[Int32]): Int32 = 
        use Chain.Empty;
        use Chain.Chain;
        use Int32.max;
        match c {
            case Empty       =&gt; 0
            case One(x)      =&gt; x
            case Chain(x, y) =&gt; max(maxValue(x), maxValue(y))
        }
}
</code></pre>
<p>Note the use of semicolons when inside an expression.</p>
<h2 id="default-uses"><a class="header" href="#default-uses">Default Uses</a></h2>
<p>In Flix, a few built-in constructors are always in scope:</p>
<ul>
<li><code>List.Nil</code> and <code>List.Cons</code>.</li>
<li><code>Result.Ok</code> and <code>Result.Err</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="companion-modules"><a class="header" href="#companion-modules">Companion Modules</a></h1>
<p>In Flix every enum and trait declaration is associated with a <em>companion
module</em>.</p>
<h2 id="enum-companions"><a class="header" href="#enum-companions">Enum Companions</a></h2>
<p>When we declare an enum, its type and cases are automatically available inside
its companion module. For example, we can write:</p>
<pre><code class="language-flix">enum Color {
    case Red,
    case Green,
    case Blue
}

mod Color {
    pub def isWarm(c: Color): Bool = match c {
        case Red    =&gt; true
        case Green  =&gt; false
        case Blue   =&gt; false
    }
}
</code></pre>
<p>Here the <code>Color</code> type and the <code>Red</code>, <code>Green</code>, and <code>Blue</code> cases are automatically
in scope within the companion <code>Color</code> module.</p>
<h2 id="trait-companions"><a class="header" href="#trait-companions">Trait Companions</a></h2>
<p>Every trait declaration also gives rise to a companion module.</p>
<p>For example, we can define a trait <code>Addable</code> for types whose elements can be added:</p>
<pre><code class="language-flix">trait Addable[t] {
    pub def add(x: t, y: t): t
}
</code></pre>
<p>The <code>Addable</code> trait implicitly introduces a companion module <code>Addable</code>. We
typically use the companion module to store functionality that is related to the
trait.</p>
<p>For example, we could have:</p>
<pre><code class="language-flix">mod Addable {
    pub def add3(x: t, y: t, z: t): t with Addable[t] = add(add(x, y), z)
}
</code></pre>
<p>When accessing a member of <code>Addable</code>, Flix will automatically look in both the
trait declaration and its companion module. Consequently, <code>Addable.add</code>
refers to the trait member <code>add</code> whereas <code>Addable.add3</code> refers to the
function inside the <code>Addable</code> module. Note that the <code>add</code> signature is in the
scope of the <code>Addable</code> module.</p>
<p>We should be aware that functions defined in the companion module of a trait
cannot be redefined by instances of the associated trait. Thus we
should only put members into the companion namespace when we do not intend
to redefine them later.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>Traits, also known as <a href="https://en.wikipedia.org/wiki/Type_class">type classes</a>,
support abstraction and modularity. The Flix trait system is similar to that of
Haskell and Rust, but not identical. Traits in Flix support associated types,
associated effects, and higher-kinded types.</p>
<p>We illustrate traits with an example.</p>
<p>We can define equality on <code>Option[Int32]</code> as follows:</p>
<pre><code class="language-flix">def equals(x: Option[Int32], y: Option[Int32]): Bool = 
    match (x, y) {
        case (None, None)         =&gt; true
        case (Some(v1), Some(v2)) =&gt; v1 == v2
        case _                    =&gt; false
    }
</code></pre>
<p>We can also define equality on <code>List[Int32]</code> as follows:</p>
<pre><code class="language-flix">def equals(x: List[Int32], y: List[Int32]): Bool = 
    match (x, y) {
        case (Nil, Nil)           =&gt; true
        case (v1 :: xs, v2 :: ys) =&gt; v1 == v2 and equals(xs, ys)
        case _                    =&gt; false
    }
</code></pre>
<p>But what if we wanted a common abstraction for data types which support
equality?</p>
<p>Here we can use traits. We can define an <code>Equatable</code> trait:</p>
<pre><code class="language-flix">trait Equatable[t] {
    pub def equals(x: t, y: t): Bool
}
</code></pre>
<p>which has a single <code>equals</code> <em>trait signature</em>. The trait is polymorphic over the
type parameter <code>t</code> which means that we can implement <code>Equatable</code> for both
<code>Option[t]</code> and <code>List[t]</code>:</p>
<pre><code class="language-flix">instance Equatable[Option[t]] with Equatable[t] {
    pub def equals(x: Option[t], y: Option[t]): Bool = 
        match (x, y) {
            case (None, None)         =&gt; true
            case (Some(v1), Some(v2)) =&gt; Equatable.equals(v1, v2)
            case _                    =&gt; false
        }
}
</code></pre>
<p>Notice that we did not implement <code>Equatable</code> for <code>Option[Int32]</code>, but instead
for <em>any</em> <code>Option[t]</code> as long as <code>t</code> itself is equatable. Moreover, instead of
comparing <code>v1</code> and <code>v2</code> directly using <code>==</code>, we call <code>Equatable.equals</code> on them.</p>
<p>We can also implement <code>Equatable</code> for <code>List[t]</code>:</p>
<pre><code class="language-flix">instance Equatable[List[t]] with Equatable[t] {
    pub def equals(x: List[t], y: List[t]): Bool = 
        use Equatable.equals;
        match (x, y) {
            case (Nil, Nil)           =&gt; true
            case (v1 :: xs, v2 :: ys) =&gt; equals(v1, v2) and equals(xs, ys)
            case _                    =&gt; false
        }
}
</code></pre>
<p>Assuming we also implement <code>Equatable</code> for <code>Int32</code>, we can use <code>Equatable</code> to
compute whether two <code>Option[Int32]</code> values are equal. But we can also compute if
two <code>Option[List[Int32]]</code> values are equal! This demonstrates the power of
abstraction: We have implemented instances for <code>Option[t]</code> and <code>List[t]</code> and we
can now reuse these instances everywhere.</p>
<p>We can use our newly defined <code>Equatable</code> trait to write polymorphic functions.</p>
<p>For example, we can define a function to compute if an element occurs in a list:</p>
<pre><code class="language-flix">def memberOf(x: t, l: List[t]): Bool with Equatable[t] = 
    match l {
        case Nil     =&gt; false
        case y :: ys =&gt; Equatable.equals(x, y) or memberOf(x, ys)
    }
</code></pre>
<p>We can use <code>memberOf</code> for a list of any type, as the element type implements
<code>Equatable</code>.</p>
<blockquote>
<p><strong>Note:</strong> In the Flix Standard Library the <code>Equatable</code> trait is called <code>Eq</code>.
Moreover, the <code>==</code> operator is syntactic sugar for the trait signature
<code>Eq.eq</code>.</p>
</blockquote>
<h2 id="sealed-traits"><a class="header" href="#sealed-traits">Sealed Traits</a></h2>
<p>We can declare a trait as <code>sealed</code> to restrict who can implement the trait.</p>
<p>For example:</p>
<pre><code class="language-flix">mod Zoo {
    sealed trait Animal[a] {
        pub def isMammal(x: a): Bool
    }

    instance Animal[Giraffe] {
        pub def isMammal(_: Giraffe): Bool = true
    }

    instance Animal[Penguin] {
        pub def isMammal(_: Penguin): Bool = false
    }

    pub enum Giraffe
    pub enum Penguin
}
</code></pre>
<p>Here we can implement instances for <code>Animal</code> and <code>Giraffe</code> because they occur in
the same module as the <code>Animal</code> trait. But we cannot implement <code>Animal</code> from
outside the <code>Zoo</code> module. If we try:</p>
<pre><code class="language-flix">mod Lake {
    pub enum Swan

    instance Zoo.Animal[Swan] {
        pub def isMammal(_: Swan): Bool = false
    }
}
</code></pre>
<p>then Flix reports:</p>
<pre><code>❌ -- Resolution Error -------------------------------------------------- 

&gt;&gt; Trait 'Zoo.Animal' is sealed from the module 'Lake'.

21 |     instance Zoo.Animal[Swan] {
                  ^^^^^^^^^^
                  sealed trait.
</code></pre>
<h2 id="malformed-traits"><a class="header" href="#malformed-traits">Malformed Traits</a></h2>
<p>A trait is <em>not</em> a C# or Java-style interface. Specifically:</p>
<ul>
<li>every trait must have exactly one type parameter, and</li>
<li>every signature must mention that type parameter.</li>
</ul>
<p>For example, the following trait is incorrect:</p>
<pre><code class="language-flix">trait Animal[a] {
    pub def isMammal(x: a): Bool      // OK     -- mentions a.
    pub def numberOfGiraffes(): Int32 // NOT OK -- does not mention a.
}
</code></pre>
<p>If we compile the above trait, Flix reports:</p>
<pre><code>❌ -- Resolution Error -------------------------------------------------- 

&gt;&gt; Unexpected signature 'numberOfGiraffes' which does not mention the type 
&gt;&gt; variable of the trait.

7 |     pub def numberOfGiraffes(): Int32 
                ^^^^^^^^^^^
                unexpected signature.
</code></pre>
<p>The problem is that the signature for <code>numberOfGiraffes</code> does not mention the
type parameter <code>a</code>.</p>
<h2 id="complex-instances"><a class="header" href="#complex-instances">Complex Instances</a></h2>
<p>A trait <em>instance</em> must be defined on:</p>
<ul>
<li>exactly one type constructor —</li>
<li>that is applied to zero or more distinct type variables.</li>
</ul>
<p>For example, given the <code>Equatable</code> trait from before:</p>
<pre><code class="language-flix">trait Equatable[t] {
    pub def equals(x: t, y: t): Bool
}
</code></pre>
<p>We can implement instances for e.g.:</p>
<ul>
<li><code>Option[a]</code></li>
<li><code>List[a]</code></li>
<li><code>(a, b)</code></li>
</ul>
<p>but we <em>cannot</em> implement instances for e.g.:</p>
<ul>
<li><code>Option[Int32]</code></li>
<li><code>List[String]</code></li>
<li><code>(a, Bool)</code></li>
<li><code>Map[Int32, v]</code></li>
</ul>
<p>If we try to implement an instance for e.g. <code>List[Int32]</code> Flix reports:</p>
<pre><code>❌ -- Instance Error -------------------------------------------------- 

&gt;&gt; Complex instance type 'List[Int32]' in 'Equatable'.

6 | instance Equatable[List[Int32]] {
             ^^^^^^^^^
             complex instance type

An instance type must be a type constructor applied to zero or more 
distinct type variables.
</code></pre>
<h2 id="overlapping-instances"><a class="header" href="#overlapping-instances">Overlapping Instances</a></h2>
<p>We cannot implement two instances of of the same trait for overlapping types.</p>
<p>For example, if we try to implement two instances of <code>Equatable</code> for <code>List[t]</code>:</p>
<pre><code class="language-flix">instance Equatable[List[t]] {
    pub def equals(x: List[t], y: List[t]): Bool = ???
}

instance Equatable[List[t]] {
    pub def equals(x: List[t], y: List[t]): Bool = ???
}
</code></pre>
<p>then Flix reports:</p>
<pre><code>❌ -- Instance Error -------------------------------------------------- 

&gt;&gt; Overlapping instances for 'Equatable'.

1 | instance Equatable[List[t]] {
              ^^^^^^^^^
              the first instance was declared here.

4 | instance Equatable[List[t]] {
             ^^^^^^^^^
             the second instance was declared here.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="essential-traits"><a class="header" href="#essential-traits">Essential Traits</a></h1>
<p>Practical programming in Flix requires knowledge of at least three traits: <code>Eq</code>,
<code>Order</code>, and <code>ToString</code>.</p>
<h2 id="the-eq-trait"><a class="header" href="#the-eq-trait">The Eq Trait</a></h2>
<p>The <code>Eq</code> trait captures when two values of a specific type are equal:</p>
<pre><code class="language-flix">trait Eq[a] {

    ///
    /// Returns `true` if and only if `x` is equal to `y`.
    ///
    pub def eq(x: a, y: a): Bool

    // ... additional members omitted ...
}
</code></pre>
<p>To implement <code>Eq</code>, we only have to implement the <code>eq</code> function. When we
implement <code>eq</code> we automatically get an implementation of <code>Eq.neq</code>.</p>
<h2 id="the-order-trait"><a class="header" href="#the-order-trait">The Order Trait</a></h2>
<p>The <code>Order</code> trait captures when one value is smaller or equal to another value
of the same type:</p>
<pre><code class="language-flix">trait Order[a] with Eq[a] {

    ///
    /// Returns `Comparison.LessThan` if `x` &lt; `y`, 
    /// `Equal` if `x` == `y` or 
    /// `Comparison.GreaterThan` if `x` &gt; `y`.
    ///
    pub def compare(x: a, y: a): Comparison

    // ... additional members omitted ...
}
</code></pre>
<p>To implement the <code>Order</code> trait, we must implement the <code>compare</code> function which
returns value of type <code>Comparison</code>. The <code>Comparison</code> data type is defined as:</p>
<pre><code class="language-flix">enum Comparison {
    case LessThan
    case EqualTo
    case GreaterThan
}
</code></pre>
<p>When we implement <code>compare</code>, we automatically get implementations of
<code>Order.less</code>, <code>Order.lessThan</code>, <code>Order.greater</code>, <code>Order.greaterEqual</code>,
<code>Order.max</code>, and <code>Order.min</code>.</p>
<h2 id="the-tostring-trait"><a class="header" href="#the-tostring-trait">The ToString Trait</a></h2>
<p>The <code>ToString</code> trait is used to obtain a string representation of a specific value:</p>
<pre><code class="language-flix">trait ToString[a] {
    ///
    /// Returns a string representation of the given `x`.
    ///
    pub def toString(x: a): String
}
</code></pre>
<p>Flix uses the <code>ToString</code> trait in string interpolations.</p>
<p>For example, the interpolated string</p>
<pre><code class="language-flix">"Good morning ${name}, it is ${hour} o'clock."
</code></pre>
<p>is actually syntactic sugar for the expression:</p>
<pre><code class="language-flix">"Good morning " + ToString.toString(name) + ", it is " 
                + ToString.toString(hour) + " o'clock."
</code></pre>
<p>In the following subsection, we discuss how to automatically derive
implementations of the <code>Eq</code>, <code>Order</code>, and <code>ToString</code> traits.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="automatic-derivation"><a class="header" href="#automatic-derivation">Automatic Derivation</a></h1>
<p>Flix supports automatic derivation of several traits, including:</p>
<ul>
<li><code>Eq</code> — to derive structural equality on the values of a type.</li>
<li><code>Order</code> — to derive a total ordering on the values of a type.</li>
<li><code>ToString</code> — to derive a human-readable string representation on the values of a type.</li>
<li><code>Sendable</code> — to enable the values of an (immutable) type to be sent over a channel.</li>
<li><code>Coerce</code> - to convert simple data types to their underlying representation.</li>
</ul>
<h2 id="derivation-of-eq-and-order"><a class="header" href="#derivation-of-eq-and-order">Derivation of Eq and Order</a></h2>
<p>We can automatically derive instances of the <code>Eq</code> and <code>Order</code> traits using
the <code>with</code> clause in the <code>enum</code> declaration. For example:</p>
<pre><code class="language-flix">enum Shape with Eq, Order {
    case Circle(Int32)
    case Square(Int32)
    case Rectangle(Int32, Int32)
}
</code></pre>
<p>The derived implementations are structural and rely on the order of the case
declarations:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    println(Circle(123) == Circle(123)); // prints `true`.
    println(Circle(123) != Square(123)); // prints `true`.
    println(Circle(123) &lt;= Circle(123)); // prints `true`.
    println(Circle(456) &lt;= Square(123))  // prints `true`.
</code></pre>
<blockquote>
<p><strong>Note</strong>: Automatic derivation of <code>Eq</code> and <code>Order</code> requires that the inner
types of the <code>enum</code> implement <code>Eq</code> and <code>Order</code> themselves.</p>
</blockquote>
<h2 id="derivation-of-tostring"><a class="header" href="#derivation-of-tostring">Derivation of ToString</a></h2>
<p>We can also automatically derive <code>ToString</code> instances:</p>
<pre><code class="language-flix">enum Shape with ToString {
    case Circle(Int32)
    case Square(Int32)
    case Rectangle(Int32, Int32)
}
</code></pre>
<p>Then we can take advantage of string interpolation and write:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    let c = Circle(123);
    let s = Square(123);
    let r = Rectangle(123, 456);
    println("A ${c}, ${s}, and ${r} walk into a bar.")
</code></pre>
<p>which prints:</p>
<pre><code>A Circle(123), Square(123), and Rectangle(123, 456) walk into a bar.
</code></pre>
<h2 id="derivation-of-sendable"><a class="header" href="#derivation-of-sendable">Derivation of Sendable</a></h2>
<p>We can automatically derive implementations of the <code>Sendable</code> trait (which
allow values of a specific type to be sent over a channel). For example:</p>
<pre><code class="language-flix">enum Shape with Sendable, ToString {
    case Circle(Int32)
}

def main(): Unit \ IO = 
    region rc {
        let (tx, rx) = Channel.buffered(rc, 10);
        Channel.send(Circle(123), tx); // OK, since Shape is Sendable.
        println(Channel.recv(rx))
    }
</code></pre>
<p>We <em>cannot</em> derive <code>Sendable</code> for types that rely on scoped mutable memory. For
example, if we try:</p>
<pre><code class="language-flix">enum Shape[r: Region] with Sendable {
    case Circle(Array[Int32, r])
}
</code></pre>
<p>The Flix compiler emits a compiler error:</p>
<pre><code>❌ -- Safety Error --------------------------------------

&gt;&gt; Cannot derive 'Sendable' for type Shape[b27587945]

Because it takes a type parameter of kind 'Region'.

1 | enum Shape[r: Region] with Sendable {
                               ^^^^^^^^
                               unable to derive Sendable.
</code></pre>
<p>This is because mutable data is not safe to share between threads.</p>
<h2 id="derivation-of-coerce"><a class="header" href="#derivation-of-coerce">Derivation of Coerce</a></h2>
<p>We can automatically derive implementations of the <code>Coerce</code> trait.
The <code>Coerce</code> trait converts a simple (one-case) data type
to its underlying implementation.</p>
<pre><code class="language-flix">enum Shape with Coerce {
    case Circle(Int32)
}

def main(): Unit \ IO =
    let c = Circle(123);
    println("The radius is ${coerce(c)}")
</code></pre>
<p>We <em>cannot</em> derive <code>Coerce</code> for an enum with more than one case.
For example, if we try:</p>
<pre><code class="language-flix">enum Shape with Coerce {
    case Circle(Int32)
    case Square(Int32)
}
</code></pre>
<p>The Flix compiler emits a compiler error:</p>
<pre><code>❌ -- Derivation Error --------------------------------------------------

&gt;&gt; Cannot derive 'Coerce' for the non-singleton enum 'Shape'.

1 | enum Shape with Coerce {
                    ^^^^^^
                    illegal derivation

'Coerce' can only be derived for enums with exactly one case.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h1>
<p>An associated type is a type member of a trait that is specified by each trait
instance. Associated types are often considered a more natural alternative to
<a href="https://en.wikipedia.org/wiki/Type_class#Multi-parameter_type_classes#Multi-parameter_type_classes">multi-parameter type classes</a>.</p>
<p>We illustrate associated types with an example.</p>
<p>We can define a trait for types that can be added:</p>
<pre><code class="language-flix">trait Addable[t] {
    pub def add(x: t, y: t): t
}
</code></pre>
<p>We can implement multiple instances of the <code>Addable</code> trait for types such as
floating-point numbers, integers, and strings. For example, here is the instance
for <code>Int32</code>:</p>
<pre><code class="language-flix">instance Addable[Int32] {
    pub def add(x: Int32, y: Int32): Int32 = x + y
}
</code></pre>
<p>and here is one for <code>String</code>:</p>
<pre><code class="language-flix">instance Addable[String] {
    pub def add(x: String, y: String): String = "${x}${y}"
}
</code></pre>
<p>But what if we wanted to add an element to a set?</p>
<p>Intuitively, we would like to write:</p>
<pre><code class="language-flix">instance Addable[Set[a]] with Order[a] {
    pub def add(s: Set[a], x: a): Set[a] = Set.insert(x, s)
}
</code></pre>
<p>But the signature of <code>add</code> does not match the signature declared in <code>Addable</code>.</p>
<p>We can overcome this problem and increase the flexibility of <code>Addable</code> with an
associated type:</p>
<pre><code class="language-flix">trait Addable[t] {
    type Rhs
    pub def add(x: t, y: Addable.Rhs[t]): t
}
</code></pre>
<p>The <code>Addable</code> trait now has an associated type called <code>Rhs</code>. We refer to it as
<code>Addable.Rhs[t]</code> as seen in the signature of <code>add</code>. Whenever we declare an
instance of <code>Addable</code>, we must specify the associated type.</p>
<p>We can still implement instances for integers and strings, as before. For
example:</p>
<pre><code class="language-flix">instance Addable[Int32] {
    type Rhs = Int32
    pub def add(x: Int32, y: Int32): Int32 = x + y
}
</code></pre>
<p>But we can also implement an instance that allows adding an element to a set:</p>
<pre><code class="language-flix">instance Addable[Set[a]] with Order[a] {
    type Rhs = a
    pub def add(s: Set[a], x: a): Set[a] = Set.insert(x, s)
}
</code></pre>
<p>The important point is that <em>each trait instance specifies the associated type</em>.</p>
<p>We might wonder if we can specify two instances for <code>Set[a]</code>: (a) one for adding
an element to a set, as above, and (b) one for adding two sets:</p>
<pre><code class="language-flix">instance Addable[Set[a]] with Order[a] {
    type Rhs = Set[a]
    pub def add(x: Set[a], y: Set[a]): Set[a] = Set.union(x, y)

}
</code></pre>
<p>But while each instance is valid on its own, we cannot have both:</p>
<pre><code>❌ -- Instance Error -------------------------------------------------- 

&gt;&gt; Overlapping instances for 'Addable'.

...
</code></pre>
<p>If we had such overlapping instances, an expression like <code>Addable.add(Set#{}, Set#{})</code> would become ambiguous: Are we adding two sets? Or are we adding the
empty set to a set?</p>
<h2 id="example-a-foreach-trait"><a class="header" href="#example-a-foreach-trait">Example: A <code>ForEach</code> Trait</a></h2>
<p>We can use associated types to define a trait for collections that have a
<code>forEach</code> function:</p>
<pre><code class="language-flix">trait ForEach[t] {
    type Elm
    pub def forEach(f: ForEach.Elm[t] -&gt; Unit \ ef, x: t): Unit \ ef
}
</code></pre>
<p>Here <code>t</code> is the type of the collection and the associated type <code>Elm</code> is the type
of its elements. We can implement several instances for <code>ForEach</code>. For example,
we can implement an instance for <code>List[a]</code>:</p>
<pre><code class="language-flix">instance ForEach[List[a]] {
    type Elm = a
    pub def forEach(f: a -&gt; Unit \ ef, x: List[a]): Unit \ ef = List.forEach(f, x)
}
</code></pre>
<p>We can also implement an instance for <code>Map[k, v]</code>:</p>
<pre><code class="language-flix">instance ForEach[Map[k, v]] {
    type Elm = (k, v)
    pub def forEach(f: ((k, v)) -&gt; Unit \ ef, x: Map[k, v]): Unit \ ef = 
        Map.forEach(k -&gt; v -&gt; f((k, v)), x)
}
</code></pre>
<p>What is interesting and useful is that we can define the element type to be
key-value pairs. We need extra parentheses around the argument to <code>f</code> because we
want it to take a pair.</p>
<p>We can implement an instance for <code>String</code> where we can iterate through each
individual character:</p>
<pre><code class="language-flix">instance ForEach[String] {
    type Elm = Char
    pub def forEach(f: Char -&gt; Unit \ ef, x: String): Unit \ ef = 
        x |&gt; String.toList |&gt; List.forEach(f)
}
</code></pre>
<h2 id="example-a-collection-trait"><a class="header" href="#example-a-collection-trait">Example: A <code>Collection</code> Trait</a></h2>
<p>As another example, we can define a trait for collections:</p>
<pre><code class="language-flix">trait Collection[t] {
    type Elm
    pub def empty(): t
    pub def insert(x: Collection.Elm[t], c: t): t
    pub def toList(c: t): List[Collection.Elm[t]]
}
</code></pre>
<p>Here <code>t</code> is the type of the collection and <code>Elm</code> is the type of its elements.
Every collection must support three operations: <code>empty</code>, <code>insert</code>, and <code>toList</code>.</p>
<p>We can implement an instance of <code>Collection</code> for <code>Vector[a]</code>:</p>
<pre><code class="language-flix">instance Collection[Vector[a]] {
    type Elm = a
    pub def empty(): Vector[a] = Vector.empty()
    pub def insert(x: a, c: Vector[a]): Vector[a] = Vector.append(c, Vector#{x})
    pub def toList(c: Vector[a]): List[a] = Vector.toList(c)
}
</code></pre>
<p>And we can implement an instance of <code>Collection</code> for <code>Set[a]</code>:</p>
<pre><code class="language-flix">instance Collection[Set[a]] with Order[a] {
    type Elm = a
    pub def empty(): Set[a] = Set.empty()
    pub def insert(x: a, c: Set[a]): Set[a] = Set.insert(x, c)
    pub def toList(c: Set[a]): List[a] = Set.toList(c)
}
</code></pre>
<h2 id="equality-constraints"><a class="header" href="#equality-constraints">Equality Constraints</a></h2>
<p>We sometimes want to write polymorphic functions where we <em>restrict</em> an
associated type.</p>
<p>For example, returning to the example of the <code>Collection</code> trait, we can write a
function where we require that the element type is an <code>Int32</code>. This allows us to
write a sum function:</p>
<pre><code class="language-flix">def sum(c: t): Int32 with Collection[t] where Collection.Elm[t] ~ Int32 = 
    Collection.toList(c) |&gt; List.sum
</code></pre>
<p>Here the <code>where</code> clause contains a list of <em>type equality constraints</em>.
Specifically, the equality constraint <code>Collection.Elm[t] ~ Int32</code> assert that
<code>sum</code> can be used with any type <code>t</code> for which there is an instance of
<code>Collection</code> as long as the element type of that instance is equal to <code>Int32</code>.
This restriction ensures that the elements of the collection are integers and
allows us to call <code>List.sum</code>.</p>
<h2 id="default-types"><a class="header" href="#default-types">Default Types</a></h2>
<p>We can define a default type for an associated type.</p>
<p>Returning to <code>Addable</code>, we can define the associated type <code>Rhs</code> with <code>t</code> as its
default:</p>
<pre><code class="language-flix">trait Addable[t] {
    type Rhs = t  // Associated type with default type.
    pub def add(x: t, y: Addable.Rhs[t]): t
}
</code></pre>
<p>Here we specify that if <code>Rhs</code> is not defined by an instance implementation then
it defaults to <code>t</code>. The upshot is that we can define an instance for <code>Int32</code>:</p>
<pre><code class="language-flix">instance Addable[Int32] {
    pub def add(x: Int32, y: Int32): Int32 = x + y
}
</code></pre>
<p>without having to explicit define <code>type Rhs = Int32</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="associated-effects"><a class="header" href="#associated-effects">Associated Effects</a></h1>
<p>We have seen how associated types increase the flexibility of traits by allowing
each instance to specify concrete types for the associated types. Associated
<em>effects</em> work in the same manner, but concern effects.</p>
<p>We motivate the need for associated effects with a simple example.</p>
<p>We can define a trait for types that can be divded:</p>
<pre><code class="language-flix">trait Dividable[t] {
    pub def div(x: t, y: t): t
}
</code></pre>
<p>and we can implement the trait for e.g. <code>Float32</code> and <code>Int32</code>:</p>
<pre><code class="language-flix">instance Dividable[Float32] {
    pub def div(x: Float32, y: Float32): Float32 = x / y
}

instance Dividable[Int32] {
    pub def div(x: Int32, y: Int32): Int32 = x / y
}
</code></pre>
<p>But what about division-by-zero? Assume we want to raise an exception and have
it tracked by the type and effect system. We would like to write:</p>
<pre><code class="language-flix">pub eff DivByZero {
    pub def raise(): Void
}

instance Dividable[Int32] {
    pub def div(x: Int32, y: Int32): Int32 \ DivByZero = 
        if (y == 0) DivByZero.raise() else x / y
}
</code></pre>
<p>But unfortunately this does not quite work:</p>
<pre><code>❌ -- Type Error --------------------------------------------------

&gt;&gt; Mismatched signature 'div' required by 'Dividable'.

14 |     pub def div(x: Int32, y: Int32): Int32 \ DivByZero = 
                 ^^^
...
</code></pre>
<p>The problem, as the compiler explains, is that the definition of <code>div</code> in the
trait <code>Dividable</code> is declared as pure. Hence we are not allowed to raise an
exception. We could change the signature of <code>Dividable.div</code>, but that would be
problematic for the <code>Float32</code> instance, because division-by-zero returns <code>NaN</code>
and does not raise an exception.</p>
<p>The solution is to use an associated effect: then the instance for <code>Int32</code> can
specify that a <code>DivByZero</code> exception may be raised whereas the instance for
<code>Float32</code> can be pure. We add an associated effect <code>Aef</code> to <code>Dividable</code>:</p>
<pre><code class="language-flix">trait Dividable[t] {
    type Aef: Eff
    pub def div(x: t, y: t): t \ Dividable.Aef[t]
}
</code></pre>
<p>and we re-implement the instances for <code>Float32</code> and <code>Int32</code>:</p>
<pre><code class="language-flix">instance Dividable[Float32] {
    type Aef = { Pure } // No exception, div-by-zero yields NaN.
    pub def div(x: Float32, y: Float32): Float32 = x / y
}

instance Dividable[Int32] {
    type Aef = { DivByZero }
    pub def div(x: Int32, y: Int32): Int32 \ DivByZero = 
        if (y == 0) DivByZero.raise() else x / y
}
</code></pre>
<h2 id="associated-effects-and-regions"><a class="header" href="#associated-effects-and-regions">Associated Effects and Regions</a></h2>
<p>We often want to use associated effects in combination with regions.</p>
<p>Assume we have the <code>ForEach</code> trait from before:</p>
<pre><code class="language-flix">trait ForEach[t] {
    type Elm
    pub def forEach(f: ForEach.Elm[t] -&gt; Unit \ ef, x: t): Unit \ ef
}
</code></pre>
<p>As we have seen, we can implement it for e.g. <code>List[t]</code> but also <code>Map[k, v]</code>.
But what if we wanted to implement it for e.g. <code>MutList[t, r]</code> or <code>MutSet[t, r]</code>. We can try:</p>
<pre><code class="language-flix">instance ForEach[MutList[t, r]] {
    type Elm = t
    pub def forEach(f: t -&gt; Unit \ ef, x: MutList[t, r]): Unit \ ef = 
        MutList.forEach(f, x)
}
</code></pre>
<p>But Flix reports:</p>
<pre><code>❌ -- Type Error -------------------------------------------------- 

&gt;&gt; Unable to unify the effect formulas: 'ef' and 'ef + r'.

9 |         MutList.forEach(f, x)
            ^^^^^^^^^^^^^^^^^^^^^
            mismatched effect formulas.
</code></pre>
<p>The problem is that <code>MutList.forEach</code> has an effect in the region <code>r</code>, but the
signature of <code>forEach</code> in the trait only permits the <code>ef</code> effect from the
function <code>f</code>.</p>
<p>We can solve the problem by extending the <code>ForEach</code> trait with an associated effect:</p>
<pre><code class="language-flix">trait ForEach[t] {
    type Elm
    type Aef: Eff
    pub def forEach(f: ForEach.Elm[t] -&gt; Unit \ ef, x: t): Unit \ ef + ForEach.Aef[t]
}
</code></pre>
<p>We must specify that <code>Aef</code> is an effect with the kind annotation <code>Aef: Eff</code>. If
we don’t specify the kind then it defaults to <code>Type</code> which is not what we want
here.</p>
<p>With the updated <code>ForEach</code> trait, we can implement it for both <code>List[t]</code> and
<code>MutList[t]</code>:</p>
<pre><code class="language-flix">instance ForEach[List[t]] {
    type Elm = t
    type Aef = { Pure }
    pub def forEach(f: t -&gt; Unit \ ef, x: List[t]): Unit \ ef = List.forEach(f, x)
}
</code></pre>
<p>and</p>
<pre><code class="language-flix">instance ForEach[MutList[t, r]] {
    type Elm = t
    type Aef = { r }
    pub def forEach(f: t -&gt; Unit \ ef, x: MutList[t, r]): Unit \ ef + r = 
        MutList.forEach(f, x)
}
</code></pre>
<p>Notice how the implementation for <code>List[t]</code> specifies that the associated effect
is pure, whereas the implementation for <code>MutList[t, r]</code> specifies that there is
a heap effect in region <code>r</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="higher-kinded-types"><a class="header" href="#higher-kinded-types">Higher-Kinded Types</a></h1>
<p>Flix supports <a href="https://en.wikipedia.org/wiki/Kind_(type_theory)">higher-kinded
types</a>, hence traits can
abstract over <em>type constructors</em>.</p>
<p>For example, we can write a trait that capture iteration over any
collection of the shape <code>t[a]</code> where <code>t</code> is a type constructor of kind
<code>Type -&gt; Type</code> and <code>a</code> is the element type of kind <code>Type</code>:</p>
<pre><code class="language-flix">trait ForEach[t: Type -&gt; Type] {
    pub def forEach(f: a -&gt; Unit \ ef, x: t[a]): Unit \ ef
}
</code></pre>
<p>To use higher-kinded types Flix <em>requires</em> us to provide kind annotations, i.e.
we had to write <code>t: Type -&gt; Type</code> to inform Flix that <code>ForEach</code> abstracts over
type constructors.</p>
<p>We can implement an instance of the <code>ForEach</code> trait for <code>Option</code>:</p>
<pre><code class="language-flix">instance ForEach[Option] {
    pub def forEach(f: a -&gt; Unit \ ef, o: Option[a]): Unit \ ef = match o {
        case None    =&gt; ()
        case Some(x) =&gt; f(x)
    }
}
</code></pre>
<p>and we can implement an instance for <code>List</code>:</p>
<pre><code class="language-flix">instance ForEach[List] {
    pub def forEach(f: a -&gt; Unit \ ef, l: List[a]): Unit \ ef = List.forEach(f, l)
}
</code></pre>
<h2 id="the-flix-kinds"><a class="header" href="#the-flix-kinds">The Flix Kinds</a></h2>
<p>Flix supports the following kinds:</p>
<ul>
<li><code>Type</code>: The kind of Flix types.
<ul>
<li>e.g. <code>Int32</code>, <code>String</code>, and <code>List[Int32]</code>.</li>
</ul>
</li>
<li><code>RecordRow</code>: The kind of rows used in records
<ul>
<li>e.g. in <code>{x = Int32, y = Int32 | r}</code> the type variable <code>r</code> has kind <code>RecordRow</code>.</li>
</ul>
</li>
<li><code>SchemaRow</code>: The kind of rows used in first-class Datalog constraints
<ul>
<li>e.g. in <code>#{P(Int32, Int32) | r}</code> the type variable <code>r</code> has kind <code>SchemaRow</code>.</li>
</ul>
</li>
</ul>
<p>Flix can usually infer kinds. For example, we can write:</p>
<pre><code class="language-flix">def sum(r: {x = t, y = t | r}): t with Add[t] = r#x + r#y
</code></pre>
<p>and have the kinds of <code>t: Type</code> and <code>r: RecordRow</code> automatically inferred.</p>
<p>We can also explicitly specify them as follows:</p>
<pre><code class="language-flix">def sum[t: Type, r: RecordRow](r: {x = t, y = t | r}): t with Add[t] = r#x + r#y
</code></pre>
<p>but this style is not considered idiomatic.</p>
<p>Flix requires explicit kind annotations in four situations:</p>
<ul>
<li>For type parameters of non-Type kind on enums.</li>
<li>For type parameters of non-Type kind on type aliases.</li>
<li>For type parameters of non-Type kind on traits.</li>
<li>For type members of a non-Type kind in a trait.</li>
</ul>
<p>The most common scenario where you will need a kind annotation is when you want
a type parameter or type member to range over an effect.</p>
<h2 id="higher-kinded-types-vs-associated-types"><a class="header" href="#higher-kinded-types-vs-associated-types">Higher-Kinded Types vs. Associated Types</a></h2>
<p>In practice higher-kinded types and associated types can be used to define
similar abstractions.</p>
<p>For example, as we have seen, we can define the <code>ForEach</code> trait in two different
ways:</p>
<p>With a <em>higher-kinded type</em>:</p>
<pre><code class="language-flix">trait ForEach[t: Type -&gt; Type] {
    pub def forEach(f: a -&gt; Unit \ ef, x: t[a]): Unit \ ef
}
</code></pre>
<p>and with an <em>associated type</em>:</p>
<pre><code class="language-flix">trait ForEach[t] {
    type Elm
    pub def forEach(f: ForEach.Elm[t] -&gt; Unit \ ef, x: t): Unit \ ef
}
</code></pre>
<p>In the case of <code>ForEach</code>, the definition with an associated type is more
flexible, since we can implement an instance for <code>String</code> with associated
element type <code>Char</code>. However, higher-kinded types are still useful. For example,
the Flix Standard Library defines the <code>Functor</code> trait as:</p>
<pre><code class="language-flix">trait Functor[m : Type -&gt; Type] {
    pub def map(f: a -&gt; b \ ef, x: m[a]): m[b] \ ef
}
</code></pre>
<p>Notably the kind of <code>m</code> ensures that every <code>Functor</code> implementation is structure
preserving. That is, we know that when we <code>map</code> over e.g. an <code>Option[a]</code> then we
get back an <code>Option[b]</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="structured-concurrency"><a class="header" href="#structured-concurrency">Structured Concurrency</a></h1>
<p>Flix supports CSP-style concurrency with channels and
processes inspired by Go and Rust.</p>
<h2 id="spawning-processes"><a class="header" href="#spawning-processes">Spawning Processes</a></h2>
<p>We can spawn a process with the <code>spawn</code> keyword:</p>
<pre><code class="language-flix">def main(): Unit \ IO = region rc {
    spawn println("Hello from thread") @ rc;
    println("Hello from main")
}
</code></pre>
<p>Spawned processes are always associated with a region; the region
will not exit until all the processes associated with it have completed:</p>
<pre><code class="language-flix">def slowPrint(delay: Int32, message: String): Unit \ IO =
    Thread.sleep(Time.Duration.fromSeconds(delay));
    println(message)

def main(): Unit \ IO =
    region r1 {
        region r2 {
            spawn slowPrint(2, "Hello from r1") @ r1;
            spawn slowPrint(1, "Hello from r2") @ r2
        };
        println("r2 is now complete")
    };
    println("r1 is now complete")
</code></pre>
<p>This means that Flix supports <em>structured concurrency</em>; spawned
processes have clearly defined entry and exit points.</p>
<h2 id="communicating-with-channels"><a class="header" href="#communicating-with-channels">Communicating with Channels</a></h2>
<p>To communicate between processes we use channels.
A <em>channel</em> allows two or more processes to exchange
data by sending immutable messages to each other.</p>
<p>A channel comes in one of two variants: <em>buffered</em> or
<em>unbuffered</em>. Channels are always associated with a region.</p>
<p>A buffered channel has a size, set at creation time,
and can hold that many messages.
If a process attempts to put a message into a
buffered channel that is full, then the process is
blocked until space becomes available.
If, on the other hand, a process attempts to get a
message from an empty channel, the process is blocked
until a message is put into the channel.</p>
<p>An unbuffered channel works like a buffered channel
of size zero; for a get and a put to happen both
processes must rendezvous (block) until the message
is passed from sender to receiver.</p>
<p>Here is an example of sending and receiving a message
over a channel:</p>
<pre><code class="language-flix">def main(): Int32 \ {Chan, NonDet, IO} = region rc {
    let (tx, rx) = Channel.unbuffered();
    spawn Channel.send(42, tx) @ rc;
    Channel.recv(rx)
}
</code></pre>
<p>Here the <code>main</code> function creates an unbuffered
channel which returns <code>Sender</code> <code>tx</code> and a <code>Receiver</code> <code>rx</code> channels,
spawns the <code>send</code> function, and waits
for a message from the channel.</p>
<p>As the example shows, a channel consists of two end points:
the <em>Sender</em> and the <em>Receiver</em>. As one would expect,
messages can only be send using the <code>Sender</code>, and only
received using the <code>Receiver</code>.</p>
<h2 id="selecting-on-channels"><a class="header" href="#selecting-on-channels">Selecting on Channels</a></h2>
<p>We can use the <code>select</code> expression to receive a
message from a collection of channels.
For example:</p>
<pre><code class="language-flix">def meow(tx: Sender[String]): Unit \ Chan =
    Channel.send("Meow!", tx)

def woof(tx: Sender[String]): Unit \ Chan =
    Channel.send("Woof!", tx)

def main(): Unit \ {Chan, NonDet, IO} = region rc {
    let (tx1, rx1) = Channel.buffered(1);
    let (tx2, rx2) = Channel.buffered(1);
    spawn meow(tx1) @ rc;
    spawn woof(tx2) @ rc;
    select {
        case m &lt;- recv(rx1) =&gt; m
        case m &lt;- recv(rx2) =&gt; m
    } |&gt; println
}
</code></pre>
<p>Many important concurrency patterns such as
producer-consumer and load balancers can be expressed
using the <code>select</code> expression.</p>
<h3 id="selecting-with-default"><a class="header" href="#selecting-with-default">Selecting with Default</a></h3>
<p>In some cases, we do not want to block until a
message arrives, potentially waiting forever.
Instead, we want to take some alternative action if
no message is readily available.
We can achieve this with a <em>default case</em> as shown
below:</p>
<pre><code class="language-flix">def main(): String \ {Chan, NonDet} = region rc {
    let (_, rx1) = Channel.buffered(1);
    let (_, rx2) = Channel.buffered(1);
    select {
        case _ &lt;- recv(rx1) =&gt; "one"
        case _ &lt;- recv(rx2) =&gt; "two"
        case _             =&gt; "default"
    }
}
</code></pre>
<p>Here a message is never sent to <code>r1</code> nor <code>r2</code>.
The <code>select</code> expression tries all cases, and if no
channel is ready, it immediately selects the default
case.
Hence using a default case prevents the <code>select</code>
expression from blocking forever.</p>
<h3 id="selecting-with-timeouts"><a class="header" href="#selecting-with-timeouts">Selecting with Timeouts</a></h3>
<p>As an alternative to a default case, we can use
<em>tickers</em> and <em>timers</em> to wait for pre-defined
periods of time inside a <code>select</code> expression.</p>
<p>For example, here is a program that has a slow
function that takes a minute to send a message on
a channel, but the <code>select</code> expression relies on
<code>Channel.timeout</code> to only wait <code>5</code> seconds before
giving up:</p>
<pre><code class="language-flix">def slow(tx: Sender[String]): Unit \ {Chan, IO} =
    Thread.sleep(Time.Duration.fromSeconds(60));
    Channel.send("I am very slow", tx)

def main(): Unit \ {Chan, NonDet, IO} = region rc {
    let (tx, rx) = Channel.buffered(1);
    spawn slow(tx) @ rc;
    let timeout = Channel.timeout(Time.Duration.fromSeconds(5));
    select {
        case m &lt;- recv(rx)       =&gt; m
        case _ &lt;- recv(timeout)  =&gt; "timeout"
    } |&gt; println
}
</code></pre>
<p>This program prints the string <code>"timeout"</code> after five
seconds.</p>
<h3 id="the-effects-of-channels"><a class="header" href="#the-effects-of-channels">The Effects of Channels</a></h3>
<p>As you might have noticed, the effects <code>Chan</code> and <code>NonDet</code>
shows up when using channels.</p>
<p>Any operation on channels has the <code>Chan</code> effect. This effect
says that the program is either modifying or accessing the global
state of channels.</p>
<p>The <code>recv</code> operation on a channel has the <code>NonDet</code> effect. This
is because the value you receive will, in the general case, be
non-deterministic, depending on the choices of the thread scheduler.
Two threads might be ready to send a value on a channel at the same
time, and it is up to the scheduler which one gets to send first.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="parallelism"><a class="header" href="#parallelism">Parallelism</a></h1>
<p>We have seen how the <code>spawn</code> expression allows us to evaluate an expression in a
new thread:</p>
<pre><code class="language-flix">region rc {
    spawn (1 + 2) @ rc
}
</code></pre>
<p>This allows us to write concurrent and parallel programs using structured
concurrency. The downside is that we must manually coordinate communication
between threads using channels.
If we want parallelism, but not concurrency, a more light-weight approach
is to use the <code>par-yield</code> expression:</p>
<pre><code class="language-flix">par (x &lt;- e1; y &lt;- e2; z &lt;- e3)
    yield x + y + z
</code></pre>
<p>which evaluates <code>e1</code>, <code>e2</code>, and <code>e3</code> in parallel and binds their results to <code>x</code>, <code>y</code>, and <code>z</code>.</p>
<p>We can use <code>par-yield</code> to write a parallel <code>List.map</code> function:</p>
<pre><code class="language-flix">def parMap(f: a -&gt; b, l: List[a]): List[b] = match l {
    case Nil     =&gt; Nil
    case x :: xs =&gt;
        par (r &lt;- f(x); rs &lt;- parMap(f, xs))
            yield r :: rs
}
</code></pre>
<p>This function will evaluate <code>f(x)</code> and <code>parMap(f, xs)</code> in parallel.</p>
<blockquote>
<p><strong>Note:</strong> The <code>par-yield</code> construct only works with pure expressions.</p>
</blockquote>
<p>If you want to run effectful operations in parallel, you must use explicit
regions and threads.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="interoperability-with-java"><a class="header" href="#interoperability-with-java">Interoperability with Java</a></h1>
<p>Flix is a <a href="https://en.wikipedia.org/wiki/Java_virtual_machine">Java Virtual Machine</a> (JVM)-based programming language,
hence:</p>
<ul>
<li>Flix programs compile to efficient JVM bytecode.</li>
<li>Flix programs run on any Java Virtual Machine<sup class="footnote-reference" id="fr-1-1-2"><a href="#footnote-1-2">1</a></sup>.</li>
<li>Flix programs can call Java code.</li>
</ul>
<p>Flix supports most Java features necessary for interoperability:</p>
<ul>
<li><a href="#creating-objects">Creating objects from classes</a></li>
<li><a href="#calling-object-methods">Calling methods on classes and objects</a></li>
<li><a href="#reading-and-writing-fields-1">Reading and writing fields on classes and objects</a></li>
<li><a href="#classes-and-interfaces">Anonymous extension of classes and interfaces</a></li>
<li><a href="#nested-and-inner-classes">Accessing inner classes</a></li>
<li><a href="#exceptions">Catching and throwing exceptions</a></li>
<li><a href="#boxing-and-unboxing">Boxing and unboxing of primitive values</a></li>
</ul>
<p>Thus Flix programs can reuse the Java Class Library. In addition, the Flix
package manager has Maven support.</p>
<p>Flix and Java share the same base types, but they have different names, as shown
in the table:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flix Type</th><th>Java Type</th></tr>
</thead>
<tbody>
<tr><td>Bool</td><td>boolean</td></tr>
<tr><td>Char</td><td>char</td></tr>
<tr><td>Float32</td><td>float</td></tr>
<tr><td>Float64</td><td>double</td></tr>
<tr><td>Int8</td><td>byte</td></tr>
<tr><td>Int16</td><td>short</td></tr>
<tr><td>Int32</td><td>int</td></tr>
<tr><td>Int64</td><td>long</td></tr>
<tr><td>String</td><td>String</td></tr>
</tbody>
</table>
</div>
<p>In Flix primitive types are always unboxed.
Hence, to call a Java method that expects a <code>java.lang.Integer</code>,
if you have a Flix <code>Int32</code>, it must be boxed by calling <code>java.lang.Integer.valueOf</code>.</p>
<hr>
<ol class="footnote-definition">
<li id="footnote-1-2">
<p>Flix requires at least Java 21. <a href="#fr-1-1-2">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="creating-objects"><a class="header" href="#creating-objects">Creating Objects</a></h1>
<p>In Flix, we can create objects using syntax similar to Java.</p>
<p>For example:</p>
<pre><code class="language-flix">import java.io.File

def main(): Unit \ IO = 
    let f = new File("foo.txt");
    println("Hello World!")
</code></pre>
<p>Here we import the <code>java.io.File</code> class and instantiate a <code>File</code> object by
calling one of its constructors using the <code>new</code> keyword.</p>
<p>The <code>File</code> class has multiple constructors, so we can also write:</p>
<pre><code class="language-flix">import java.io.File

def main(): Unit \ IO = 
    let f1 = new File("foo.txt");
    let f2 = new File("bar", "foo.txt");
    println("Hello World!")
</code></pre>
<p>Flix resolves the constructor based on the number of arguments and their types.</p>
<p>As another example, we can write:</p>
<pre><code class="language-flix">import java.io.File
import java.net.URI

def main(): Unit \ IO = 
    let f1 = new File("foo.txt");
    let f2 = new File("bar", "foo.txt");
    let f3 = new File(new URI("file://foo.txt"));
    println("Hello World!")
</code></pre>
<p>We can use a <em>renaming import</em> to resolve a clash between a Java name and a Flix
module:</p>
<pre><code class="language-flix">import java.lang.{String =&gt; JString}

def main(): Unit \ IO = 
    let s = new JString("Hello World");
    println("Hello World!")
</code></pre>
<p>Here <code>JString</code> refers to the Java class <code>java.lang.String</code> whereas <code>String</code>
refers to the Flix module. Note that internally Flix and Java strings are the
same.</p>
<blockquote>
<p><strong>Note:</strong> Any interaction with Java code always has the <code>IO</code> effect.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> In Flix, Java classes must be <code>import</code>ed before they can be used. In
particular, we <em>cannot</em> write <code>new java.io.File(...)</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="calling-object-methods"><a class="header" href="#calling-object-methods">Calling Object Methods</a></h1>
<p>In Flix, we can call methods on Java objects using syntax similar to Java.</p>
<p>For example:</p>
<pre><code class="language-flix">import java.io.File

def main(): Unit \ IO = 
    let f = new File("foo.txt");
    println(f.getName())
</code></pre>
<p>Here we import the <code>java.io.File</code> class, instantiate a <code>File</code> object, and then
call the <code>getName</code> method on that object.</p>
<p>Like with constructors, Flix resolves the method based on the number of
arguments and their types.</p>
<p>Here is another example:</p>
<pre><code class="language-flix">import java.io.File

def main(): Unit \ IO = 
    let f = new File("foo.txt");
    if (f.exists())
        println("The file ${f.getName()} exists!")
    else
        println("The file ${f.getName()} does not exist!")
</code></pre>
<p>And here is a larger example:</p>
<pre><code class="language-flix">import java.io.File
import java.io.FileWriter

def main(): Unit \ IO = 
    let f = new File("foo.txt");
    let w = new FileWriter(f);
    w.append("Hello World\n");
    w.close()
</code></pre>
<p>In the above example, we may want to catch the <code>IOException</code> that can be raised:</p>
<pre><code class="language-flix">import java.io.File
import java.io.FileWriter
import java.io.IOException

def main(): Unit \ IO = 
    let f = new File("foo.txt");
    try {
        let w = new FileWriter(f);
        w.append("Hello World\n");
        w.close()
    } catch {
        case ex: IOException =&gt; 
            println("Unable to write to file: ${f.getName()}");
            println("The error message was: ${ex.getMessage()}")
    }
</code></pre>
<h2 id="calling-static-methods"><a class="header" href="#calling-static-methods">Calling Static Methods</a></h2>
<p>In Flix, we can call static methods (i.e. class methods) using syntax similar to Java:</p>
<p>For example:</p>
<pre><code class="language-flix">import java.lang.Math

def main(): Unit \ IO = 
    let n = Math.sin(3.14);
    println(n)

</code></pre>
<p>Like with constructors and methods, Flix resolves the static method based on the
number of arguments and their types.</p>
<p>Here is another example:</p>
<pre><code class="language-flix">import java.lang.Math

def main(): Unit \ IO = 
    println(Math.abs(-123i32));
    println(Math.abs(-123i64));
    println(Math.abs(-123.456f32));
    println(Math.abs(-123.456f64))
</code></pre>
<h2 id="calling-constructors-or-methods-with-varargs"><a class="header" href="#calling-constructors-or-methods-with-varargs">Calling Constructors or Methods with VarArgs</a></h2>
<p>We can call a constructor or method that takes variable arguments using the
special syntax <code>...{ value1, value2, ...}</code>. For example:</p>
<pre><code class="language-flix">import java.nio.file.Path

def getMyPhoto(): Path \ IO =
    Path.of("Documents", ...{"Images", "me.jpg"})
</code></pre>
<p>Here we call the <code>Path.of</code> Java method which requires a single string and then
a varargs array of strings.</p>
<p>In the special case where we want to call a constructor or method without any
varargs we have to explicitly pass an empty <code>Vector[t]</code>. Moreover, we have to
specify the type of the elements. For example:</p>
<pre><code>import java.nio.file.Path

def getDocuments(): Path \ IO =
    Path.of("Documents", (Vector.empty(): Vector[String]))
</code></pre>
<h2 id="when-constructor-or-method-resolution-fails"><a class="header" href="#when-constructor-or-method-resolution-fails">When Constructor or Method Resolution Fails</a></h2>
<p>In some cases the Flix compiler is unable to determine what Java constructor or
method is called.</p>
<p>For example, in the program:</p>
<pre><code class="language-flix">import java.lang.{String =&gt; JString}

def f(): String \ IO = 
    let o = ???;
    JString.valueOf(o)
</code></pre>
<p>The type of <code>o</code> is unknown, hence Flix cannot know if we want to call
<code>String.valueOf(boolean)</code>, <code>String.valueOf(char)</code>, <code>String.valueOf(double)</code>, or
one of the other overloaded versions.</p>
<p>The solution is to put a type ascription on the relevant argument:</p>
<pre><code class="language-flix">import java.lang.{String =&gt; JString}

def f(): String \ IO = 
    let o = ???;
    JString.valueOf((o: Bool))
</code></pre>
<p>The type ascription specifies that <code>o</code> has type <code>Bool</code> which allows method
resolution to complete successfully. Note that the extra pair of parenthesis is
required.</p>
<h2 id="calling-java-methods-known-to-be-pure"><a class="header" href="#calling-java-methods-known-to-be-pure">Calling Java Methods Known to be Pure</a></h2>
<p>Any Flix expression that creates a Java object, calls a Java method, or calls a
Java static method has the <code>IO</code> effect. This is to be expected: Java
constructors and methods may have arbitrary side-effects.</p>
<p>If we know for certain that a Java constructor or method invocation has no
side-effects, we can use an <code>unsafe</code> block to tell Flix to treat that expression
as pure.</p>
<p>For example:</p>
<pre><code class="language-flix">import java.lang.Math

def pythagoras(x: Float64, y: Float64): Float64 = // Pure, no IO effect
    unsafe Math.sqrt((Math.pow(x, 2.0) + Math.pow(y, 2.0)))

def main(): Unit \ IO = 
    println(pythagoras(3.0, 4.0))
</code></pre>
<p>Here we know for certain that <code>Math.pow</code> and <code>Math.sqrt</code> are <em>pure</em> functions,
hence we can put them inside an <code>unsafe</code> block. Thus we are able to type check
the Flix <code>pythagoras</code> function as pure, i.e. without the <code>IO</code> effect.</p>
<blockquote>
<p><strong>Warning:</strong> Do not, under any circumstances, use <code>unsafe</code> on expressions that
have side-effects. Doing so breaks the type and effect system which can lead
to incorrect compiler optimizations which can change the meaning of your
program in subtle or catastrophic ways!</p>
</blockquote>
<h2 id="partial-application-of-java-constructors-and-methods"><a class="header" href="#partial-application-of-java-constructors-and-methods">Partial Application of Java Constructors and Methods</a></h2>
<p>Flix supports partial application of Flix functions. However, Java constructors
and methods can never be partially applied. This limitation can be overcome
introducing an explicit lambda.</p>
<p>For example:</p>
<pre><code class="language-flix">import java.lang.{String =&gt; JString}

def main(): Unit \ IO = 
    def replaceAll(s, src, dst) = s.replaceAll(src, dst);
    let f = replaceAll("Hello World");
    let s1 = f("World")("Galaxy");
    let s2 = f("World")("Universe");
    println(s1);
    println(s2)
</code></pre>
<p>Here we introduce a Flix function <code>replaceAll</code> which calls <code>String.replaceAll</code>.
Since <code>replaceAll</code> is a Flix function, we can partially apply it as shown in the
example.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="reading-and-writing-fields-1"><a class="header" href="#reading-and-writing-fields-1">Reading and Writing Fields</a></h1>
<p>Flix supports reading object fields and static (class) fields with standard Java
syntax.</p>
<h2 id="reading-object-fields"><a class="header" href="#reading-object-fields">Reading Object Fields</a></h2>
<p>We can read an object field as follows:</p>
<pre><code class="language-flix">import java.awt.Point

def area(p: Point): Int32 \ IO = p.x * p.y
</code></pre>
<h2 id="reading-static-fields"><a class="header" href="#reading-static-fields">Reading Static Fields</a></h2>
<p>We can read a static field as follows:</p>
<pre><code class="language-flix">import java.lang.Math

def area(radius: Float64): Float64 = (unsafe Math.PI) * radius * radius
</code></pre>
<p>We import the <code>java.lang.Math</code> class and then we access the static <code>PI</code> field.</p>
<p>We know that the <code>PI</code> field will never change, hence we cast away the effect with <code>unsafe</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="classes-and-interfaces"><a class="header" href="#classes-and-interfaces">Classes and Interfaces</a></h1>
<p>Flix allows us to create objects that extend a Java class or implements a Java interface.</p>
<p>This feature is conceptually similar to Java’s <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">Anonymous Classes</a>:
We can define an (unnamed class) which implements an interface or extends a class and create an object of that class. All in one expression.</p>
<p>For example, we can create an object that implements the <code>java.lang.Runnable</code> interface:</p>
<pre><code class="language-flix">import java.lang.Runnable

def newRunnable(): Runnable \ IO = new Runnable {
    def $run(_this: Runnable): Unit \ IO = 
        println("I am running!")
}
</code></pre>
<p>Every time we call <code>newRunnable</code> we get a <em>fresh</em> object that implements <code>java.lang.Runnable</code>.</p>
<blockquote>
<p><strong>Note:</strong> The implicit <code>this</code> argument is always explicitly passed as the first argument in a new expression.</p>
</blockquote>
<p>As another example, we can create an object that implements the <code>java.io.Closeable</code> interface:</p>
<pre><code class="language-flix">import java.io.Closeable

def newClosable(): Closeable \ IO = new Closeable {
    def close(_this: Closeable): Unit \ IO = 
        println("I am closing!")
}
</code></pre>
<p>We can also extend classes. For example, we can create a
<code>java.lang.Object</code> where we override the <code>hashCode</code> and <code>toString</code> methods:</p>
<pre><code class="language-flix">def newObject(): Object \ IO = new Object {
    def hashCode(_this: Object): Int32 = 42
    def toString(_this: Object): String = "Hello World!"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="nested-and-inner-classes"><a class="header" href="#nested-and-inner-classes">Nested and Inner Classes</a></h1>
<p>Java supports nested static and non-static inner classes:</p>
<p>For example:</p>
<pre><code class="language-java">package Foo.Bar;

class OuterClass {
    ...
    class InnerClass {
        ...
    }
    static class StaticInnerClass {
        public static String hello() { return "Hi"; }
    }
}
</code></pre>
<p>In Flix, we can access the <code>StaticInnerClass</code> using the <code>import</code> statement:</p>
<pre><code class="language-flix">import Foo.Bar.{OuterClass$StaticInnerClass =&gt; Inner}

def main(): Unit \ IO = 
    println(Inner.hello())
</code></pre>
<p>A typical example is to access the <code>Map.Entry</code> class:</p>
<pre><code class="language-flix">import java.util.{Map$Entry =&gt; Entry}
</code></pre>
<blockquote>
<p><strong>Note:</strong> Flix does not support accessing nested non-static inner classes.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h1>
<p>In Flix, we can catch Java exceptions using the <code>try-catch</code> construct. The
construct is similar to the one in Java, but the syntax is slightly different.</p>
<p>For example:</p>
<pre><code class="language-flix">import java.io.BufferedReader
import java.io.File
import java.io.FileReader
import java.io.FileNotFoundException
import java.io.IOException

def main(): Unit \ IO = 
    let f = new File("foo.txt");
    try {
        let r = new BufferedReader(new FileReader(f));
        let l = r.readLine();
        println("The first line of the file is: ${l}");
        r.close()
    } catch {
        case _: FileNotFoundException =&gt; 
            println("The file does not exist!")
        case ex: IOException =&gt; 
            println("The file could not be read!");
            println("The error message was: ${ex.getMessage()}")
    }
</code></pre>
<p>Here the calls <code>new FileReader()</code>, <code>r.readLine()</code>, and <code>r.close()</code> can throw
<code>IOException</code>s. We use a <code>try-catch</code> block to catch these exceptions. We add a
special case for the <code>FileNotFoundException</code> exception.</p>
<blockquote>
<p><strong>Note:</strong> Flix programs should not use exceptions: it is considered bad style.
Instead, programs should use the <code>Result[e, t]</code> type. The <code>try-catch</code>
construct should only be used on the boundary between Flix and Java code.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> Flix does not (yet) support a <code>finally</code> block.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="boxing-and-unboxing"><a class="header" href="#boxing-and-unboxing">Boxing and Unboxing</a></h1>
<p>Unlike Java, Flix never performs implicit boxing or unboxing of values.</p>
<p>We believe auto boxing is a design flaw and do not plan to support it. Hence,
primitive values must be manually boxed and unboxed.</p>
<h2 id="boxing"><a class="header" href="#boxing">Boxing</a></h2>
<p>The following example shows how to box a primitive integer:</p>
<pre><code class="language-flix">def f(x: Int32): String \ IO = 
    let i = Box.box(x); // Integer
    i.toString()
</code></pre>
<p>Here the call to <code>Box.box(x)</code> returns an <code>Integer</code> object. Since <code>i</code> is an
object, we can call <code>toString</code> on it. Boxing is a pure operation, but calling
<code>toString</code> has the <code>IO</code> effect.</p>
<h2 id="unboxing"><a class="header" href="#unboxing">Unboxing</a></h2>
<p>The following example shows how to unbox two Java <code>Integer</code> objects:</p>
<pre><code class="language-flix">import java.lang.Integer

def sum(x: Integer, y: Integer): Int32 = 
    Box.unbox(x) + Box.unbox(y)
</code></pre>
<p>Here the call to <code>Box.unbox</code> returns an <code>Int32</code> primitive value.</p>
<p>Unboxing is a pure operation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="java-collections"><a class="header" href="#java-collections">Java Collections</a></h1>
<p>Flix has support for conversion from and to Java collections.</p>
<p>In the following, we use the following import aliases:</p>
<pre><code class="language-flix">import java.util.{List =&gt; JList}
import java.util.{LinkedList =&gt; JLinkedList}
import java.util.{ArrayList =&gt; JArrayList}
import java.util.{Set =&gt; JSet}
import java.util.{TreeSet =&gt; JTreeSet}
import java.util.{Map =&gt; JMap}
import java.util.{TreeMap =&gt; JTreeMap}
</code></pre>
<p>The following functions are available in the
<a href="../api.flix.dev/Adaptor.html">Adaptor</a> module:</p>
<h2 id="flix-to-java"><a class="header" href="#flix-to-java">Flix to Java</a></h2>
<p>The following functions <em>convert</em> Flix collections to Java collections:</p>
<pre><code class="language-flix">///
/// Lists
///
def toList(ma: m[a]): JList \ IO + Aef[m] with Foldable[m]
def toArrayList(ma: m[a]): JArrayList \ IO + Aef[m] with Foldable[m]
def toLinkedList(ma: m[a]): JLinkedList \ IO + Aef[m] with Foldable[m]

///
/// Sets
///
def toSet(ma: m[a]): JSet \ IO + Aef[m] with Order[a], Foldable[m]
def toTreeSet(ma: m[a]): JTreeSet \ IO + Aef[m] with Order[a], Foldable[m]

///
/// Maps
///
def toMap(m: Map[k, v]): JMap \ IO with Order[k]
def toTreeMap(m: Map[k, v]): JTreeMap \ IO with Order[k]
</code></pre>
<p>Each function constructs a new collection and copies all its elements into it.
Hence each operation takes at least linear time. The result is a normal Java
collection (which can be modified).</p>
<h2 id="java-to-flix"><a class="header" href="#java-to-flix">Java to Flix</a></h2>
<p>The following functions <em>convert</em> Java collections to Flix collections:</p>
<pre><code class="language-flix">/// Lists
def fromList(l: JList): List[a]

/// Sets
def fromSet(l: JSet): Set[a] with Order[a]

/// Maps
def fromMap(m: JMap): Map[k, v] with Order[k]
</code></pre>
<p>Each function constructs a new Flix collection from a Java Collection. Hence
each operation takes at least linear time. Note that for <code>Set</code> and <code>Map</code>, the
Flix collections use the <code>Order[a]</code> instance defined on <code>a</code>. This may not be the
same ordering as used by Java.</p>
<blockquote>
<p><strong>Warning:</strong> Converting Flix and/or Java collections with primitive values
requires extra care. In particular, values must be manually boxed or unboxed
before any conversion.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fixpoints"><a class="header" href="#fixpoints">Fixpoints</a></h1>
<p>A unique feature of Flix is its built-in support for
fixpoint computations on <em>constraint on relations</em>
and <em>constraint on lattices</em>.</p>
<p>We assume that the reader is already familiar with
Datalog and focus on the Flix specific features.</p>
<h2 id="using-flix-to-solve-constraints-on-relations"><a class="header" href="#using-flix-to-solve-constraints-on-relations">Using Flix to Solve Constraints on Relations</a></h2>
<p>We can use Flix to solve a fixpoint computation
inside a function.</p>
<p>For example, given a set of edges <code>s</code>, a <code>src</code> node,
and <code>dst</code> node, compute if there is a path from <code>src</code>
to <code>dst</code>.
We can elegantly solve this problem as follows:</p>
<pre><code class="language-flix">def isConnected(s: Set[(Int32, Int32)], src: Int32, dst: Int32): Bool =
    let rules = #{
        Path(x, y) :- Edge(x, y).
        Path(x, z) :- Path(x, y), Edge(y, z).
    };
    let edges = inject s into Edge/2;
    let paths = query edges, rules select true from Path(src, dst);
    not (paths |&gt; Vector.isEmpty)

def main(): Unit \ IO =
    let s = Set#{(1, 2), (2, 3), (3, 4), (4, 5)};
    let src = 1;
    let dst = 5;
    if (isConnected(s, src, dst)) {
        println("Found a path between ${src} and ${dst}!")
    } else {
        println("Did not find a path between ${src} and ${dst}!")
    }
</code></pre>
<p>The <code>isConnected</code> function behaves like any other
function: We can call it with a set of edges
(<code>Int32</code>-pairs), an <code>Int32</code> source node, and
an <code>Int32</code> destination node.
What is interesting about <code>isConnected</code> is that its
implementation uses a small Datalog program to solve
the task at hand.</p>
<p>In the <code>isConnected</code> function, the local variable
<code>rules</code> holds a Datalog program fragment that
consists of two rules which define the <code>Path</code>
relation.
Note that the predicate symbols, <code>Edge</code> and <code>Path</code> do
not have to be explicitly introduced; they are simply
used.
The local variable <code>edges</code> holds a collection of edge
facts that are obtained by taking all the tuples in
the set <code>s</code> and turning them into <code>Edge</code> facts.
Next, the local variable <code>paths</code> holds the result of
computing the fixpoint of the facts and rules
(<code>edges</code> and <code>rules</code>) and selecting the Boolean
<code>true</code> <em>if</em> there is a <code>Path(src, dst)</code> fact.
Note that here <code>src</code> and <code>dst</code> are the
lexically-bound function parameters.
Thus, <code>paths</code> is either an empty array (no paths were
found) or a one-element array (a path was found), and
we simply return this fact.</p>
<p>Flix is strongly typed.
Any attempt to use predicate symbol with terms of the
wrong type (or with the wrong arity) is caught by the
type checker.
Note also that Flix supports type inference, hence we
did not have to declare the type of <code>Edge</code> nor of
<code>Path</code>.</p>
<h2 id="programming-with-first-class-constraints"><a class="header" href="#programming-with-first-class-constraints">Programming with First-class Constraints</a></h2>
<p>A unique feature of Flix is its support for
<em>first-class constraints</em>.
A first-class constraint is a value that can be
constructed, passed around, composed with other
constraints, and ultimately solved.
The solution to a constraint system is another
constraint system which can be further composed.
For example:</p>
<pre><code class="language-flix">def getParents(): #{ ParentOf(String, String) | r } = #{
    ParentOf("Pompey", "Strabo").
    ParentOf("Gnaeus", "Pompey").
    ParentOf("Pompeia", "Pompey").
    ParentOf("Sextus", "Pompey").
}

def getAdoptions(): #{ AdoptedBy(String, String) | r } = #{
    AdoptedBy("Augustus", "Caesar").
    AdoptedBy("Tiberius", "Augustus").
}

def withAncestors(): #{ ParentOf(String, String),
                        AncestorOf(String, String) | r } = #{
        AncestorOf(x, y) :- ParentOf(x, y).
        AncestorOf(x, z) :- AncestorOf(x, y), AncestorOf(y, z).
}

def withAdoptions(): #{ AdoptedBy(String, String),
                        AncestorOf(String, String) | r } = #{
    AncestorOf(x, y) :- AdoptedBy(x, y).
}

def main(): Unit \ IO =
    let c = false;
    if (c) {
        query getParents(), getAdoptions(), withAncestors()
            select (x, y) from AncestorOf(x, y) |&gt; println
    } else {
        query getParents(), getAdoptions(), withAncestors(), withAdoptions()
            select (x, y) from AncestorOf(x, y) |&gt; println
    }
</code></pre>
<p>The program uses three predicate symbols: <code>ParentOf</code>,
<code>AncestorOf</code>, and <code>AdoptedBy</code>.
The <code>getParents</code>function returns a collection of facts
that represent biological parents, whereas the
<code>getAdoptions</code> function returns a collection of facts
that represent adoptions.
The <code>withAncestors</code> function returns two constraints
that populate the <code>AncestorOf</code> relation using the
<code>ParentOf</code> relation.
The <code>withAdoptions</code> function returns a constraint
that populates the <code>ParentOf</code> relation using the
<code>AdoptedBy</code> relation.</p>
<p>In the <code>main</code> function the local variable <code>c</code>
controls whether we query a Datalog program that only
considers biological parents or if we include
adoptions.</p>
<p>As can be seen, the types the functions are
row-polymorphic.
For example, the signature of <code>getParents</code> is
<code>def getParents(): #{ ParentOf | r }</code> where <code>r</code>
is row polymorphic type variable that represent the
rest of the predicates that the result of the
function can be composed with.</p>
<blockquote>
<p><strong>Design Note</strong></p>
<p>The row polymorphic types are best understood as an
over-approximation of the predicates that may occur
in a constraint system.
For example, if a constraint system has type
<code>#{ A(String), B(Int32, Int32) }</code> that doesn’t
necessarily mean that it will contain facts or rules
that use the predicate symbols <code>A</code> or <code>B</code>, but it
does guarantee that it will not contain any fact or
rule that refer to a predicate symbol <code>C</code>.</p>
</blockquote>
<h2 id="polymorphic-first-class-constraints"><a class="header" href="#polymorphic-first-class-constraints">Polymorphic First-class Constraints</a></h2>
<p>Another unique feature of Flix is its support for
first-class <em>polymorphic</em> constraints.
That is, constraints where one or more constraints
are polymorphic in their term types.
For example:</p>
<pre><code class="language-flix">def edgesWithNumbers(): #{ LabelledEdge(String, Int32 , String) | r } = #{
    LabelledEdge("a", 1, "b").
    LabelledEdge("b", 1, "c").
    LabelledEdge("c", 2, "d").
}

def edgesWithColor(): #{ LabelledEdge(String, String, String) | r } = #{
    LabelledEdge("a", "red", "b").
    LabelledEdge("b", "red", "c").
    LabelledEdge("c", "blu", "d").
}

def closure(): #{ LabelledEdge(String, l, String),
                  LabelledPath(String, l, String) } with Order[l] = #{
    LabelledPath(x, l, y) :- LabelledEdge(x, l, y).
    LabelledPath(x, l, z) :- LabelledPath(x, l, y), LabelledPath(y, l, z).
}

def main(): Unit \ IO =
    query edgesWithNumbers(), closure()
        select (x, l, z) from LabelledPath(x, l, z) |&gt; println;
    query edgesWithColor(), closure()
        select (x, l, z) from LabelledPath(x, l, z) |&gt; println
</code></pre>
<p>Here we use two predicate symbols: <code>LabelledEdge</code> and
<code>LabelledPath</code>.
Each predicate has a type parameter named <code>l</code> and is
polymorphic in the “label” type associated with the
edge/path.
Note how <code>edgesWithNumbers</code> returns a collection of
edge facts where the labels are integers, whereas
<code>edgesWithColor</code> returns a collection of facts where
the labels are strings.
The <code>closure</code> function is polymorphic and returns two
rules that compute the transitive closure of edges
that have the same label.</p>
<p>The Flix type system ensures that we cannot
accidentally mix edges (or paths) with different
types of labels.</p>
<h2 id="injecting-facts-into-datalog"><a class="header" href="#injecting-facts-into-datalog">Injecting Facts into Datalog</a></h2>
<p>Flix provides a flexible mechanism that allows
functional data structures (such as lists, sets,
and maps) to be converted into Datalog facts.</p>
<p>For example, given a Flix list of pairs we can
convert it to a collection of Datalog facts:</p>
<pre><code class="language-flix">let l = (1, 2) :: (2, 3) :: Nil;
let p = inject l into Edge/2;
</code></pre>
<p>where <code>l</code> has type <code>List[(Int32, Int32)]</code>.
The <code>inject</code> expression converts <code>l</code> into a Datalog
constraint set <code>p</code> of type
<code>#{ Edge(Int32, Int32) | ... }</code>.
The expression includes the predicate’s arity:
<code>Edge/2</code>.
The general form is <code>Predicate/Arity</code>.</p>
<p>The <code>inject</code> expression works with any type that
implements the <code>Foldable</code> trait.
Consequently, it can be used with lists, sets, maps,
and so forth.</p>
<p>The <code>inject</code> expression can operate on multiple
collections simultaneously.
For example:</p>
<pre><code class="language-flix">let names = "Lucky Luke" :: "Luke Skywalker" :: Nil;
let jedis = "Luke Skywalker" :: Nil;
let p = inject names, jedis into Name/1, Jedi/1;
</code></pre>
<p>where <code>p</code> has type
<code>#{ Name(String), Jedi(String) | ... }</code>.</p>
<h2 id="pipelines-of-fixpoint-computations"><a class="header" href="#pipelines-of-fixpoint-computations">Pipelines of Fixpoint Computations</a></h2>
<p>The solution (i.e. fixpoint) of a constraint system
is another constraint system.
We can use this to construct <em>pipelines</em> of fixpoint
computations, i.e. to feed the result of one fixpoint
computation into another fixpoint computation.
For example:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    let f1 = #{
        ColorEdge(1, "blue", 2).
        ColorEdge(2, "blue", 3).
        ColorEdge(3, "red", 4).
    };
    let r1 = #{
        ColorPath(x, c, y) :- ColorEdge(x, c, y).
        ColorPath(x, c, z) :- ColorPath(x, c, y), ColorEdge(y, c, z).
    };
    let r2 = #{
        ColorlessPath(x, y) :- ColorPath(x, _, y).
    };
    let m = solve f1, r1 project ColorPath;
    query m, r2 select (x, y) from ColorlessPath(x, y) |&gt; println
</code></pre>
<p>The program uses three predicates: <code>ColorEdge</code>,
<code>ColorPath</code>, and <code>ColorlessPath</code>.
Our goal is to compute the transitive closure of the
colored edges and then afterwards construct a graph
where the edges have no color.</p>
<p>The program first computes the fixpoint of <code>f1</code> and
<code>r1</code> and injects out the <code>ColorPath</code> fact.
The result is stored in <code>m</code>. Next, the program
queries <code>m</code> and <code>r2</code>, and selects all <code>ColorlessPath</code>
facts.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="stratified-negation"><a class="header" href="#stratified-negation">Stratified Negation</a></h1>
<p>Flix supports <em>stratified negation</em> which allow
restricted use of negation in rule bodies.
For example:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    let movies = #{
        Movie("The Hateful Eight").
        Movie("Interstellar").
    };
    let actors = #{
        StarringIn("The Hateful Eight", "Samuel L. Jackson").
        StarringIn("The Hateful Eight", "Kurt Russel").
        StarringIn("The Hateful Eight", "Quentin Tarantino").
        StarringIn("Interstellar", "Matthew McConaughey").
        StarringIn("Interstellar", "Anne Hathaway").
    };
    let directors = #{
        DirectedBy("The Hateful Eight", "Quentin Tarantino").
        DirectedBy("Interstellar", "Christopher Nolan").
    };
    let rule = #{
        MovieWithoutDirector(title) :-
            Movie(title),
            DirectedBy(title, name),
            not StarringIn(title, name).
    };
    query movies, actors, directors, rule
        select title from MovieWithoutDirector(title) |&gt; println
</code></pre>
<p>The program defines three local variables that
contain information about movies, actors, and
directors.
The local variable <code>rule</code> contains a rule that
captures all movies where the director does not star
in the movie.
Note the use negation in this rule.
The query returns an array with the string
<code>"Interstellar"</code> because Christopher Nolan did not
star in that movie.</p>
<blockquote>
<p><strong>Note:</strong> Flix enforces that programs are stratified, i.e. a program must not
have recursive dependencies on which there is use of negation. If there is,
the Flix compiler rejects the program.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="local-predicates"><a class="header" href="#local-predicates">Local Predicates</a></h1>
<p>Flix supports an abstract mechanism called <em>local predicates</em>. A local
predicate, like a local variable, is not visible to the outside.</p>
<p>To understand local predicates, consider the following example: We can a write a
function that returns a Datalog program value which computes whether a graph has
a cycle:</p>
<pre><code class="language-flix">def cyclic(): #{Edge(Int32, Int32), Path(Int32, Int32), Cyclic()} = #{
    Path(x, y) :- Edge(x, y).
    Path(x, z) :- Path(x, y), Edge(y, z).
    Cyclic() :- Path(x, x).
}

def main(): Unit \ IO = 
    let db = #{
        Edge(1, 2).
        Edge(2, 3).
        Edge(3, 1).
    };
    query db, cyclic() select true from Cyclic() |&gt; println
</code></pre>
<p>Here the <code>cyclic</code> function returns a <em>Datalog program value</em> which consists of
three rules that compute the transitive closure of a graph of edges and whether
there is path from a vertex to itself. We use the <code>cyclic</code> function inside
<code>main</code> to determine if a small graph, given by <code>db</code>, has a cyclic. The program
prints <code>Vector#{true}</code> when compiled and run.</p>
<p>Returning to <code>cyclic</code>, we see that its type is:</p>
<pre><code class="language-flix">def cyclic(): #{Edge(Int32, Int32), Path(Int32, Int32), Cyclic()} = ...
</code></pre>
<p>This is sensible because the Datalog program value uses the predicate symbols
<code>Edge</code>, <code>Path</code> and <code>Cyclic</code> with their given types. However, if we think more
about it, we can realize that the <code>Path</code> predicate is really local to the
computation: We are not meant to see it from the outside; it is an
implementation detail! What we really want is that <code>Edge(Int32, Int32)</code> should
be an <em>input</em> and <code>Cyclic()</code> should be an <em>output</em>. More importantly,
<code>Path(Int32, Int32)</code> should not be visible from the outside nor part of the
type. We can achieve this with <em>predicate abstraction</em>:</p>
<pre><code class="language-flix">def cyclic(): #{Edge(Int32, Int32), Cyclic()} = 
    #(Edge, Cyclic) -&gt; #{
        Path(x, y) :- Edge(x, y).
        Path(x, z) :- Path(x, y), Edge(y, z).
        Cyclic() :- Path(x, x).
    }
</code></pre>
<p>Here we use the syntax <code>#(Edge, Cyclic) -&gt; v</code> to specific that <em>only</em> the
predicates <code>Edge</code> and <code>Cyclic</code> from within <code>v</code> should be visible to the outside.
Thus we can omit <code>Path(Int32, Int32)</code> from the return type of <code>cyclic</code>.
Moreover, the Datalog program value no longer contains a <code>Path</code> predicate symbol
that can be referenced. We can evidence this by observing that the program:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    let db = #{
        Edge(1, 2).
        Edge(2, 3).
        Edge(3, 1).
    };
    query db, cyclic() select (x, y) from Path(x, y) |&gt; println
</code></pre>
<p>prints the empty vector <code>Vector#{}</code> since <code>Path</code> has been made local by the predicate
abstraction.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="functional-predicates"><a class="header" href="#functional-predicates">Functional Predicates</a></h1>
<p>We sometimes run into a situation where we would like to use a logic predicate,
but not to exhaustively enumerate all of its tuples.</p>
<p>For example, we can image a situation where we want a predicate
<code>PrimeInRange(from, to, prime)</code> which holds if <code>prime</code> is a prime number in the
range <code>[from; to]</code>. While we can imagine such a predicate, it is not feasible to
compute with. Instead, what we often want, is that we want to treat
<code>PrimeInRange</code> as a <strong>functional</strong>, i.e. a function that given <code>from</code> and <code>to</code>
as <em>input</em> produces a set of primes as <em>output</em>. To make matters concrete, we
might want to write the rule:</p>
<pre><code class="language-flix">R(p) :- P(x), Q(y), PrimeInRange(x, y, p).
</code></pre>
<p>but without having to evaluate <code>PrimeInRange</code> for every <code>x</code>, <code>y</code>, and <code>p</code>.</p>
<p>We can achieve this as follows. We write a function:</p>
<pre><code class="language-flix">def primesInRange(b: Int32, e: Int32): Vector[Int32] = 
    Vector.range(b, e) |&gt; Vector.filter(isPrime)
</code></pre>
<p>The key is that <code>primesInRange</code> is a <em>function</em> which returns a vector of tuples
(in this case single elements), given a begin <code>b</code> and end index <code>e</code>. Thus
<code>primesInRange</code> can efficiently compute the tuples we are interested in. To use
it in our rule, we write:</p>
<pre><code class="language-flix">R(p) :- P(b), Q(e), let p = primesInRange(b, e).
</code></pre>
<p>where <code>b</code> and <code>e</code> are clearly identified as the input of <code>primesInRange</code> and <code>p</code>
as its output. Specifically, Flix requires that <code>b</code> and <code>e</code> are positively bound
(i.e. bound by a non-negative body atom– in this case <code>P</code> and <code>Q</code>.) In this
case, <code>primesInRanges</code> returns a vector of <code>Int32</code>s, but in general a functional
may return a vector of tuples.</p>
<blockquote>
<p><strong>Note:</strong> An important limitation in the current implementation is that the
variables in the LHS of a functional predicate <em>must not</em> be rebound. That is,
if the functional predicate is of the form <code>let (a, b) = f(x, y)</code> then <code>a</code> and
<code>b</code> must not be rebound in the rule.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="using-flix-to-solve-constraints-on-lattices"><a class="header" href="#using-flix-to-solve-constraints-on-lattices">Using Flix to Solve Constraints on Lattices</a></h1>
<p>Flix supports not only <em>constraints on relations</em>,
but also <em>constraints on lattices</em>.
To create such constraints, we must first define the
lattice operations (the partial order, the least
upper bound, and so on) as functions, associate them
with a type, and then declare the predicate symbols
that have lattice semantics.</p>
<p>We begin with the definition of the <code>Sign</code> data type:</p>
<pre><code class="language-flix">use Sign.{Top, Neg, Zer, Pos, Bot};

enum Sign {
    case Top,
    case Neg,
    case Zer,
    case Pos,
    case Bot
}
</code></pre>
<p>We need to define the usual <code>Eq</code>, <code>Order</code>, and
<code>ToString</code> instances for this new type.
Note that the order instance is unrelated to the
partial order instance we will later define, and is
simply used to sort elements for pretty printing etc.</p>
<pre><code class="language-flix">instance Eq[Sign] {
    pub def eq(x: Sign, y: Sign): Bool = match (x, y) {
        case (Bot, Bot) =&gt; true
        case (Neg, Neg) =&gt; true
        case (Zer, Zer) =&gt; true
        case (Pos, Pos) =&gt; true
        case (Top, Top) =&gt; true
        case _          =&gt; false
    }
}

instance Order[Sign] {
    pub def compare(x: Sign, y: Sign): Comparison =
        let num = w -&gt; match w {
            case Bot =&gt; 0
            case Neg =&gt; 1
            case Zer =&gt; 2
            case Pos =&gt; 3
            case Top =&gt; 4
        };
        num(x) &lt;=&gt; num(y)
}

instance ToString[Sign] {
    pub def toString(x: Sign): String = match x {
        case Bot =&gt; "Bot"
        case Neg =&gt; "Neg"
        case Zer =&gt; "Zer"
        case Pos =&gt; "Pos"
        case Top =&gt; "Top"
    }
}
</code></pre>
<p>With these trait instances in place, we can now
define the lattice operations on <code>Sign</code>.</p>
<p>We define the bottom element and the partial order:</p>
<pre><code class="language-flix">instance LowerBound[Sign] {
    pub def minValue(): Sign = Bot
}

instance PartialOrder[Sign] {
    pub def lessEqual(x: Sign, y: Sign): Bool =
        match (x, y) {
            case (Bot, _)   =&gt; true
            case (Neg, Neg) =&gt; true
            case (Zer, Zer) =&gt; true
            case (Pos, Pos) =&gt; true
            case (_, Top)   =&gt; true
            case _          =&gt; false
        }
}
</code></pre>
<p>Next, we define the least upper bound and greatest
lower bound:</p>
<pre><code class="language-flix">instance JoinLattice[Sign] {
    pub def leastUpperBound(x: Sign, y: Sign): Sign =
        match (x, y) {
            case (Bot, _)   =&gt; y
            case (_, Bot)   =&gt; x
            case (Neg, Neg) =&gt; Neg
            case (Zer, Zer) =&gt; Zer
            case (Pos, Pos) =&gt; Pos
            case _          =&gt; Top
        }
}

instance MeetLattice[Sign] {
    pub def greatestLowerBound(x: Sign, y: Sign): Sign =
        match (x, y) {
            case (Top, _)   =&gt; y
            case (_, Top)   =&gt; x
            case (Neg, Neg) =&gt; Neg
            case (Zer, Zer) =&gt; Zer
            case (Pos, Pos) =&gt; Pos
            case _          =&gt; Bot
        }
}
</code></pre>
<p>With all of these definitions we are ready to write
Datalog constraints with lattice semantics.
But before we proceed, let us also write a single
monotone function:</p>
<pre><code class="language-flix">def sum(x: Sign, y: Sign): Sign = match (x, y) {
    case (Bot, _)   =&gt; Bot
    case (_, Bot)   =&gt; Bot
    case (Neg, Zer) =&gt; Neg
    case (Zer, Neg) =&gt; Neg
    case (Zer, Zer) =&gt; Zer
    case (Zer, Pos) =&gt; Pos
    case (Pos, Zer) =&gt; Pos
    case (Pos, Pos) =&gt; Pos
    case _          =&gt; Top
}
</code></pre>
<p>We can now finally put everything to use:</p>
<pre><code class="language-flix">pub def main(): Unit \ IO =
    let p = #{
        LocalVar("x"; Pos).
        LocalVar("y"; Zer).
        LocalVar("z"; Neg).
        AddStm("r1", "x", "y").
        AddStm("r2", "x", "y").
        AddStm("r2", "y", "z").
        LocalVar(r; sum(v1, v2)) :-
            AddStm(r, x, y), LocalVar(x; v1), LocalVar(y; v2).
    };
    query p select (r, v) from LocalVar(r; v) |&gt; println
</code></pre>
<p>Note the careful use of <code>;</code> to designate lattice
semantics.</p>
<h2 id="using-lattice-semantics-to-compute-shortest-paths"><a class="header" href="#using-lattice-semantics-to-compute-shortest-paths">Using Lattice Semantics to Compute Shortest Paths</a></h2>
<p>We can also use lattice semantics to compute shortest paths.</p>
<p>The key is to define our own new data type <code>D</code> which is simple an <code>Int32</code> with
forms a lattice with the reverse order of the integers (e.g. the smallest
element is <code>Int32.maxValue()</code>).</p>
<pre><code class="language-flix">use D.D;

pub enum D with Eq, Order, ToString {
    case D(Int32)
}

instance PartialOrder[D] {
    pub def lessEqual(x: D, y: D): Bool =
        let D(n1) = x;
        let D(n2) = y;
        n1 &gt;= n2        // Note: Order reversed.
}

instance LowerBound[D] {
    // Note: Because the order is reversed, the largest value is the smallest.
    pub def minValue(): D = D(Int32.maxValue())
}

instance UpperBound[D] {
    // Note: Because the order is reversed, the smallest value is the largest.
    pub def maxValue(): D = D(Int32.minValue())
}

instance JoinLattice[D] {
    pub def leastUpperBound(x: D, y: D): D =
        let D(n1) = x;
        let D(n2) = y;
        D(Int32.min(n1, n2))        // Note: Order reversed.
}

instance MeetLattice[D] {
    pub def greatestLowerBound(x: D, y: D): D =
        let D(n1) = x;
        let D(n2) = y;
        D(Int32.max(n1, n2))        // Note: Order reversed.
}

def shortestPath(g: Set[(t, Int32, t)], o: t): Map[t, D] with Order[t] =
    let db = inject g into Edge/3;
    let pr = #{
        Dist(o; D(0)).
        Dist(y; add(d1 , D(d2))) :- Dist(x; d1), Edge(x, d2, y).
    };
    query db, pr select (x , d) from Dist(x; d) |&gt; Vector.toMap

def add(x: D, y: D): D =
    let D(n1) = x;
    let D(n2) = y;
    D(n1 + n2)

def main(): Unit \ IO =
    let g = Set#{
        ("Aarhus", 200, "Flensburg"),
        ("Flensburg", 150, "Hamburg")
    };
    println(shortestPath(g, "Aarhus"))

</code></pre>
<p>Flix actually comes with a type like <code>D</code> built-in. It’s called <code>Down</code> and simply
reverses the order on the underlying type. We can use it and write the program
as:</p>
<pre><code class="language-flix">use Down.Down;

def shortestPaths(g: Set[(t, Int32, t)], o: t): Map[t, Down[Int32]] with Order[t] =
    let db = inject g into Edge/3;
    let pr = #{
        Dist(o; Down(0)).
        Dist(y; add(d1 , Down(d2))) :- Dist(x; d1), Edge(x, d2, y).
    };
    query db, pr select (x , d) from Dist(x; d) |&gt; Vector.toMap

def add(x: Down[Int32], y: Down[Int32]): Down[Int32] =
    let Down(n1) = x;
    let Down(n2) = y;
    Down(n1 + n2)

def main(): Unit \ IO =
    let g = Set#{
        ("Aarhus", 200, "Flensburg"),
        ("Flensburg", 150, "Hamburg")
    };
    println(shortestPaths(g, "Aarhus"))

</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="everyday-programming"><a class="header" href="#everyday-programming">Everyday Programming</a></h1>
<p>In this chapter we cover some everyday programming features:</p>
<ul>
<li>The signature of the <code>main</code> function.</li>
<li>How to print to standard out and standard error.</li>
<li>How to use string interpolation.</li>
<li>How to use anonymous and named holes for incomplete programs.</li>
<li>How to use type ascriptions to explicitly provide some types to the compiler.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-main-function"><a class="header" href="#the-main-function">The Main Function</a></h1>
<p>The entry point of any Flix program is the <code>main</code> function which <em>must</em> have the
signature:</p>
<pre><code class="language-flix">def main(): Unit \ IO
</code></pre>
<p>That is, the <code>main</code> function:</p>
<ol>
<li>must return <code>Unit</code>, and</li>
<li>must be marked as effectful (i.e. have the effect annotation <code>\ IO</code>).</li>
</ol>
<p>The signature of <code>main</code> does not specify any arguments, but the command line
arguments passed to the program can be accessed by calling
<code>Environment.getArgs()</code>:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    let args = Environment.getArgs();
    ...
</code></pre>
<p>Flix requires <code>main</code> to have the <code>IO</code> effect. If main was pure there would be no
reason to run the program. Typically the effectful requirement is satisfied
because <code>main</code> prints to the console or has another side-effect.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="printing-to-standard-out"><a class="header" href="#printing-to-standard-out">Printing to Standard Out</a></h1>
<p>The Flix Prelude defines the <code>println</code> function which prints to standard out.
For example:</p>
<pre><code class="language-flix">println("Hello World")
</code></pre>
<p>The <code>println</code> function can print any value whose type implements the <code>ToString</code>
trait and consequently can be converted to a <code>String</code>. For example:</p>
<pre><code class="language-flix">let o = Some(123);
let l = 1 :: 2 :: 3 :: Nil;
println(o);
println(l)
</code></pre>
<p>The <code>println</code> function is rightfully effectful, hence it cannot be called from a
pure function. To debug a pure function, use the builtin <a href="#debugging">debugging
facilities</a>.</p>
<h2 id="the-console-module"><a class="header" href="#the-console-module">The Console Module</a></h2>
<p>The <code>Console</code> module defines additional functions for reading from or writing to
the terminal:</p>
<pre><code class="language-flix">mod Console {
    def print(x: a): Unit \ IO with ToString[a]
    def println(x: a): Unit \ IO with ToString[a]
    def readLine(): Result[String, String] \ IO Impure
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h1>
<p>Flix strings support interpolation. Inside a string, the form <code>"${e}"</code> evaluates
<code>e</code> to a value and converts it to a string using the <code>ToString</code> trait. For
example:</p>
<pre><code class="language-flix">let fstName = "Lucky";
let lstName = "Luke";
"Hello Mr. ${lstName}. Do you feel ${fstName}, punk?"
</code></pre>
<p>String interpolation works for any type that implements a <code>ToString</code> instance.
For example:</p>
<pre><code class="language-flix">let i = 123;
let o = Some(123);
let l = 1 :: 2 :: 3 :: Nil;
"i = ${i}, o = ${o}, l = ${l}"
</code></pre>
<p>String interpolations may contain arbitrary expressions. For example:</p>
<pre><code class="language-flix">let x = 1;
let y = 2;
"${x + y + 1}"
</code></pre>
<p>String interpolation is the preferred way to concatenate two strings:</p>
<pre><code class="language-flix">let x = "Hello";
let y = "World";
"${x}${y}" // equivalent to x + y
</code></pre>
<p>String interpolation is the preferred way to convert a value to a string:</p>
<pre><code class="language-flix">let o = Some(123);
"${o}"
</code></pre>
<p>which is equivalent to an explicit use of the <code>toString</code> function from the
<code>ToString</code> trait:</p>
<pre><code class="language-flix">ToString.toString(o)
</code></pre>
<p>String interpolators may nest, but this is discouraged.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tail-recursion"><a class="header" href="#tail-recursion">Tail Recursion</a></h1>
<p>In Flix, and in functional programming in general, iteration is expressed
through <a href="https://en.wikipedia.org/wiki/Recursion_(computer_science)">recursion</a>.</p>
<p>For example, if we want to determine if a list contains an element, we can write
a recursive function:</p>
<pre><code class="language-flix">def memberOf(x: a, l: List[a]): Bool with Eq[a] = 
    match l {
        case Nil     =&gt; false
        case y :: ys =&gt; if (x == y) true else memberOf(x, ys)
    }
</code></pre>
<p>The <code>memberOf</code> function pattern matches on the list <code>l</code>. If it is empty then it
returns <code>false</code>. Otherwise, we have an element <code>y</code> and the rest of the list is
<code>ys</code>. If <code>x == y</code> then we have found the element and we return <code>true</code>. Otherwise
we <em>recurse</em> on the rest of the list <code>ys</code>.</p>
<p>The recursive call to <code>memberOf</code> is in <em>tail position</em>, i.e. it is the last
thing to happen in the <code>memberOf</code> function. This has two important benefits: (a)
the Flix compiler is able to rewrite <code>memberOf</code> to use an ordinary loop (which
is more efficient than a function call) and more importantly (b) a call to
<code>memberOf</code> <em>cannot</em> overflow the stack, because the call stack never increases
in height.</p>
<blockquote>
<p><strong>Tip</strong>: Flix has support for <a href="https://en.wikipedia.org/wiki/Tail_call">full tail
call</a> elimination which means that
recursive calls in tail position never increase the stack height and hence
cannot cause the stack to overflow!</p>
</blockquote>
<p>We <em>remark</em> that Flix has <em><strong>full</strong></em> tail call elimination, not just tail call
optimization. This means that the following program compiles and runs
successfully:</p>
<pre><code class="language-flix">def isOdd(n: Int32): Bool =
    if (n == 0) false else isEvn(n - 1)

def isEvn(n: Int32): Bool =
    if (n == 0) true else isOdd(n - 1)

def main(): Unit \ IO =
    isOdd(12345) |&gt; println
</code></pre>
<p>which is not the case in many other programming languages.</p>
<h2 id="non-tail-calls-and-stackoverflows"><a class="header" href="#non-tail-calls-and-stackoverflows">Non-Tail Calls and StackOverflows</a></h2>
<p>While the Flix compiler <em>guarantees</em> that tail calls cannot overflow the stack,
the same is not true for function calls in non-tail positions.</p>
<p>For example, the following implementation of the <a href="https://en.wikipedia.org/wiki/Factorial">factorial
function</a> overflows the call stack:</p>
<pre><code class="language-flix">def factorial(n: Int32): Int32 = match n {
    case 0 =&gt; 1
    case _ =&gt; n * factorial(n - 1)
}
</code></pre>
<p>as this program shows:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    println(factorial(1_000_000))
</code></pre>
<p>which when compiled and run produces:</p>
<pre><code>java : Exception in thread "main" java.lang.StackOverflowError
	at Cont%Int32.unwind(Cont%Int32)
	at Def%factorial.invoke(Unknown Source)
	at Cont%Int32.unwind(Cont%Int32)
	at Def%factorial.invoke(Unknown Source)
	at Cont%Int32.unwind(Cont%Int32)
    ... many more frames ...
</code></pre>
<p>A well-known technique is to rewrite <code>factorial</code> to use an accumulator:</p>
<pre><code class="language-flix">def factorial(n: Int32): Int32 = 
    def visit(x, acc) = match x {
        case 0 =&gt; acc
        case _ =&gt; visit(x - 1, x * acc)
    };
    visit(n, 1)
</code></pre>
<p>Here the <code>visit</code> function is tail recursive, hence it cannot overflow the stack.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anonymous-and-named-holes"><a class="header" href="#anonymous-and-named-holes">Anonymous and Named Holes</a></h1>
<p>During development, Flix encourages the use of holes for incomplete code. For
example:</p>
<pre><code class="language-flix">def sum(x: Int32, y: Int32): Int32 = ???
</code></pre>
<p>The triple question marks <code>???</code> represents an anonymous hole and can be used
wherever an expression is expected. In the above code, <code>???</code> represents a
missing function body, but it can also be used inside an expression. For
example:</p>
<pre><code class="language-flix">def length(l: List[a]): Int32 = match l {
    case Nil     =&gt; 0
    case x :: xs =&gt; ???
}
</code></pre>
<p>When a program has multiple holes, it can be useful to name them. For example:</p>
<pre><code class="language-flix">def length(l: List[a]): Int32 = match l {
    case Nil     =&gt; ?base
    case x :: xs =&gt; ?step
}
</code></pre>
<p>Flix requires that each named hole has a unique name.</p>
<h2 id="variable-holes-and-auto-completion"><a class="header" href="#variable-holes-and-auto-completion">Variable Holes and Auto-Completion</a></h2>
<p>Flix has support for a special <em>variable hole</em> which enables type-driven
auto-completion suggestions. For example, in the program:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    let s: String = "Hello World";
    let n: Int32 = s?;
    println("The length of ${s} is ${n}!")
</code></pre>
<p>If we place the cursor on <code>s?</code> and ask for auto-completion suggestions, Flix
will suggest:</p>
<ul>
<li><code>String.length(s: String): Int32</code></li>
<li><code>String.countSubstring(substr: {substr: String}, s: String): Int32</code></li>
<li><code>String.levenshtein(s: String, t: String): Int32</code></li>
<li>…</li>
</ul>
<p>since these are functions that can convert a <code>String</code> to an <code>Int32</code>.</p>
<p>As another example, in the program:</p>
<pre><code class="language-flix">def main(): Unit \ IO = 
    let l: List[Int32] = List.range(1, 10);
    let n: Int32 = l?;
    println("The value of `n` is ${n}.")
</code></pre>
<p>If we place the cursor on <code>l?</code>, Flix will suggest:</p>
<ul>
<li><code>List.product(l: List[Int32]): Int32</code></li>
<li><code>List.sum(l: List[Int32]): Int32</code></li>
<li><code>List.fold(l: List[Int32]): Int32</code></li>
<li><code>List.length(l: List[Int32]): Int32</code></li>
<li><code>List.count(f: a -&gt; Bool \ ef, l: List[a]): a \ ef</code></li>
<li>…</li>
</ul>
<p>since these are functions that can convert a <code>List[Int32]</code> to an <code>Int32</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-ascriptions"><a class="header" href="#type-ascriptions">Type Ascriptions</a></h1>
<p>While Flix supports local type inference, it can sometimes be useful to annotate
an expression or a let-binding with its type. We call such annotations <em>type
ascriptions</em>. A type ascription cannot change the type of an expression nor can
it be used to violate type safety.</p>
<p>A type ascription can be placed after an expression:</p>
<pre><code class="language-flix">(("Hello" :: "World" :: Nil) : List[String])
</code></pre>
<p>but it must be wrapped in parentheses to disambiguate it from other expressions.</p>
<p>It can also be placed on a let-binding without parentheses:</p>
<pre><code class="language-flix">let l: List[String] = "Hello" :: "World" :: Nil
</code></pre>
<h2 id="kind-ascriptions"><a class="header" href="#kind-ascriptions">Kind Ascriptions</a></h2>
<p>Flix also supports kind ascriptions. Where a type ascription specifies the
<em>type</em> of an <em>expression</em>, a kind ascription specifies the <em>kind</em> of a <em>type</em>.</p>
<p>We can use kind ascriptions on type parameters. For example:</p>
<pre><code class="language-flix">def fst1[a: Type, b: Type](p: (a, b)): a = let (x, _) = p; x
</code></pre>
<p>Here we have specified that the <em>kind</em> of the two type parameters <code>a</code> and <code>b</code> is
<code>Type</code>. We will typically never have to specify such kinds since they can
be inferred.</p>
<p>We can also provide kind ascriptions on algebraic data types:</p>
<pre><code class="language-flix">enum A[t: Type] {
    case A(t, t)
}
</code></pre>
<p>and on traits:</p>
<pre><code class="language-flix">trait MyTrait[t: Type] {
    // ...
}
</code></pre>
<p>We typically only use kind ascriptions for <a href="#higher-kinded-types">higher-kinded
types</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="redundancy"><a class="header" href="#redundancy">Redundancy</a></h1>
<p>The Flix compiler aggressively rejects programs that contain unused elements.
The idea is to help programmers avoid subtle bugs[^1]. While this can take some
time getting used to, we believe the trade-off is worth it.</p>
<p>Specifically, the Flix compiler will ensure that a program does not have:</p>
<ul>
<li><a href="#unused-local-variables">Unused local variables</a>: local variables that are declared, but never used.</li>
<li><a href="#shadowed-local-variables">Shadowed local variables</a>: local variables that shadow other local variables.</li>
<li><a href="#useless-expressions">Useless expressions</a>: pure expressions whose values are discarded.</li>
<li><a href="#must-use-values">Must use values</a>: expressions whose values are unused but their type is marked as <code>@MustUse</code>.</li>
</ul>
<h2 id="unused-local-variables"><a class="header" href="#unused-local-variables">Unused Local Variables</a></h2>
<p>Flix rejects programs with unused variables.</p>
<p>For example, the following program is rejected:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    let x = 123;
    let y = 456;
    println("The sum is ${x + x}")
</code></pre>
<p>with the message:</p>
<pre><code>❌ -- Redundancy Error -------------------------------------------------- Main.flix

&gt;&gt; Unused local variable 'y'. The variable is not referenced within its scope.

3 |     let y = 456;
            ^
            unused local variable.
</code></pre>
<p>Unused local variables can be prefixed by an underscore <code>_</code> to suppress the error.
For example, if we replace <code>y</code> by <code>_y</code> the above program compiles:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    let x = 123;
    let _y = 456; // OK
    println("The sum is ${x + x}")
</code></pre>
<h2 id="shadowed-local-variables"><a class="header" href="#shadowed-local-variables">Shadowed Local Variables</a></h2>
<p>Flix rejects programs with shadowed variables.</p>
<p>For example, the following program is rejected:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    let x = 123;
    let x = 456;
    println("The value of x is ${x}.")
</code></pre>
<p>with the message:</p>
<pre><code>❌ -- Redundancy Error -------------------------------------------------- Main.flix

&gt;&gt; Shadowed variable 'x'.

3 |     let x = 456;
            ^
            shadowing variable.

The shadowed variable was declared here:

2 |     let x = 123;
            ^
            shadowed variable.
</code></pre>
<h2 id="useless-expressions"><a class="header" href="#useless-expressions">Useless Expressions</a></h2>
<p>Flix rejects programs with <em>pure</em> expressions whose results are discarded.</p>
<p>For example, the following program is rejected:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    123 + 456;
    println("Hello World!")
</code></pre>
<p>with the message:</p>
<pre><code>❌ -- Redundancy Error -------------------------------------------------- Main.flix

&gt;&gt; Useless expression: It has no side-effect(s) and its result is discarded.

2 |     123 + 456;
        ^^^^^^^^^
        useless expression.

The expression has type 'Int32'
</code></pre>
<p>An expression that has no side-effect and whose result is unused is suspicious,
since it could just be removed from the program without changing its meaning.</p>
<h2 id="must-use-values"><a class="header" href="#must-use-values">Must Use Values</a></h2>
<p>Flix rejects programs with expressions whose values are discarded but where
their type is marked with the <code>@MustUse</code> annotation. Function types, and the
<code>Result</code> and <code>Validation</code> types from the Flix Standard Library are marked as
<code>@MustUse</code>.</p>
<p>For example, the following program is rejected:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    File.creationTime("foo.txt");
    println("Hello World!")
</code></pre>
<p>with the message:</p>
<pre><code>❌ -- Redundancy Error -------------------------------------------------- Main.flix

&gt;&gt; Unused value but its type is marked as @MustUse.

2 |     File.creationTime("foo.txt");
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        unused value.

The expression has type 'Result[String, Int64]'
</code></pre>
<p>Even though <code>File.creationTime</code> has a side-effect, we should probably be using the result <code>Result[String, Int64]</code>.
At least to ensure that the operation was successful.</p>
<p>If the result of an impure expression is truly not needed, then the <code>discard</code> expression can be used:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    discard File.creationTime("foo.txt");
    println("Hello World!")
</code></pre>
<p>which permits a <code>@MustUse</code> value to be thrown away as long as the expression is non-pure.</p>
<p>[^1] See e.g. <a href="https://dl.acm.org/doi/abs/10.1145/605466.605475">Using Redundancies to Find Errors</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>When debugging, it is often helpful to output the value of an expression or
variable.</p>
<p>We might try something like:</p>
<pre><code class="language-flix">def sum(x: Int32, y: Int32): Int32 =
    let result = x + y;
    println("The sum of ${x} and ${y} is ${result}");
    result
</code></pre>
<p>Unfortunately this does not work:</p>
<pre><code>❌ -- Type Error -------------------------------------------------- Main.flix

&gt;&gt; Unable to unify the effect formulas: 'IO' and 'Pure'.

1 |&gt; def sum(x: Int32, y: Int32): Int32 =
2 |&gt;     let result = x + y;
3 |&gt;     println("The sum of ${x} and ${y} is ${result}");
4 |&gt;     result
</code></pre>
<p>The problem is that <code>println</code> has the <code>IO</code>. Hence, we cannot use it to for
print debugging inside pure functions. We could make our <code>sum</code> function have
the <code>IO</code> effect, but that is rarely what we want. Instead, Flix has a
built-in debugging facility that allows us to do print-line debugging.</p>
<h2 id="the-debugdprintln-function"><a class="header" href="#the-debugdprintln-function">The <code>Debug.dprintln</code> Function</a></h2>
<p>Instead, we can use the <code>Debug.dprintln</code> function and write:</p>
<pre><code class="language-flix">use Debug.dprintln;

def sum(x: Int32, y: Int32): Int32 =
    let result = x + y;
    dprintln("The sum of ${x} and ${y} is ${result}");
    result
</code></pre>
<p>Inside the <code>sum</code> function, the <code>dprintln</code> has the effect <code>Debug</code>, but due to
its special nature, the <code>Debug</code> effect “disappears” once we exit the function,
i.e. it is not part of its type and effect signature.</p>
<h2 id="debugging-with-source-locations"><a class="header" href="#debugging-with-source-locations">Debugging with Source Locations</a></h2>
<p>We can use the special <em>debug string interpolator</em> to add source locations
to our print statements:</p>
<pre><code class="language-flix">use Debug.dprintln;

def sum(x: Int32, y: Int32): Int32 =
    let result = x + y;
    dprintln(d"The sum of ${x} and ${y} is ${result}");
    result
</code></pre>
<blockquote>
<p>A longer introduction to <code>dprintln</code> is available in the
blog post <a href="https://blog.flix.dev/blog/effect-systems-vs-print-debugging/">Effect Systems vs Print Debugging: A Pragmatic Solution</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>This chapter covers the tooling which Flix ships with, including:</p>
<ul>
<li>A fully-featured <a href="#visual-studio-code-extension">Visual Studio Code extension</a>.</li>
<li>A built-in <a href="#test-framework">test framework</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="visual-studio-code-extension"><a class="header" href="#visual-studio-code-extension">Visual Studio Code Extension</a></h1>
<p>Flix comes with <a href="https://marketplace.visualstudio.com/items?itemName=flix.flix">a fully-featured Visual Studio Code Extension</a>:</p>
<p><img src="images/vscode1.png" alt="Visual Studio Code1"></p>
<p>The Flix extension uses the real Flix compiler hence all information (e.g. error
messages) are always 1:1 with the real Flix programming language.</p>
<p>Flix also comes with an (optional) Visual Studio Code color theme called “Flixify Dark”.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>
<p><strong>Semantic Syntax Highlighting</strong></p>
<ul>
<li>Code highlighting for *.flix files. This work best with the <a href="https://marketplace.visualstudio.com/items?itemName=flix.flixify-dark">official vscode theme</a>.</li>
</ul>
</li>
<li>
<p><strong>Diagnostics</strong></p>
<ul>
<li>Compiler error messages.</li>
</ul>
</li>
<li>
<p><strong>Auto-complete</strong></p>
<ul>
<li>Auto-complete as you type.</li>
<li>Auto-completion is context aware.</li>
<li>Type-directed completion of program holes.</li>
</ul>
</li>
<li>
<p><strong>Snippets</strong></p>
<ul>
<li>Auto-complete common code constructs.</li>
</ul>
</li>
<li>
<p><strong>Inlay Hints</strong></p>
<ul>
<li>Shows inline type information.</li>
</ul>
</li>
<li>
<p><strong>Type and Effect Hovers</strong></p>
<ul>
<li>Hover over any expression to see its type and effect.</li>
<li>Hover over any local variable or formal parameter to see its type.</li>
<li>Hover over any function to see its type signature and documentation.</li>
</ul>
</li>
<li>
<p><strong>Jump to Definition</strong></p>
<ul>
<li>Jump to the definition of any function.</li>
<li>Jump to the definition of any local variable or formal parameter.</li>
<li>Jump to the definition of any enum case.</li>
</ul>
</li>
<li>
<p><strong>Find References</strong></p>
<ul>
<li>Find all references to a function.</li>
<li>Find all references to a local variable or formal parameter.</li>
<li>Find all references to an enum case.</li>
<li>Find all implementations of a trait.</li>
</ul>
</li>
<li>
<p><strong>Symbols</strong></p>
<ul>
<li>List all document symbols.</li>
<li>List all workspace symbols.</li>
</ul>
</li>
<li>
<p><strong>Rename</strong></p>
<ul>
<li>Rename local variables or formal parameters.</li>
<li>Rename functions.</li>
</ul>
</li>
<li>
<p><strong>Code Lenses</strong></p>
<ul>
<li>Run <code>main</code> from within the editor.</li>
<li>Run tests from within the editor.</li>
</ul>
</li>
<li>
<p><strong>Highlight</strong></p>
<ul>
<li>Highlights semantically related symbols.</li>
</ul>
</li>
<li>
<p><strong>Semantic Tokens</strong></p>
<ul>
<li>Additional code highlighting hints provided by the compiler.</li>
</ul>
</li>
</ul>
<h2 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h2>
<ul>
<li>
<p>There is a known issue with PowerShell and using file names that contain
special characters. We recommend that Flix source files are given only ASCII
names.</p>
</li>
<li>
<p>The extension assumes that you are working in “Workspace Mode”, i.e. you must
have a folder open which contains your Flix source code.</p>
</li>
<li>
<p>Upon startup, the Flix compiler has to load the entire Flix standard library
into its caches which takes a few seconds.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="test-framework"><a class="header" href="#test-framework">Test Framework</a></h1>
<p>Flix comes with a built-in test framework. A test is a Flix function marked with
the <code>@Test</code> annotation. A test function must take no arguments and return
<code>Unit</code>.</p>
<p>The <code>Assert</code> module provides assertion functions for testing. Here are the most commonly used:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Assert.assertEq(expected = value, actual)</code></td><td>Assert equality between values</td></tr>
<tr><td><code>Assert.assertNeq(unexpected = value, actual)</code></td><td>Assert inequality between values</td></tr>
<tr><td><code>Assert.assertTrue(cond)</code></td><td>Assert condition is true</td></tr>
<tr><td><code>Assert.assertFalse(cond)</code></td><td>Assert condition is false</td></tr>
<tr><td><code>Assert.assertSome(opt)</code></td><td>Assert Option is Some</td></tr>
<tr><td><code>Assert.assertNone(opt)</code></td><td>Assert Option is None</td></tr>
<tr><td><code>Assert.assertOk(res)</code></td><td>Assert Result is Ok</td></tr>
<tr><td><code>Assert.assertErr(res)</code></td><td>Assert Result is Err</td></tr>
<tr><td><code>Assert.assertEmpty(coll)</code></td><td>Assert collection is empty</td></tr>
<tr><td><code>Assert.assertMemberOf(x, coll)</code></td><td>Assert element is in collection</td></tr>
<tr><td><code>Assert.fail(msg)</code></td><td>Unconditionally fail with message</td></tr>
<tr><td><code>Assert.success(msg)</code></td><td>Unconditionally succeed with message</td></tr>
</tbody>
</table>
</div>
<p>The <code>assertEq</code> and <code>assertNeq</code> functions require a labelled argument <code>expected</code> / <code>unexpected</code>.</p>
<p>Here is an example:</p>
<pre><code class="language-flix">use Assert.{assertEq, assertTrue, assertFalse, assertOk, assertErr}

def add(x: Int32, y: Int32): Int32 = x + y

def isEven(x: Int32): Bool = Int32.modulo(x, 2) == 0

def safeDivide(x: Int32, y: Int32): Result[String, Int32] =
    if (y == 0) Err("Division by zero") else Ok(x / y)

@Test
def testAdd01(): Unit \ Assert =
    assertEq(expected = 5, add(2, 3))

@Test
def testIsEven01(): Unit \ Assert =
    assertTrue(isEven(4))

@Test
def testIsEven02(): Unit \ Assert =
    assertFalse(isEven(3))

@Test
def testSafeDivide01(): Unit \ Assert =
    assertOk(safeDivide(10, 2))

@Test
def testSafeDivide02(): Unit \ Assert =
    assertErr(safeDivide(10, 0))
</code></pre>
<p>Running the tests (e.g. with <code>flix test</code>) yields:</p>
<pre><code>Running 5 tests...

   PASS  testAdd01 1,4ms
   PASS  testIsEven01 312,5us
   PASS  testIsEven02 229,8us
   PASS  testSafeDivide01 366,0us
   PASS  testSafeDivide02 299,7us

Passed: 5, Failed: 0. Skipped: 0. Elapsed: 3,8ms.
</code></pre>
<h2 id="assertions-with-custom-messages"><a class="header" href="#assertions-with-custom-messages">Assertions with Custom Messages</a></h2>
<p>Most assertions have <code>WithMsg</code> variants for custom error messages.</p>
<pre><code class="language-flix">use Assert.{assertEqWithMsg, assertTrueWithMsg, assertFalseWithMsg}

@Test
def testAdd01(): Unit \ Assert =
    assertEqWithMsg(expected = 5, add(2, 3), "addition should work")

@Test
def testIsEven01(): Unit \ Assert =
    assertTrueWithMsg(isEven(4), "4 should be even")

@Test
def testIsEven02(): Unit \ Assert =
    assertFalseWithMsg(isEven(3), "3 should be odd")
</code></pre>
<h2 id="test-function-signatures"><a class="header" href="#test-function-signatures"><code>@Test</code> Function Signatures</a></h2>
<p>A function marked with <code>@Test</code> must have one of the following signatures:</p>
<pre><code class="language-flix">@Test
def test01(): Unit = ...
def test02(): Unit \ Assert = ...
def test03(): Unit \ Assert + IO = ...
</code></pre>
<p>In addition, a <code>@Test</code> function may use any algebraic effect for which there is
a <code>@DefaultHandler</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="build-and-package-management"><a class="header" href="#build-and-package-management">Build and Package Management</a></h1>
<p>Flix comes with a build system and package manager. The build system makes it
simple to compile a Flix program to a collection of Java classes and to build a
fat JAR. The package manager makes it possible to create Flix packages, publish
them on GitHub, and depend on them via a manifest file. The package manager also
makes it possible to depend on Java JAR-artifacts published on Maven.</p>
<p>The Flix build system supports the following commands:</p>
<ul>
<li><code>init</code>: creates a new Flix project in the current directory.</li>
<li><code>check</code>: checks the current project for compiler errors.</li>
<li><code>build</code>: builds the current project (i.e. emits Java bytecode).</li>
<li><code>build-jar</code>: builds a jar-file from the current project.</li>
<li><code>build-fatjar</code>: builds a jar-file with all dependencies bundled.</li>
<li><code>build-pkg</code>: builds a fpkg-file from the current project.</li>
<li><code>run</code>: runs main in current project.</li>
<li><code>test</code>: runs all tests in the current project.</li>
</ul>
<p>All commands can be executed from the command line, from the REPL, and from
VSCode.</p>
<p>All commands, except <code>build-pkg</code> work without a manifest file. To build,
package, and publish a Flix project, a <code>flix.toml</code> manifest is required. The
<code>init</code> command will create an empty skeleton <code>flix.toml</code> manifest, if not
already present.</p>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>Flix scans for source files in the paths <code>*.flix</code>, <code>src/**/*.flix,</code>, and
<code>test/**/*.flix</code>.</p>
<p>Flix scans for Flix packages and JARs in the paths <code>lib/**/*.fpkg</code> and
<code>lib/**/*.jar</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="build-management"><a class="header" href="#build-management">Build Management</a></h1>
<p>We now discuss the build commands. Each command can be executed from the command
line, from the REPL, and from VSCode.</p>
<h2 id="creating-a-new-project"><a class="header" href="#creating-a-new-project">Creating a New Project</a></h2>
<p>We can create a new project, inside a directory, with the <code>init</code> command.</p>
<p>This will create the default Flix project structure:</p>
<pre><code>.
├── flix.toml
├── LICENSE.md
├── README.md
├── src
│   └── Main.flix
└── test
    └── TestMain.flix

2 directories, 6 files
</code></pre>
<p>The most relevant files are <code>flix.toml</code>, <code>src/Main.flix</code> and
<code>test/TestMain.flix</code>.</p>
<p>The <code>flix.toml</code> manifest file is discussed in the next section.</p>
<blockquote>
<p><strong>Tip:</strong> The <code>init</code> command is safe to use; it will only create files that do
not already exist.</p>
</blockquote>
<h2 id="checking-a-project"><a class="header" href="#checking-a-project">Checking a Project</a></h2>
<p>We can check a project for compiler errors with the <code>check</code> command. During
development, the <code>check</code> command is preferable to the <code>build</code> command because it
skips code generation (and hence is significantly faster).</p>
<h2 id="building-a-project"><a class="header" href="#building-a-project">Building a Project</a></h2>
<p>We can compile a project with the <code>build</code> command. Running the <code>build</code> command
will compile the entire project and emit bytecode, i.e. compiled Java classes,
to the <code>build</code> directory.</p>
<p>Flix has no <code>clean</code> command. Deleting the <code>build</code> directory serves the same
purpose.</p>
<h2 id="building-a-jar-file"><a class="header" href="#building-a-jar-file">Building a JAR-file</a></h2>
<p>We can compile a project to a JAR-file with the <code>build-jar</code> command. The
<code>build-jar</code> command emits a <code>artifact/project.jar</code> file. If there is <code>main</code>
function, we can run it:</p>
<pre><code class="language-bash">$ java -jar artifact/project.jar
</code></pre>
<p>The JAR-file contains all class files from the <code>build</code> directory. The built JAR
may depend on external JARs, if the project, or one of its dependencies, depends
on JAR-files.</p>
<blockquote>
<p><strong>Note:</strong> <code>build-jar</code> automatically invokes the <code>build</code> command.</p>
</blockquote>
<h2 id="building-a-fat-jar-file-bundling-all-dependencies"><a class="header" href="#building-a-fat-jar-file-bundling-all-dependencies">Building a fat JAR-file (bundling all dependencies)</a></h2>
<p>We can compile a project to a single standalone fat JAR-file with the
<code>build-fatjar</code> command. The <code>build-fatjar</code> command emits a
<code>artifact/project.jar</code> file where <em>all</em> dependencies — both Flix and Maven — are
bundled into one single JAR-file.</p>
<p>The JAR-file contains all class files from the <code>build</code> directory together with
all class files extract from all Maven dependencies found in the <code>lib</code>
directory.</p>
<blockquote>
<p><strong>Note:</strong> <code>build-fatjar</code> automatically invokes the <code>build</code> command.</p>
</blockquote>
<h2 id="building-a-flix-project"><a class="header" href="#building-a-flix-project">Building a Flix Project</a></h2>
<p>We can bundle a project into a Flix package file (fpkg) with the <code>build-pkg</code>
command. Running the <code>build-pkg</code> command emits a <code>artifact/project.fpkg</code> file.</p>
<p>A Flix package file (fpkg) is essentially zip-file of the project source code. A
Flix package, together with its <code>flix.toml</code> manifest, can be published on
GitHub.</p>
<h2 id="running-a-project"><a class="header" href="#running-a-project">Running a Project</a></h2>
<p>We do not have to build a JAR-file to run a project, we can simply use the <code>run</code>
command which will compile and run the main entry point.</p>
<h2 id="testing-a-project"><a class="header" href="#testing-a-project">Testing a Project</a></h2>
<p>We can use the <code>test</code> command to run all test cases in a project. Flix will
collect all functions marked with <code>@Test</code>, execute them, and print a summary of
the results:</p>
<pre><code>Running 1 tests...

   PASS  test01 1,1ms

Passed: 1, Failed: 0. Skipped: 0. Elapsed: 3,9ms.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="package-management"><a class="header" href="#package-management">Package Management</a></h1>
<p>Every non-trivial Flix project should have a <code>flix.toml</code> manifest. The manifest
contains information about the project and its dependencies.</p>
<p>A minimal manifest is of the form:</p>
<pre><code class="language-toml">[package]
name        = "hello-library"
description = "A simple library"
version     = "0.1.0"
flix        = "0.35.0"
license     = "Apache-2.0"
authors     = ["John Doe &lt;john@example.com&gt;"]
</code></pre>
<blockquote>
<p><strong>Note:</strong> The <code>flix</code> field is not yet used, but it will be used in the future.</p>
</blockquote>
<h2 id="adding-flix-dependencies"><a class="header" href="#adding-flix-dependencies">Adding Flix Dependencies</a></h2>
<p>We can add dependencies on other Flix packages to the manifest:</p>
<pre><code class="language-toml">[dependencies]
"github:flix/museum"              = "1.4.0"
"github:magnus-madsen/helloworld" = "1.3.0"
</code></pre>
<blockquote>
<p><strong>Note:</strong> Flix requires version numbers to follow SemVer.</p>
</blockquote>
<h2 id="adding-maven-dependencies"><a class="header" href="#adding-maven-dependencies">Adding Maven Dependencies</a></h2>
<p>We can also add dependencies on Maven packages to the manifest:</p>
<pre><code class="language-toml">[mvn-dependencies]
"org.junit.jupiter:junit-jupiter-api" = "5.9.2"
</code></pre>
<h2 id="understanding-dependency-resolution"><a class="header" href="#understanding-dependency-resolution">Understanding Dependency Resolution</a></h2>
<p>Flix dependency resolution works as follows:</p>
<ol>
<li>Flix reads <code>flix.toml</code> and computes the transitive set of Flix package
dependencies.</li>
<li>Flix downloads all of these Flix packages.</li>
<li>Flix inspects each package for its Maven dependencies and downloads these.</li>
</ol>
<p>We illustrate with an example. Assume we have a Flix package with:</p>
<pre><code class="language-toml">[dependencies]
"github:flix/museum"              = "1.4.0"
</code></pre>
<p>Running Flix produces:</p>
<pre><code>Found `flix.toml'. Checking dependencies...
Resolving Flix dependencies...
  Downloading `flix/museum.toml` (v1.4.0)... OK.
  Downloading `flix/museum-entrance.toml` (v1.2.0)... OK.
  Downloading `flix/museum-giftshop.toml` (v1.1.0)... OK.
  Downloading `flix/museum-restaurant.toml` (v1.1.0)... OK.
  Downloading `flix/museum-clerk.toml` (v1.1.0)... OK.
  Cached `flix/museum-clerk.toml` (v1.1.0).
Downloading Flix dependencies...
  Downloading `flix/museum.fpkg` (v1.4.0)... OK.
  Downloading `flix/museum-entrance.fpkg` (v1.2.0)... OK.
  Downloading `flix/museum-giftshop.fpkg` (v1.1.0)... OK.
  Downloading `flix/museum-restaurant.fpkg` (v1.1.0)... OK.
  Downloading `flix/museum-clerk.fpkg` (v1.1.0)... OK.
  Cached `flix/museum-clerk.fpkg` (v1.1.0).
Resolving Maven dependencies...
  Adding `org.apache.commons:commons-lang3' (3.12.0).
  Running Maven dependency resolver.
Dependency resolution completed.
</code></pre>
<p>This happens because <code>flix/museum</code> has the following dependency tree:</p>
<ul>
<li><code>flix/museum</code> depends on:
<ul>
<li><code>flix/museum-entrance</code> which depends on:
<ul>
<li><code>flix/museum-clerk</code></li>
</ul>
</li>
<li><code>flix/museum-giftshop</code> which depends on:
<ul>
<li><code>flix/museum-clerk</code></li>
</ul>
</li>
<li><code>flix/museum-restaurant</code> which depends on
<ul>
<li><code>org.apache.commons:commons-lang3</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="security"><a class="header" href="#security">Security</a></h2>
<p>To reduce the risk of supply-chain attacks, every dependency has a <strong>security
context</strong> — even if you don’t set one explicitly. Security contexts control
which language features a dependency may use. Broader security contexts enable
more features but also increase the risk of supply-chain attacks.</p>
<p>The security contexts are defined as follows:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Security Context</th><th>Java Interop</th><th>Unchecked Casts</th><th>The <code>IO</code> Effect</th></tr>
</thead>
<tbody>
<tr><td><code>paranoid</code></td><td>Forbidden</td><td>Forbidden</td><td>Forbidden</td></tr>
<tr><td><code>plain</code> (default)</td><td>Forbidden</td><td>Forbidden</td><td>Allowed</td></tr>
<tr><td><code>unrestricted</code></td><td>Allowed</td><td>Allowed</td><td>Allowed</td></tr>
</tbody>
</table>
</div>
<p>You can set the security context of each dependency in the manifest like so:</p>
<pre><code class="language-toml">[dependencies]
"github:flix/museum"              = { version = "1.4.0", security = "plain" }
"github:magnus-madsen/helloworld" = { version = "1.3.0", security = "unrestricted" }
</code></pre>
<p>Security contexts are transitive: a dependency’s security context also applies
to its transitive dependencies, unless a dependency explicitly declares a lesser
security context. If multiple dependencies require the same library, the library
inherits the most restrictive security context requested.</p>
<p>The recommended approach is to <strong>not</strong> specify a security context, thus
defaulting to <code>plain</code>. It provides the best balance between flexibility and
safety. You should avoid <code>unrestricted</code> when possible, as it permits
(transitive) dependencies to do <em>anything</em>. Even building or compiling code that
includes <code>unrestricted</code> dependencies can by itself expose you to a supply-chain
attack.</p>
<p>If you are the author of a Flix library that requires effects, the best
practice is to introduce your own custom effects instead of using the <code>IO</code>
effect directly, and to split the library into two packages:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Package</th><th>Description</th><th>Security Context</th></tr>
</thead>
<tbody>
<tr><td><code>webserver-lib</code></td><td>Core functionality using effects</td><td><code>plain</code></td></tr>
<tr><td><code>webserver-lib-handlers</code></td><td>Handlers that perform Java interop/IO</td><td><code>unrestricted</code></td></tr>
</tbody>
</table>
</div>
<p>This approach provides several benefits:</p>
<ul>
<li>Most functionality remains in the trusted <code>plain</code> security context.</li>
<li>Unsafe code is isolated in <code>webserver-lib-handlers</code> for easier review.</li>
<li>Users can implement their own handlers if they don’t trust the provided ones.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="publishing-a-package-on-github"><a class="header" href="#publishing-a-package-on-github">Publishing a Package on GitHub</a></h1>
<p>Flix packages are published on GitHub.</p>
<h2 id="automatically-publishing-a-package"><a class="header" href="#automatically-publishing-a-package">Automatically Publishing a Package</a></h2>
<p>Flix can automatically package and publish artifacts on GitHub by following these steps:</p>
<ol>
<li>Check that you have a <code>flix.toml</code> manifest (if not create one with <code>init</code>).</li>
<li>Check that the version field in <code>flix.toml</code> is correct.</li>
<li>Check that the repository field in <code>flix.toml</code> is correct. (e.g. <code>repository = "github:user/repo"</code>)</li>
<li>Check that you have a GitHub token which has read and write access to
<code>Contents</code> for the relevant repository.
<ul>
<li>If not go to GitHub and navigate to <code>Settings &gt; Developer settings &gt; Personal access tokens</code> and create a new token.</li>
</ul>
</li>
<li>Run <code>check</code> and <code>test</code> to ensure that everything looks alright.</li>
<li>Run <code>release --github-token &lt;TOKEN&gt;</code>. You should see:</li>
</ol>
<pre><code class="language-shell">Found `flix.toml'. Checking dependencies...
Resolving Flix dependencies...
Downloading Flix dependencies...
Resolving Maven dependencies...
  Running Maven dependency resolver.
Downloading external jar dependencies...
Dependency resolution completed.
Release github:user/repo v1.2.3? [y/N]: y
Building project...
Publishing new release...

 Successfully released v1.2.3
 https://github.com/user/repo/releases/tag/v1.2.3
</code></pre>
<blockquote>
<p><strong>Tip:</strong> See the <a href="https://github.com/flix/museum">Museum Project</a> for an
example of a package that has been published on GitHub.</p>
</blockquote>
<blockquote>
<p><strong>Tip:</strong> Flix will read the GitHub token from the environment variable
<code>GITHUB_TOKEN</code>, if available.</p>
</blockquote>
<blockquote>
<p><strong>Tip:</strong> Flix will also read the GitHub token from the file <code>.GITHUB_TOKEN</code>,
if available.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> You cannot publish artifacts for empty GitHub repositories.</p>
</blockquote>
<blockquote>
<p><strong>Warning:</strong> Be sure to keep your token safe!</p>
</blockquote>
<h2 id="manually-publishing-a-package"><a class="header" href="#manually-publishing-a-package">Manually Publishing a Package</a></h2>
<p>A package can also be manually published by following these steps:</p>
<ol>
<li>Check that you have a <code>flix.toml</code> manifest (if not create one with <code>init</code>).</li>
<li>Check that the version field in <code>flix.toml</code> is correct.</li>
<li>Run <code>check</code> and <code>test</code> to ensure that everything looks correct.</li>
<li>Run <code>build-pkg</code>. Check that the <code>artifact</code> directory is populated.</li>
<li>Go to the repository on GitHub:
<ol>
<li>Click “Releases”.</li>
<li>Click “Draft new release”.</li>
<li>Enter a tag of the form <code>v1.2.3</code> (i.e. use SemVer).</li>
<li>Upload the <code>package.fpkg</code> and <code>flix.toml</code> from the <code>artifact</code> directory.</li>
</ol>
</li>
</ol>
<blockquote>
<p><strong>Warning:</strong> You must upload <em>both</em> the package file  (<code>foo.fpkg</code>) and the
manifest file (<code>flix.toml</code>).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="finding-outdated-packages"><a class="header" href="#finding-outdated-packages">Finding Outdated Packages</a></h1>
<p>We can use the <code>outdated</code> command to check if any Flix packages have updates
available.</p>
<p>For example, if we have the following dependency in <code>flix.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
"github:flix/museum"            = "1.0.0"
"github:flix/museum-giftshop"   = "1.0.0"
</code></pre>
<p>then we can run <code>outdated</code> command which will produce:</p>
<pre><code class="language-shell">Found `flix.toml`. Checking dependencies...
Resolving Flix dependencies...
  Cached `flix/museum.toml` (v1.0.0).
  Cached `flix/museum-giftshop.toml` (v1.0.0).  
  Cached `flix/museum-entrance.toml` (v1.0.0).  
  Cached `flix/museum-giftshop.toml` (v1.0.0).  
  Cached `flix/museum-restaurant.toml` (v1.0.0).
  Cached `flix/museum-clerk.toml` (v1.0.0).     
  Cached `flix/museum-clerk.toml` (v1.0.0).
Downloading Flix dependencies...
  Cached `flix/museum.fpkg` (v1.0.0).
  Cached `flix/museum-giftshop.fpkg` (v1.0.0).
  Cached `flix/museum-entrance.fpkg` (v1.0.0).
  Cached `flix/museum-giftshop.fpkg` (v1.0.0).
  Cached `flix/museum-restaurant.fpkg` (v1.0.0).
  Cached `flix/museum-clerk.fpkg` (v1.0.0).
  Cached `flix/museum-clerk.fpkg` (v1.0.0).
Resolving Maven dependencies...
  Running Maven dependency resolver.
Downloading external jar dependencies...
Dependency resolution completed.

package                 current    major    minor    patch
flix/museum             1.0.0               1.4.0         
flix/museum-giftshop    1.0.0               1.1.0         
</code></pre>
<p>The <code>outdated</code> command tells us that we are using two packages which have
updates available:</p>
<ul>
<li><code>flix/museum</code> can be upgraded from <code>1.0.0</code> to <code>1.4.0</code>.</li>
<li><code>flix/museum-giftshop</code> can be upgraded from <code>1.0.0</code> to <code>1.1.0</code>.</li>
</ul>
<p>If we want to upgrade a package, we must manually modify <code>flix.toml</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h1>
<p>In this chapter, we discuss some advanced features of Flix, including:</p>
<ul>
<li><a href="#checked-type-and-effect-casts">Checked Casts</a> and <a href="#unchecked-type-and-effect-casts">Unchecked Casts</a></li>
<li><a href="#bug-and-unreachable">The <code>bug!</code> and <code>unreachable!</code> functions</a></li>
<li><a href="#type-match">Type Match</a></li>
<li><a href="#purity-reflection">Purity Reflection</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="checked-type-and-effect-casts"><a class="header" href="#checked-type-and-effect-casts">Checked Type and Effect Casts</a></h1>
<p>The Flix type and effect system – by design – does not support sub-typing nor
sub-effecting. To work around these limitations, which are rare in practice,
Flix has two <em>safe</em> upcast constructs:</p>
<ul>
<li>A checked <em>type</em> cast: <code>checked_cast(exp)</code>, and</li>
<li>A checked <em>effect</em> cast <code>checked_ecast(exp)</code>.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> The <code>checked_cast</code> and <code>checked_ecast</code> expressions are guaranteed to
be <em>safe</em>. The Flix compiler will check at compile-time that every checked
cast cannot go wrong.</p>
</blockquote>
<h2 id="checked-type-casts"><a class="header" href="#checked-type-casts">Checked Type Casts</a></h2>
<p>The following program:</p>
<pre><code class="language-flix">def main(): Unit =
    let s = "Hello World";
    let o: ##java.lang.Object = s;
    ()
</code></pre>
<p>does not compile:</p>
<pre><code>❌ -- Type Error --------------------------------------------------

&gt;&gt; Expected type: 'Object' but found type: 'String'.

4 |     let o: ##java.lang.Object = s;
                                    ^
                                    expression has unexpected type.
</code></pre>
<p>because in Flix the <code>String</code> type is <em>not</em> a subtype of <code>Object</code>.</p>
<p>We can use a checked type cast to safely upcast from <code>String</code> to <code>Object</code>:</p>
<pre><code class="language-flix">def main(): Unit =
    let s = "Hello World";
    let o: ##java.lang.Object = checked_cast(s);
    ()
</code></pre>
<p>We can use the <code>checked_cast</code> construct to safely upcast any Java type to one of
its super-types:</p>
<pre><code class="language-flix">let _: ##java.lang.Object       = checked_cast("Hello World");
let _: ##java.lang.CharSequence = checked_cast("Hello World");
let _: ##java.io.Serializable   = checked_cast("Hello World");
let _: ##java.lang.Object       = checked_cast(null);
let _: ##java.lang.String       = checked_cast(null);
</code></pre>
<h2 id="checked-effect-casts"><a class="header" href="#checked-effect-casts">Checked Effect Casts</a></h2>
<p>The following program:</p>
<pre><code class="language-flix">def hof(f: Int32 -&gt; Int32 \ IO): Int32 \ IO = f(42)

def main(): Int32 \ IO =
    hof(x -&gt; x + 1)
</code></pre>
<p>does not compile:</p>
<pre><code>❌ -- Type Error --------------------------------------------------

&gt;&gt; Expected argument of type 'Int32 -&gt; Int32 \ IO', but got 'Int32 -&gt; Int32'.

4 |     hof(x -&gt; x + 1)
            ^^^^^^^^^^
            expected: 'Int32 -&gt; Int32 &amp; Impure \ IO'

The function 'hof' expects its 1st argument to be of type 'Int32 -&gt; Int32 \ IO'.

Expected: Int32 -&gt; Int32 &amp; Impure \ IO
  Actual: Int32 -&gt; Int32
</code></pre>
<p>because in Flix a <em>pure</em> function is <em>not</em> a subtype of an impure function.
Specifically, the <code>hof</code> requires a function with the <code>IO</code> effect, but we are
passing in a pure function.</p>
<p>We can use a checked effect cast to safely upcast a pure expression to an
impure expression:</p>
<pre><code class="language-flix">def main(): Int32 \ IO =
    hof(x -&gt; checked_ecast(x + 1))
</code></pre>
<p>The <code>checked_ecast</code> construct allows us to pretend that <code>x + 1</code> has the <code>IO</code> effect.</p>
<blockquote>
<p><strong>Note:</strong> In Flix – as a general rule – higher-order functions should <em>not</em>
require their function arguments to have a specific effect. Instead they
should be effect polymorphic.</p>
</blockquote>
<h2 id="function-types"><a class="header" href="#function-types">Function Types</a></h2>
<p>Neither the <code>checked_cast</code> nor the <code>checked_ecast</code> constructs work on function types.</p>
<p>For example, the following does not work:</p>
<pre><code class="language-flix">let f: Unit -&gt; ##java.lang.Object = checked_cast(() -&gt; "Hello World")
</code></pre>
<p>because it tries to cast the function type <code>Unit -&gt; String</code> to <code>Unit -&gt; Object</code>.</p>
<p>Instead, we should write:</p>
<pre><code class="language-flix">let f: Unit -&gt; ##java.lang.Object = (() -&gt; checked_cast("Hello World"))
</code></pre>
<p>because it directly casts <code>String</code> to <code>Object</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="unchecked-type-and-effect-casts"><a class="header" href="#unchecked-type-and-effect-casts">Unchecked Type and Effect Casts</a></h1>
<p>Flix also supports <em>unchecked</em> type and effect casts.</p>
<h2 id="unchecked-type-casts"><a class="header" href="#unchecked-type-casts">Unchecked Type Casts</a></h2>
<p>An <em>unchecked type cast</em> instructs the compiler that an expression has a specific type.</p>
<blockquote>
<p><strong>Warning:</strong> Type casts are very dangerous and should be used with utmost
caution!</p>
</blockquote>
<p>Flix programmers should normally never need to use an unchecked type cast.</p>
<h3 id="example-safe-cast-to-a-super-type"><a class="header" href="#example-safe-cast-to-a-super-type">Example: Safe Cast to a Super-Type</a></h3>
<p>The expression below casts a <code>String</code> to an <code>Object</code>:</p>
<pre><code class="language-flix">unchecked_cast("Hello World" as ##java.lang.Object)
</code></pre>
<p>Note: It is safer to use the <code>checked_cast</code> expression.</p>
<h3 id="example-safe-cast-from-null-to-an-object-type"><a class="header" href="#example-safe-cast-from-null-to-an-object-type">Example: Safe Cast from Null to an Object-Type</a></h3>
<p>The expression below casts the <code>null</code> value (of type <code>Null</code>) to <code>String</code>:</p>
<pre><code class="language-flix">unchecked_cast(null as ##java.lang.String)
</code></pre>
<p>Note: It is safer to use the <code>checked_cast</code> expression.</p>
<h3 id="example-unsafe-type-cast"><a class="header" href="#example-unsafe-type-cast">Example: Unsafe Type Cast</a></h3>
<p>The expression below contains an illegal cast and triggers a
<code>ClassCastException</code> at runtime:</p>
<pre><code class="language-flix">unchecked_cast((123, 456) as ##java.lang.Integer)
</code></pre>
<h2 id="effect-casts"><a class="header" href="#effect-casts">Effect Casts</a></h2>
<p>An <em>unchecked effect cast</em> instructs the compiler that an expression has a
specific effect.</p>
<blockquote>
<p><strong>Warning:</strong> Effect casts are extremely dangerous and should be used with
extreme caution!</p>
</blockquote>
<p>Flix programmers should normally never need to use an unchecked effect cast.</p>
<h3 id="example-unsafe-effect-cast"><a class="header" href="#example-unsafe-effect-cast">Example: Unsafe Effect Cast</a></h3>
<p>We can pretend an impure expression is pure:</p>
<pre><code class="language-flix">def main(): Unit =
    unchecked_cast(println("Hello World") as _ \ {})
</code></pre>
<p>Here we call <code>println</code> which has the <code>IO</code> effect and then we explicitly, and
unsafely, cast away the effect, pretending that the expression is pure.</p>
<blockquote>
<p><strong>Warning:</strong> Never cast effectful expressions to pure. You have been warned.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bug-and-unreachable"><a class="header" href="#bug-and-unreachable"><code>bug!</code> and <code>unreachable!</code></a></h1>
<p>Flix supports two special “functions”: <code>bug!</code> and
<code>unreachable!</code> that can be used to indicate when an
internal program invariant is broken and execute
should abort.
For example:</p>
<pre><code class="language-flix">match o {
    case Some(x) =&gt; ...
    case None    =&gt; bug!("The value of `o` cannot be empty.")
}
</code></pre>
<p>As another example:</p>
<pre><code class="language-flix">match k {
    case n if n == 0 =&gt; ...
    case n if n &gt;= 0 =&gt; ...
    case n if n &lt;= 0 =&gt; ...
    case n           =&gt;  unreachable!()
}
</code></pre>
<p>Use of <code>bug!</code> and <code>unreachable!</code> should be avoided
whenever possible.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="laziness"><a class="header" href="#laziness">Laziness</a></h1>
<p>Flix uses eager evaluation in most circumstances, but allows the programmer to opt-in to lazy evaluation when appropriate with the <code>lazy</code> keyword:</p>
<pre><code class="language-flix">let x: Lazy[Int32] = lazy (1 + 2);
</code></pre>
<p>The expression won’t be evaluated until it’s <em>forced</em>:</p>
<pre><code class="language-flix">let y: Int32 = force x;
</code></pre>
<blockquote>
<p><strong>Note:</strong> The <code>lazy</code> construct requires the expression it’s given to be pure.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> Forcing a lazy value that’s already been evaluated won’t evaluate it for a second time.</p>
</blockquote>
<h2 id="lazy-data-structures"><a class="header" href="#lazy-data-structures">Lazy data structures</a></h2>
<p>Laziness can be used to create lazy data structures which are evaluated as they’re used. This even allows us to create infinite data structures.</p>
<p>Here for example, is a data structure which implements an infinitely long stream of integers which increase by one each time:</p>
<pre><code class="language-flix">mod IntStream {

    enum IntStream { case SCons(Int32, Lazy[IntStream]) }

    pub def from(x: Int32): IntStream =
        IntStream.SCons(x, lazy from(x + 1))
}
</code></pre>
<p>Given this, we can implement functions such as <code>map</code> and <code>take</code>:</p>
<pre><code class="language-flix">    pub def take(n: Int32, s: IntStream): List[Int32] =
        match n {
            case 0 =&gt; Nil
            case _ =&gt; match s {
                case SCons(h, t) =&gt; h :: take(n - 1, force t)
            }
        }

    pub def map(f: Int32 -&gt; Int32, s: IntStream): IntStream =
        match s {
            case SCons(h, t) =&gt; IntStream.SCons(f(h), lazy map(f, force t))
        }
</code></pre>
<p>So, for example:</p>
<pre><code class="language-flix">IntStream.from(42) |&gt; IntStream.map(x -&gt; x + 10) |&gt; IntStream.take(10)
</code></pre>
<p>Will return:</p>
<pre><code class="language-flix">52 :: 53 :: 54 :: 55 :: 56 :: 57 :: 58 :: 59 :: 60 :: 61 :: Nil
</code></pre>
<p>Flix provides <code>DelayList</code> and <code>DelayMap</code> data structures which already implement this functionality and more:</p>
<pre><code class="language-flix">DelayList.from(42) |&gt; DelayList.map(x -&gt; x + 10) |&gt; DelayList.take(10)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-match"><a class="header" href="#type-match">Type Match</a></h1>
<p>Flix supports a type match construct that enables compile-time pattern matching
on the type of a polymorphic value.</p>
<p>For example, we can write a function that inspects the type of its argument:</p>
<pre><code class="language-flix">def inspect(x: a): String = typematch x {
    case _: Int32   =&gt; "x is an Int32"
    case _: String  =&gt; "x is a String"
    case _: _       =&gt; "x is neither an Int32 nor a String"
}

def main(): Unit \ IO = 
    println(inspect(12345));
    println(inspect("abc"));
    println(inspect(false))
</code></pre>
<p>Here the <code>inspect</code> function pattern matches on the type of the formal parameter
<code>x</code> using the <code>typematch</code> construct. For example, if the type of <code>x</code> is an
<code>Int32</code> then the function returns the string <code>"x is an Int32"</code> and so forth.</p>
<p>The <code>typematch</code> construct is eliminated at compile-time, hence there is no
runtime cost.</p>
<p>As the example shows, the <code>typematch</code> construct always requires a default case.
This is because Flix has infinitely many types, and a <code>typematch</code> cannot cover
all of them.</p>
<p>A type match can also inspect more complex types, as the following example
shows:</p>
<pre><code class="language-flix">def inspect(x: a): String = typematch x {
    case _: List[Int32]   =&gt; "x is a list of integers"
    case _: List[String]  =&gt; "x is a list of strings"
    case _: _             =&gt; "x is something else"
}

def main(): Unit \ IO = 
    println(inspect(1 :: 2 :: 3 :: Nil));
    println(inspect("abc" :: "def" :: Nil));
    println(inspect(false))
</code></pre>
<p>We can also bind values with type match, as the following example shows:</p>
<pre><code class="language-flix">def inspect(x: a): String = typematch x {
    case i: Int32   =&gt; "${i * i}"
    case s: String  =&gt; String.toUpperCase(s)
    case _: _ 		=&gt; "-"
}

def main(): Unit \ IO = 
    println(inspect(12345));
    println(inspect("abc"));
    println(inspect(false))
</code></pre>
<blockquote>
<p><strong>Warning:</strong> While type match is a powerful meta-programming construct, it
should be used sparingly and with great care.</p>
</blockquote>
<p>A typical legitimate use case for type match is when we want to work around
limitations imposed by the JVM. For example, the Flix Standard Library uses type
match to implement the <code>Array.copyOfRange</code> function as shown below:</p>
<pre><code class="language-flix">def copyOfRange(_: Region[r2], b: Int32, e: Int32, a: Array[a, r1]): ... =
typematch a {
    case arr: Array[Int16, r1] =&gt;
        import static java.util.Arrays.copyOfRange(Array[Int16, r1], Int32, Int32): ...
    ...
    case arr: Array[Int32, r1] =&gt;
        import static java.util.Arrays.copyOfRange(Array[Int32, r1], Int32, Int32): ...
    ...
    // ... additional cases ...
}
</code></pre>
<p>Here type match allows us to call the right overloaded version of
<code>java.util.Arrays.copyOfRange</code>. Thus Flix programmers can use our version of
<code>copyOfRange</code> (i.e., <code>Array.copyOfRange</code>) while underneath the hood, we always
call the most efficient Java version.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="purity-reflection"><a class="header" href="#purity-reflection">Purity Reflection</a></h1>
<blockquote>
<p><strong>Note:</strong> This is an advanced feature and should only be used by experts.</p>
</blockquote>
<p>Purity reflection enables higher-order functions to inspect the purity of their
function arguments.</p>
<p>This allows us to write functions that use <em>selective</em> lazy and/or parallel
evaluation.</p>
<p>For example, here is the implementation of <code>Set.count</code>:</p>
<pre><code class="language-flix">@ParallelWhenPure
pub def count(f: a -&gt; Bool \ ef, s: Set[a]): Int32 \ ef =
    match purityOf(f) {
        case Purity.Pure(g) =&gt;
            if (useParallelEvaluation(s))
                let h = (k, _) -&gt; g(k);
                let Set(t) = s;
                RedBlackTree.parCount(h, t)
            else
                foldLeft((b, k) -&gt; if (f(k)) b + 1 else b, 0, s)
        case Purity.Impure(g) =&gt; foldLeft((b, k) -&gt; if (g(k)) b + 1 else b, 0, s)
    }
</code></pre>
<p>Here the <code>purityOf</code> function is used to reflect on the purity of <code>f</code>:</p>
<ul>
<li>If <code>f</code> is pure then we evaluate <code>Set.count</code> in <em>parallel</em> over the elements of
the set (if the set is big enough to warrant it).</li>
<li>If <code>f</code> is effectful then we use an ordinary (single-threaded) fold.</li>
</ul>
<p>The advantage is that we get parallelism for free – <em>if</em> <code>f</code> is pure.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-level-programming"><a class="header" href="#type-level-programming">Type-Level Programming</a></h1>
<blockquote>
<p><strong>Note:</strong> This feature is experimental. Do not use in production.</p>
</blockquote>
<p>This section assumes prior familiarity with type-level programming and phantom
types.</p>
<h2 id="type-level-booleans"><a class="header" href="#type-level-booleans">Type-Level Booleans</a></h2>
<p>A unique Flix feature is its support for <em>type-level Boolean formulas</em>. This
means <code>true</code> and <code>false</code> are types, but also that formulas such as <code>x and (not y)</code> are types. A type-level Boolean formula has kind <code>Bool</code>. Two type-level
Boolean formulas are equal if the formulas are equivalent (i.e. have the same
truth tables). For example, the two types <code>true</code> and <code>x or not x</code> are <em>the same
type</em>.</p>
<p>While type-level Boolean formulas are not as expressive as general refinement
types or dependent types they support complete type inference and parametric
polymorphism. This means that they are very ergonomic to work with.</p>
<p>We can use type-level Boolean formulas to statically enforce program invariants.</p>
<p>We illustrate with a few examples:</p>
<h3 id="humans-and-vampires"><a class="header" href="#humans-and-vampires">Humans and Vampires</a></h3>
<pre><code class="language-flix">///
/// We can use a phantom type-level Boolean to model whether a person is alive
/// or is undead (i.e. a vampire).
///
enum Person[_isAlive: Bool] {
    /// A person has a name, an age, and is modelled as a record.
    case P({name = String, age = Int32})
}

///
/// We interpret the Boolean `true` is alive and the Boolean `false` as undead
/// (i.e. a vampire).
///
type alias Alive  = true
type alias Undead = false

///
/// A person who is born is alive.
///
def born(name: String): Person[Alive] =
    Person.P({name = name, age = 0})

///
/// A person who is alive and is bitten becomes a vampire.
///
/// Note that the type system enforces that an already undead (i.e. a vampire)
/// cannot be bitten again.
///
def bite(p: Person[Alive]): Person[Undead] = match p {
    /// The implementation is not important; it simply restructs the person.
    case Person.P(r) =&gt; Person.P(r)
}

///
/// Two persons can be married, but only if they are both alive or both undead.
///
/// (The church does not yet recognize human-vampire marriages.)
///
/// Note that the type system enforces that both arguments have the same type.
///
def marry(_p1: Person[isAlive], _p2: Person[isAlive]): Unit = ()

///
/// We can implement a more sophisticated version of born.
///
/// If two persons have a child then that child is a vampire if one of them is.
///
/// Note that here we use the type-level computation `isAlive1 and isAlive2`
/// to compute whether the result is alive or undead.
///
def offspring(p1: Person[isAlive1], p2: Person[isAlive2]): Person[isAlive1 and isAlive2] =
    match (p1, p2) {
        case (Person.P(r1), Person.P(r2)) =&gt;
            Person.P({name = "Spawn of ${r1#name} and ${r2#name}", age = 0})
}

///
/// A person can age-- no matter if they are alive or undead.
///
/// Note that this function preserves the `isAlive` parameter. That is, if a
/// person is alive they stay alive.
///
def birthday(p: Person[isAlive]): Person[isAlive] = match p {
    case Person.P(r) =&gt; Person.P({name = r#name, age = r#age + 1})
}
</code></pre>
<p>We can now illustrate how the type system enforces certain invariants.</p>
<p>For example, the type system ensures that person cannot be bitten twice:</p>
<pre><code class="language-flix">let p = birthday(bite(born("Dracula")));
bite(p);
</code></pre>
<p>If we compile this program then the Flix compiler emits a compiler error:</p>
<pre><code>❌ -- Type Error --------------------------------------------------

&gt;&gt; Expected argument of type 'Person[true]', but got 'Person[false]'.

69 |     bite(p);
              ^
              expected: 'Person[true]'

The function 'bite' expects its 1st argument to be of type 'Person[true]'.
</code></pre>
<p>Here we have to recall that <code>true</code> means <code>Alive</code> and <code>false</code> means <code>Undead</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="common-problems"><a class="header" href="#common-problems">Common Problems</a></h1>
<ul>
<li><a href="#tostring-is-not-defined-on-a">ToString is not defined on ‘a’</a></li>
<li><a href="#records-and-complex-instances">Records and Complex Instances</a></li>
<li><a href="#expected-kind-bool-or-effect-here-but-kind-type-is-used">Expected kind ‘Bool or Effect’ here, but kind ‘Type’ is used</a></li>
</ul>
<h2 id="tostring-is-not-defined-on-a"><a class="header" href="#tostring-is-not-defined-on-a">ToString is not defined on ‘a’</a></h2>
<p>Given the program:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    let l = Nil;
    println(l)
</code></pre>
<p>The Flix compiler reports:</p>
<pre><code>❌ -- Type Error ---------------------

&gt;&gt; ToString is not defined on a. [...]

3 |     println(l)
        ^^^^^^^^^^
        missing ToString instance
</code></pre>
<p>The issue is that the empty list has the polymorphic type: <code>List[a]</code> for any
<code>a</code>. This means that Flix cannot select the appropriate <code>ToString</code> trait
instance.</p>
<p>The solution is to specify the type of the empty list. For example, we can write:</p>
<pre><code class="language-flix">def main(): Unit \ IO =
    let l: List[Int32] = Nil;
    println(l)
</code></pre>
<p>which solves the problem because Flix can find an instance of <code>ToString</code> trait
for the concrete type <code>List[Int32]</code>.</p>
<h2 id="records-and-complex-instances"><a class="header" href="#records-and-complex-instances">Records and Complex Instances</a></h2>
<p>Given the program:</p>
<pre><code class="language-flix">instance Eq[{fstName = String, lstName = String}]
</code></pre>
<p>The Flix compiler reports:</p>
<pre><code>❌ -- Instance Error --------------------------------------------------

&gt;&gt; Complex instance type '{ fstName = String, lstName = String }' in 'Eq'.

1 | instance Eq[{fstName = String, lstName = String}]
             ^^
             complex instance type
</code></pre>
<p>This is because, at least for the moment, it is not possible to define
trait instances on records (or Datalog schema rows). This may change in the
future. Until then, it is necessary to wrap the record in an algebraic data
type. For example:</p>
<pre><code class="language-flix">enum Person({fstName = String, lstName = String})
</code></pre>
<p>and then we can implement <code>Eq</code> for the <code>Person</code> type:</p>
<pre><code class="language-flix">instance Eq[Person] {
    pub def eq(x: Person, y: Person): Bool =
        let Person(r1) = x;
        let Person(r2) = y;
        r1#fstName == r2#fstName and r1#lstName == r2#lstName
}
</code></pre>
<h2 id="expected-kind-bool-or-effect-here-but-kind-type-is-used"><a class="header" href="#expected-kind-bool-or-effect-here-but-kind-type-is-used">Expected kind ‘Bool or Effect’ here, but kind ‘Type’ is used</a></h2>
<p>Given the program:</p>
<pre><code class="language-flix">enum A[a, b, ef] {
    case A(a -&gt; b \ ef)
}
</code></pre>
<p>The Flix compiler reports:</p>
<pre><code>❌ -- Kind Error -----------------------------------------------

&gt;&gt; Expected kind 'Bool or Effect' here, but kind 'Type' is used.

2 |     case A(a -&gt; b \ ef)
                        ^^
                        unexpected kind.

Expected kind: Bool or Effect
Actual kind:   Type
</code></pre>
<p>This is because Flix assumes every un-annotated type variable to have kind
<code>Type</code>. However, in the above case <code>a</code> and <code>b</code> should have kind <code>Type</code>, but <code>ef</code>
should have kind <code>Bool</code>. We can make this explicit like so:</p>
<pre><code class="language-flix">enum A[a: Type, b: Type, ef: Bool] {
    case A(a -&gt; b \ ef)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<h2 id="does-flix-supports-constants"><a class="header" href="#does-flix-supports-constants">Does Flix supports constants?</a></h2>
<p>Yes and no. Flix does not support top-level constants. You can, however, declare
a pure function which takes zero arguments:</p>
<pre><code class="language-flix">def pi(): Float64 = 3.14f64
</code></pre>
<p>The Flix compiler will inline such constants.</p>
<p>If you have an expensive computation that you want to perform once, you should
compute it where needed and explicitly pass it around. Flix does not support
top-level constants because they violate the principle that no code should be
executed before main.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p><em><strong>Algebraic Data Type.</strong></em> A data type defined using sum and product types, i.e.
using enumerated types and tuple types.</p>
<p><em><strong>Algebraic Effect.</strong></em>  <a name="associated-effect"></a> A user-defined effect
which can be handled. The handler is supplied with the (delimited) continuation
of the effect. The continuation can be dropped, resume once, or resumed
multiple-times.</p>
<p><em><strong>Associated Type.</strong></em>  <a name="associated-type"></a> A type that belongs to a
trait. Each trait instance specifies the specific associated type for that
instance. Hence different trait instances can have different associated types.</p>
<p><em><strong>Associated Effect.</strong></em> An effect that belongs to a trait. Each trait instance
specifies the specific associated effect for that instance. Hence different
trait instances can have different associated effects.</p>
<p><em><strong>Checked Cast.</strong></em> A safe cast that the compiler ensures is correct. Cannot
fail at runtime.</p>
<p><em><strong>Effect.</strong></em> Flix supports three types of effects: built-in effects (e.g.
<code>IO</code> and <code>NonDet</code>), region-based effects, and user-defined effects.</p>
<p><em><strong>Effect Cast.</strong></em> A cast that changes the <em>effect</em> of an expression.</p>
<p><em><strong>Effect Member.</strong></em> See <a href="#associated-effect">associated effect</a>.</p>
<p><em><strong>Effect Polymorphic.</strong></em> A function whose effect(s) depend on the effect(s) of
its function argument. See also <a href="#higher-order-function">higher-order function</a>.</p>
<p><em><strong>Effect Handler.</strong></em> An expression which handles a user-defined effect.</p>
<p><em><strong>Higher-Order Function.</strong></em> <a name="higher-order-function"></a> A function
that takes a function argument or returns a function.</p>
<p><em><strong>IO Effect.</strong></em> A built-in generic effect which represents any interaction with
the outside world.</p>
<p><em><strong>Pure.</strong></em> A function (or expression) which has no effects.</p>
<p><em><strong>String Interpolation.</strong></em> A language feature that allows a string to contain
expressions.</p>
<p><em><strong>Tail Call.</strong></em> A function call in tail-position and hence does not require
additional stack space.</p>
<p><em><strong>Trait.</strong></em> An interface that specifies a collection of function signatures and
default functions. A trait can be implemented by several data types. Traits in
Flix are type classes.</p>
<p><em><strong>Type Class.</strong></em> See Trait.</p>
<p><em><strong>Type Cast.</strong></em> A cast that changes the <em>type</em> of an expression.</p>
<p><em><strong>Type Inference.</strong></em> A language feature that allows the compiler to infer the
type of an expression without requiring annotations from the programmer.</p>
<p><em><strong>Type Match.</strong></em> A language feature that allows a function to inspect (reflect)
on a type.</p>
<p><em><strong>Type Member.</strong></em> See <a href="#associated-type">associated type</a>.</p>
<p><em><strong>Unchecked Cast.</strong></em> An unsafe cast which is not verified by the compiler. Can
fail at runtime.</p>
<p><em><strong>Uninterpretable Effect.</strong></em> An effect that cannot (or should not) be handled, e.g. <code>IO</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="additional-information"><a class="header" href="#additional-information">Additional Information</a></h1>
<p>More information about the Flix programming language can be found in:</p>
<ul>
<li>The <a href="#research-literature">research literature</a> written by programming
language researchers.</li>
<li>A series of <a href="#blog-posts">blog posts</a> written by the community.</li>
</ul>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If you have a question or comment we are happy to help you out on our Gitter
channel:</p>
<p><a href="https://gitter.im/flix/Lobby">https://gitter.im/flix/Lobby</a></p>
<h2 id="reporting-a-bug"><a class="header" href="#reporting-a-bug">Reporting a Bug</a></h2>
<p>If you encounter a bug, you can report it here:</p>
<p><a href="https://github.com/flix/flix/issues">https://github.com/flix/flix/issues</a></p>
<p>but first you may wish to talk to us on Gitter.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="research-literature"><a class="header" href="#research-literature">Research Literature</a></h1>
<p>The following research papers cover specific aspects of Flix:</p>
<ul>
<li><a href="https://dl.acm.org/doi/10.1145/3563835.3567661">The Principles of the Flix Programming Language</a></li>
<li><a href="https://ceur-ws.org/Vol-3203/short8.pdf">Flix: A Meta Programming Language for Datalog</a></li>
<li><a href="https://dl.acm.org/doi/abs/10.1145/3485487">Relational Nullable Types with Boolean Unification</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/3428193">Fixpoints for the Masses: Programming with First-Class Datalog Constraints</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/3428222">Polymorphic Types and Effects with Boolean Unification</a></li>
<li><a href="https://dl.acm.org/doi/abs/10.1145/3236950.3236953">Implicit Parameters for Logic Programming</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/3213846.3213847">Safe and Sound Program Analysis with Flix</a></li>
<li><a href="https://dl.acm.org/doi/abs/10.1145/3178372.3179499">Tail Call Elimination and Data Representation for Functional Languages on the Java Virtual Machine</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/2980983.2908096">From Datalog to Flix: A Declarative Language for Fixed Points on Lattices</a></li>
<li><a href="https://staticanalysis.org/tapas2016/abstracts/TAPAS_2016_MadsenEtAl.pdf">Programming a Dataflow Analysis in Flix</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="blog-posts"><a class="header" href="#blog-posts">Blog Posts</a></h1>
<p>A few people are writing about various aspects of Flix on their blogs:</p>
<p><strong>Valentin Erokhin</strong> is writing blog posts on effect handlers and Flix:</p>
<ul>
<li><a href="https://www.relax.software/blog/flix-effects-intro/">Algebraic Effects in Practice with Flix</a></li>
</ul>
<p><strong>Paul Butcher</strong> is writing a blog post series on Flix:</p>
<ul>
<li><a href="https://paulbutcher.com/datalog1.html">An introduction to Datalog in Flix: Part 1</a></li>
<li><a href="https://paulbutcher.com/datalog2.html">An introduction to Datalog in Flix: Part 2</a></li>
<li><a href="https://paulbutcher.com/datalog3.html">An introduction to Datalog in Flix: Part 3</a></li>
<li><a href="https://paulbutcher.com/datalog4.html">An introduction to Datalog in Flix: Part 4</a></li>
</ul>
<p><strong>Susan Potter</strong> is writing a blog post series on Flix:</p>
<ul>
<li><a href="https://www.susanpotter.net/software/getting-started-with-flix-part-0/">Getting Started with Flix, Part 0</a></li>
<li><a href="https://www.susanpotter.net/software/flix-series-part-1-higher-order-functions-infix-combinators/">Higher-order functions &amp; infix combinators, Part 1</a></li>
</ul>
<p><strong>Jesse Claven</strong> wrote a blog post on logic programming in Flix:</p>
<ul>
<li><a href="https://j-e-s-s-e.com/notes/programming-imperative-to-functional-to-logic">Programming: Imperative to Functional to Logic</a></li>
</ul>
<p><strong>Magnus Madsen</strong> wrote a few blog posts on Flix during COVID:</p>
<ul>
<li><a href="https://blog.flix.dev/blog/effect-systems-vs-print-debugging/">Effect Systems vs Print Debugging: A Pragmatic Solution</a></li>
<li><a href="https://blog.flix.dev/blog/in-defense-of-programming-languages/">In Defense of Programming Languages</a></li>
<li><a href="https://blog.flix.dev/blog/taming-impurity-with-polymorphic-effects/">Taming Impurity with Polymorphic Effects</a></li>
<li><a href="https://blog.flix.dev/blog/naming-functional-and-destructive-operations/">Naming Functional and Destructive Operations</a></li>
<li><a href="https://blog.flix.dev/blog/redundancies-as-compile-time-errors/">Redundancies as Compile-Time Errors</a></li>
<li><a href="https://blog.flix.dev/blog/design-flaws-in-flix/">Design Flaws in Flix</a></li>
</ul>
<p><strong>Lutz Hühnken</strong> wrote a blog post on Flix for Java progammers:</p>
<ul>
<li><a href="https://www.reactivesystems.eu/2022/06/24/flix-for-java-programmers.html">Flix For Java Programmers</a></li>
</ul>
<p><strong>Varun Gandhi</strong> wrote a critical blog post about the value of effects, using Flix as an example:</p>
<ul>
<li><a href="https://typesanitizer.com/blog/effects-convo.html">On the purported benefits of effect systems</a></li>
</ul>
<p><strong>Magnus Madsen</strong> did an interview about Flix on the Happy Path Programming podcast:</p>
<ul>
<li><a href="https://anchor.fm/happypathprogramming/episodes/54-Flix-Designing-a-principled-programming-language-with-Magnus-Madsen-e1dueb2">Episode 54 Flix: Designing a principled programming language with Magnus Madsen</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="videos"><a class="header" href="#videos">Videos</a></h1>
<p>A collection of videos about Flix.</p>
<h2 id="industry-talks"><a class="header" href="#industry-talks">Industry Talks</a></h2>
<ul>
<li>Magnus Madsen @ LambdaDays 2025: <a href="https://www.youtube.com/watch?v=DHB4SvB7g84">An Introduction to Effectful Programming in Flix</a> (<a href="https://flix.dev/talks/lambdadays2025.pdf">slides</a>)</li>
<li>Magnus Madsen @ Devoxx Greece 2025: <a href="https://www.youtube.com/watch?v=o7-JWY0uLmc">Effectful Programming in the Flix Programming Language</a> (<a href="https://flix.dev/talks/devoxx2025.pdf">slides</a>)</li>
<li>Magnus Madsen @ Goto 2023: <a href="https://www.youtube.com/watch?v=2LSOqikNqxM">An Introduction to Functional Imperative Programming in Flix</a></li>
</ul>
<h2 id="research-talks"><a class="header" href="#research-talks">Research Talks</a></h2>
<ul>
<li>Matthew Lutze @ PLDI 2024: <a href="https://www.youtube.com/watch?v=HoJaLJEPXW8">Associated Effects: Flexible Abstractions for Effectful Programming</a></li>
<li>Matthew Lutze @ ICFP 2023:<a href="https://www.youtube.com/watch?v=IyLNJh4Eq0c">With or Without You: Programming with Effect Exclusion</a></li>
<li>Magnus Madsen @ Onward 2022: <a href="https://www.youtube.com/watch?v=RNZeAmp1EaA">The Principles of the Flix Programming Language</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<p>The appendix covers technical details such as:</p>
<ul>
<li><a href="#identifiers">Legal Identifiers</a></li>
<li><a href="#precedence">Operator Precedence</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<p>Flix has several types of identifiers:</p>
<ul>
<li><strong>Uppercase name:</strong> An identifier that starts with an uppercase letter followed by any number of uppercase and lowercase letters, underscore, and exclamation mark (<code>A</code>…<code>Z</code>, <code>a</code>…<code>z</code>, <code>_</code>, <code>!</code>).
<ul>
<li>e.g. <code>String</code>, <code>ALL_UPPER</code>, <code>Shriek!</code></li>
<li>Can be used to name: namespaces, annotations, traits, effects, predicates (within datalog), tags (within enums), types</li>
</ul>
</li>
<li><strong>Lowercase name:</strong> An identifier that starts with a lowercase letter followed by any number of uppercase and lowercase letters, underscore, and exclamation mark (<code>A</code>…<code>Z</code>, <code>a</code>…<code>z</code>, <code>_</code>, <code>!</code>).
<ul>
<li>e.g. <code>anIdentifier</code>, <code>x</code>, <code>this_and_that</code></li>
<li>Can be used to name: annotations, attributes (within datalog), functions, labels (within records), variables</li>
</ul>
</li>
<li><strong>Greek name:</strong> An identifier consisting of any combination of letters from the Greek alphabet (the unicode range U+0370 to U+03FF).
<ul>
<li>e.g. <code>Χαίρετε</code>, <code>αναγνωριστικό</code></li>
<li>Can be used to name: functions, variables</li>
</ul>
</li>
<li><strong>Math name:</strong> An identifier consisting of any combination of math symbols (the unicode range U+2190 to U+22FF).
<ul>
<li>e.g. <code>⊆</code>, <code>√</code>, <code>⊙</code></li>
<li>Can be used to name: functions, variables</li>
</ul>
</li>
<li><strong>Operator name:</strong> An identifier of minimum length 2 consisting of any combination of <code>+</code>, <code>-</code>, <code>*</code>, <code>&lt;</code>, <code>&gt;</code>, <code>=</code>, <code>!</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, and <code>$</code>.
<ul>
<li>e.g. <code>&gt;==&gt;</code>, <code>&lt;*&gt;</code></li>
<li>Can be used to name: functions</li>
</ul>
</li>
</ul>
<p>Note that greek letters, math symbols, and operator letters cannot be combined within a single identifier.</p>
<h2 id="reserved-identifiers"><a class="header" href="#reserved-identifiers">Reserved Identifiers</a></h2>
<p>The following are reserved by Flix and cannot be redefined within user code:</p>
<p><code>!=</code>, <code>**</code>, <code>..</code>, <code>::</code>, <code>:=</code>, <code>&lt;-</code>, <code>&lt;=</code>, <code>==</code>, <code>=&gt;</code>, <code>&gt;=</code>, <code>or</code>,
<code>&amp;&amp;&amp;</code>, <code>&lt;+&gt;</code>, <code>&lt;&lt;&lt;</code>, <code>&lt;=&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>???</code>, <code>^^^</code>, <code>and</code>, <code>mod</code>, <code>not</code>, <code>|||</code>, <code>~~~</code>,
<code>$DEFAULT$</code>, <code>*</code>, <code>+</code>, <code>-</code>, <code>/</code>, <code>:</code>, <code>&lt;</code>,
<code>&gt;</code>, <code>@</code>, <code>Absent</code>, <code>Bool</code>, <code>Impure</code>, <code>Nil</code>, <code>Predicate</code>, <code>Present</code>, <code>Pure</code>,
<code>Read</code>, <code>RecordRow</code>, <code>Region</code>, <code>SchemaRow</code>, <code>Type</code>, <code>Write</code>, <code>alias</code>, <code>case</code>, <code>catch</code>, <code>chan</code>,
<code>class</code>, <code>def</code>, <code>deref</code>, <code>else</code>, <code>enum</code>, <code>false</code>, <code>fix</code>, <code>force</code>,
<code>if</code>, <code>import</code>, <code>inline</code>, <code>instance</code>, <code>into</code>, <code>lat</code>, <code>law</code>, <code>lawful</code>, <code>lazy</code>, <code>let</code>, <code>match</code>,
<code>mod</code>, <code>null</code>, <code>opaque</code>, <code>pub</code>, <code>redef</code>, <code>ref</code>, <code>region</code>, <code>reify</code>,
<code>reifyBool</code>, <code>reifyEff</code>, <code>reifyType</code>, <code>rel</code>, <code>sealed</code>, <code>set</code>, <code>spawn</code>, <code>Static</code>, <code>trait</code>, <code>true</code>,
<code>type</code>, <code>use</code>, <code>where</code>, <code>with</code>, <code>discard</code>, <code>object</code>, <code>choose</code>, <code>solve</code>, <code>inject</code>, <code>project</code></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="precedence"><a class="header" href="#precedence">Precedence</a></h1>
<ol>
<li>Unary operators (<code>+</code>, <code>-</code>, <code>~~~</code>, and <code>not</code>)</li>
<li>User-defined operators (including operators defined in the standard library such as <code>|&gt;</code>)</li>
<li>Functions applied infix with backticks</li>
<li>Composition (<code>&lt;+&gt;</code>)</li>
<li>Multiplicative (<code>**</code>, <code>*</code>, and <code>/</code>)</li>
<li>Additive (<code>+</code> and <code>-</code>)</li>
<li>Shift (<code>&lt;&lt;&lt;</code> and <code>&gt;&gt;&gt;</code>)</li>
<li>Comparison (<code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, and <code>&gt;</code>)</li>
<li>Equality (<code>==</code>, <code>!=</code>, and <code>&lt;==&gt;</code>)</li>
<li>Bitwise And (<code>&amp;&amp;&amp;</code>)</li>
<li>Bitwise Xor (<code>^^^</code>)</li>
<li>Bitwise Or (<code>|||</code>)</li>
<li>Logical <code>and</code></li>
<li>Logical <code>or</code></li>
<li>Channel <code>&lt;-</code></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-066eac05.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
